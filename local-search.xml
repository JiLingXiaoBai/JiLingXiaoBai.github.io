<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>WorkFlow</title>
    <link href="/posts/WorkFlow/"/>
    <url>/posts/WorkFlow/</url>
    
    <content type="html"><![CDATA[<h2 id="Upgrade-PowerShell">Upgrade PowerShell</h2><p>Execute the following command in PowerShell</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">winget search Microsoft.PowerShell<br></code></pre></td></tr></table></figure><p>get the output like this</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">Name               Id                           Version Source<br>---------------------------------------------------------------<br>PowerShell         Microsoft.PowerShell         7.5.1.0 winget<br>PowerShell Preview Microsoft.PowerShell.Preview 7.6.0.4 winget<br></code></pre></td></tr></table></figure><p>then execute the following command</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">winget install --<span class="hljs-built_in">id</span> Microsoft.PowerShell --<span class="hljs-built_in">source</span> winget<br></code></pre></td></tr></table></figure><p>or just goto <a href="https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows">official website</a> to get the latest version</p><h2 id="Scoop">Scoop</h2><p>Execute the following commands in PowerShell as Administrator</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser<br><br>Invoke-RestMethod -Uri https://get.scoop.sh | Invoke-Expression<br></code></pre></td></tr></table></figure><p>then install git with scoop</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">scoop install git<br></code></pre></td></tr></table></figure><p>setup git <a href="http://user.name">user.name</a> and user.email</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global user.name <span class="hljs-string">&quot;your name&quot;</span><br>git config --global user.email <span class="hljs-built_in">test</span>@youremail.com<br></code></pre></td></tr></table></figure><h2 id="Yazi">Yazi</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">scoop install ffmpeg 7zip jq poppler fd ripgrep fzf zoxide resvg imagemagick ghostscript yazi<br></code></pre></td></tr></table></figure><p>goto <code>C:\Users\&lt;Username&gt;\Documents\PowerShell\Microsoft.PowerShell_profile.ps1</code>, if  it doesn’t exist, create it</p><p>append the following lines to the file</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-keyword">function</span> y &#123;<br>    <span class="hljs-variable">$tmp</span> = [System.IO.Path]::GetTempFileName()<br>    yazi <span class="hljs-variable">$args</span> --cwd-file=<span class="hljs-string">&quot;<span class="hljs-variable">$tmp</span>&quot;</span><br>    <span class="hljs-variable">$cwd</span> = Get-Content -Path <span class="hljs-variable">$tmp</span> -Encoding UTF8<br>    <span class="hljs-keyword">if</span> (-not [String]::IsNullOrEmpty(<span class="hljs-variable">$cwd</span>) -and <span class="hljs-variable">$cwd</span> -ne <span class="hljs-variable">$PWD</span>.Path) &#123;<br>        Set-Location -LiteralPath ([System.IO.Path]::GetFullPath(<span class="hljs-variable">$cwd</span>))<br>    &#125;<br>    Remove-Item -Path <span class="hljs-variable">$tmp</span><br>&#125;<br></code></pre></td></tr></table></figure><p>goto <code>C:\Users\&lt;Username&gt;\AppData\Roaming\yazi\config\yazi.toml</code>, if  it doesn’t exist, create it</p><p>append the following lines to the file</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[manager]</span><br><span class="hljs-attr">show_hidden</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[opener]</span><br><span class="hljs-attr">edit</span> = [<br>&#123;run = <span class="hljs-string">&#x27;nvim %*&#x27;</span>, block = <span class="hljs-literal">true</span>, desc = <span class="hljs-string">&quot;nvim&quot;</span>, for = <span class="hljs-string">&quot;windows&quot;</span> &#125;,<br>]<br><br><span class="hljs-section">[open]</span><br><span class="hljs-attr">prepend_rules</span> = [<br>&#123; name = <span class="hljs-string">&quot;*.json&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>&#123; name = <span class="hljs-string">&quot;*.toml&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>&#123; name = <span class="hljs-string">&quot;*.html&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>&#123; name = <span class="hljs-string">&quot;*.c&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>&#123; name = <span class="hljs-string">&quot;*.cpp&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>&#123; name = <span class="hljs-string">&quot;*.h&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>&#123; name = <span class="hljs-string">&quot;*.cs&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>&#123; name = <span class="hljs-string">&quot;*.md&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>&#123; name = <span class="hljs-string">&quot;*.lua&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>]<br><span class="hljs-attr">append_rules</span> = [<br>&#123; name = <span class="hljs-string">&quot;*&quot;</span>, use = [ <span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-string">&quot;reveal&quot;</span> ] &#125;,<br>]<br></code></pre></td></tr></table></figure><p>Yazi relies on <code>file(1)</code> to detect the mime-type of the file, and the easiest and most reliable way to get it on Windows<br>is to install Git for Windows and use the <code>file.exe</code> that comes with it.</p><ol><li>Install Git for Windows by running <a href="https://git-scm.com/downloads/win">the official installer</a>, or through your package manager of choice.</li><li>To allow Yazi to use <code>file(1)</code>, add &lt;Git_Installed_Directory&gt;\usr\bin\file.exe to your <code>YAZI_FILE_ONE</code> environment variable,<br>which differs depending on how you installed Git:</li></ol><ul><li>If you installed Git with the installer, it would be <code>C:\Program Files\Git\usr\bin\file.exe</code>.</li><li>If you installed Git with Scoop, it would be <code>C:\Users\&lt;Username&gt;\scoop\apps\git\current\usr\bin\file.exe</code>.</li></ul><ol start="3"><li>Restart your terminal.</li></ol><h2 id="Neovim">Neovim</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">scoop bucket add nerd-fonts<br>scoop install Hack-NF-Mono<br>scoop install make unzip gcc recycle-bin<br></code></pre></td></tr></table></figure><p>Goto <code>C:\Users\&lt;Username&gt;\AppData\Local</code>, clone the repo here</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/JiLingXiaoBai/nvim.git<br></code></pre></td></tr></table></figure><h2 id="Windows-Terminal">Windows Terminal</h2><p>Modify <code>settings.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;$help&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://aka.ms/terminal-documentation&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;$schema&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://aka.ms/terminal-profiles-schema&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;actions&quot;</span><span class="hljs-punctuation">:</span> <br>    <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;copy&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;singleLine&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User.copy.644BA8F2&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;paste&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User.paste&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;find&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User.find&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;splitPane&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;split&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;auto&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;splitMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;duplicate&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User.splitPane.A6751878&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;alwaysShowTabs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;copyFormatting&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;none&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;copyOnSelect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;defaultProfile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;&lt;your default profile&gt;&#125;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keybindings&quot;</span><span class="hljs-punctuation">:</span> <br>    <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User.copy.644BA8F2&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;keys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ctrl+c&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User.find&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;keys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ctrl+shift+f&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User.paste&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;keys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ctrl+v&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User.splitPane.A6751878&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;keys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;alt+shift+d&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;newTabMenu&quot;</span><span class="hljs-punctuation">:</span> <br>    <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;remainingProfiles&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;profiles&quot;</span><span class="hljs-punctuation">:</span> <br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;defaults&quot;</span><span class="hljs-punctuation">:</span> <br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;colorScheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arcoiris&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cursorShape&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;filledBox&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;font&quot;</span><span class="hljs-punctuation">:</span> <br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;face&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Hack Nerd Font Mono&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;opacity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">37</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;padding&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;scrollbarState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hidden&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;useAcrylic&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;list&quot;</span><span class="hljs-punctuation">:</span> <br>        <span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span>&lt;your profile lists&gt;<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;schemes&quot;</span><span class="hljs-punctuation">:</span> <br>    <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;background&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#201F1E&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;black&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#333333&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;blue&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#518BFC&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;brightBlack&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#777777&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;brightBlue&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#B3E8F3&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;brightCyan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#BCFFC7&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;brightGreen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#E3F6AA&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;brightPurple&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#CBBAF9&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;brightRed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#FFB9B9&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;brightWhite&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#EFEFEF&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;brightYellow&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#FFDDAA&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cursorColor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#4FBD04&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cyan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#63FAD5&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#EEE4D9&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;green&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#12C258&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arcoiris&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;purple&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#E37BD9&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;red&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#DA2700&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;selectionBackground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#25524A&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;white&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#BAB2B2&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;yellow&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#FFC656&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;showTabsInTitlebar&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;theme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dark&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;themes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;useAcrylicInTabRow&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Workflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Workflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Delaunay-Triangulation</title>
    <link href="/posts/Delaunay-Triangulation/"/>
    <url>/posts/Delaunay-Triangulation/</url>
    
    <content type="html"><![CDATA[<h1>Delaunay 三角形化</h1><p>Delaunay三角形化，也叫Delaunay三角剖分，是一种三角剖分算法，它的作用是把一个平面上的点集，按照一定的规则，分成若干个三角形。这些三角形有以下特点：</p><ul><li>这些三角形互不重叠</li><li>这些三角形可以覆盖整个平面</li><li>每个点均不位于不包含该点的三角形的外接圆内（即：在某个三角形的外接圆内，只包含在外接圆上的三个点，不包含其他点）</li></ul><p>Delaunay 三角形化的优点：</p><ul><li>最小角的最大化（所形成的最小角是所有连接方式形成的最小角中的最大者）</li><li>生成的三角形边长的均匀性最好，最接近正三角形</li></ul><h2 id="Delaunay-三角形化方法">Delaunay 三角形化方法</h2><p><img src="/posts_image/DelaunayTriangulation/DelaunayTriangulation_1.png" alt=""></p><p>如上图所示的求解区域为例，1~5是边界点，6为内部点，其初始化 Delaunay 三角形的过程如下：</p><ol><li>包围该求解区域的各边界点做一个辅助正四边形及两个三角形 $\triangle{790}$，$\triangle{789}$，显然这两个三角形为 Delaunay 三角形；</li><li>首先考虑节点1，它位于$\triangle{790}$和$\triangle{789}$的外接圆内；</li><li>消去公共线79，连接点1与四个顶点（0，7，8，9）；</li><li>考虑点2，它位于$\triangle{178}$和$\triangle{189}$的外接圆内；</li><li>消去公共线18，连接点2与四个顶点（1，7，8，9）；</li><li>采用同样的方法依次考虑点3、4、5，最后形成图（f）所示情况，注意不一定位于两个外接圆内，可能更多，即公共线也更多</li></ol><p><img src="/posts_image/DelaunayTriangulation/DelaunayTriangulation_2.png" alt=""></p><ol start="7"><li>删除所有重心不在求解区域的三角形得到图（g）所示的初始化 Delaunay 三角形；</li><li>由于点6为内部点，它位于$\triangle{145}$、$\triangle{142}$ 和 $\triangle{234}$ 外接圆内，因此需要消去公共线14、24，连接点6与五个顶点（1，2，3，4，5）；</li></ol><h2 id="如何向求解区域内设点">如何向求解区域内设点</h2><p>为了能方便控制区域内点附近网格的疏密，引入两个几何参数</p><ol><li>长度标尺，长度标尺的大小代表边界上网格疏密的程度，网格点越稠密的地方，长度标尺越小，网格点越稀疏的地方，长度标尺越大；</li><li>三角形外接圆无量纲半径，判断三角形偏离正三角形的严重程度，$R(k)$越大偏离越严重，首先应该往$R(k)$较大的三角形中添加点以改善网格质量；</li></ol><h4 id="长度标尺">长度标尺</h4><p>长度标尺是赋予网格点的一个几何参数<br><img src="/posts_image/DelaunayTriangulation/DelaunayTriangulation_3.png" alt=""><br>边界网格点的长度标尺定义为：该点到边界上相邻两个边界网格点的距离的平均值的 $\sqrt{3}/2$ 倍；如点1的长度标尺为：(点1到点2的距离 + 点1到点5的距离)/2 * $\sqrt{3}/2$</p><p>内部网格点的长度标尺采用下列倒数原则，由边界网格点的长度标尺插值而得；设Q点是要插入到$\triangle{145}$中的一点，则：<br>$$<br>L(Q) = \frac{L(1)/l_1 + L(4)/l_4 + L(5)/l_5}{1/l_1 + 1/l_4 + 1/l_5}<br>$$<br>式中，$L(1)$，$L(4)$，$L(5)$ 分别为点1，点4，点5的长度标尺，$l_1$, $l_4$, $l_5$ 分别为点Q到点1，点4，点5的距离；</p><h4 id="三角形外接圆无量纲半径">三角形外接圆无量纲半径</h4><p>设任意一个 Delaunay 三角形为 $\triangle{k}$，其外接圆的半径为 $r(k)$，其外接圆的圆心长度标尺为 $L(k)$，则其外接圆无量纲半径 $R(k)$ 为：<br>$$<br>R(k) = \frac{r(k)}{L(k)}<br>$$<br>正三角形的外接圆无量纲半径最小，值为2/3</p><h4 id="步骤">步骤</h4><ol><li>计算所有已生成的 Delaunay 三角形的外接圆圆心的长度标尺 $L(k)$ 以及外接圆半径 $r(k)$；</li><li>计算所有三角形的外接圆无量纲半径 $R(k)$；</li><li>对所有现存三角形按 $R(k)$ 从大到小排序；</li><li>在 $R(k)$ 最大的三角形的外接圆圆心处添加新的点Q；</li><li>利用 Delaunay 三角形化方法，生成一组新的 Delaunay 三角形；</li><li>返回第一步，重复加点动作，直到满足要求；</li></ol>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# List&lt;T&gt;</title>
    <link href="/posts/CSharpList/"/>
    <url>/posts/CSharpList/</url>
    
    <content type="html"><![CDATA[<h1>List&lt;T&gt;</h1><p>泛型 List 在底层实现中是由数组来承载数据，所以又被称为“动态数组”。数组的大小即为容量(capacity)，可以手动或自动地调整。当容量不足时，会自动创建一个更长的数组，将原数组中的内容复制到新的数组中实现扩容。默认新创建的不含任何元素的 List 容量为 0，加入一个元素后容量为 4，容量不足时进行二倍扩容，即容量变为 8、16、32… 当 List 调用 Clear 方法后，其数组长度即容量不变。泛型 List 与非泛型的 ArrayList 相对应，后者元素都为 object 类型。</p><style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><div class="center"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Category</th><th style="text-align:left">Member</th></tr></thead><tbody><tr><td style="text-align:left">Create</td><td style="text-align:left">Constructor</td><td style="text-align:left">List&lt;T&gt;()</td></tr><tr><td style="text-align:left">Create</td><td style="text-align:left">Constructor</td><td style="text-align:left">List&lt;T&gt;(IEnumerable&lt;T&gt;)</td></tr><tr><td style="text-align:left">Create</td><td style="text-align:left">Constructor</td><td style="text-align:left">List&lt;T&gt;(Int32)</td></tr><tr><td style="text-align:left">Create</td><td style="text-align:left"></td><td style="text-align:left">Add(T)</td></tr><tr><td style="text-align:left">Create</td><td style="text-align:left"></td><td style="text-align:left">AddRange(IEnumerable&lt;T&gt;)</td></tr><tr><td style="text-align:left">Create</td><td style="text-align:left"></td><td style="text-align:left">Insert(Int32, T)</td></tr><tr><td style="text-align:left">Create</td><td style="text-align:left"></td><td style="text-align:left">InsertRange(Int32, IEnumerable&lt;T&gt;)</td></tr><tr><td style="text-align:left">Delete</td><td style="text-align:left"></td><td style="text-align:left">Clear()</td></tr><tr><td style="text-align:left">Delete</td><td style="text-align:left"></td><td style="text-align:left">RemoveAt(Int32)</td></tr><tr><td style="text-align:left">Delete</td><td style="text-align:left"></td><td style="text-align:left">RemoveRange(Int32, Int32)</td></tr><tr><td style="text-align:left">Delete</td><td style="text-align:left"></td><td style="text-align:left">Remove(T)</td></tr><tr><td style="text-align:left">Delete</td><td style="text-align:left"></td><td style="text-align:left">RemoveAll(Predicate&lt;T&gt;)</td></tr></tbody></table></div><ul><li>Add(T) 和 AddRange(IEnumerable&lt;T&gt;) 是在 List 最后添加新的元素。</li><li>Insert(Int32, T) 和 InsertRange(Int32, IEnumerable&lt;T&gt;) 是在指定位置插入元素，会造成被插入位置和其后的所有元素整体后移。</li><li>RemoveAt(Int32) 和 RemoveRange(Int32, Int32) 是移除指定位置的元素，会造成被移除元素位置之后的所有元素整体前移。</li><li>Remove(T) 是移除特定对象的第一个匹配项，RemoveAll(Predicate&lt;T&gt;) 的参数是一个参数为 T，返回值为 bool 类型的委托，它会移除与指定的委托所定义的条件相匹配的所有元素。也会造成被移除元素位置之后的所有元素整体前移。</li></ul><div class="center"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Category</th><th style="text-align:left">Member</th></tr></thead><tbody><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">Count</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">Capacity</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">Item[Int32]</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">GetRange(Int32, Int32)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left">Iterate</td><td style="text-align:left">GetEnumerator()</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left">Iterate</td><td style="text-align:left">ForEach(Action&lt;T&gt;)</td></tr></tbody></table></div><ul><li>Count 是当前列表中元素的个数，Capacity 是列表容量，即数组的长度，Item[Int32] 是索引器，即可以使用数组下标访问元素。</li><li>GetRange(Int32, Int32) 参数分别为起始索引和终止索引，将当前列表中从起始索引到终止索引的元素加入子列表，将子列表返回。</li><li>GetEnumerator() 拿到迭代器，调用返回值为 bool 类型的 MoveNext() 方法进行遍历，迭代器的指针默认指向的并不是 list 中的第一个元素，而是第一个元素之前的位置，遍历所有元素后会指向 list 之外的位置，所以遍历 list 最好使用 foreach。</li><li>使用 foreach 进行遍历时不可以添加或者删除元素，可以修改元素内部的属性值，但是不可以修改元素本身的值。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;&#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">400</span>&#125;;<br><span class="hljs-keyword">var</span> e = intList.GetEnumerator();<br>Console.WriteLine(e.Current);<br><span class="hljs-keyword">while</span>(e.MoveNext())&#123;<br>    Console.WriteLine(e.Current);<br>&#125;<br>Console.WriteLine(e.Current);<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//100</span><br><span class="hljs-comment">//200</span><br><span class="hljs-comment">//300</span><br><span class="hljs-comment">//400</span><br><span class="hljs-comment">//0</span><br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">var</span> val <span class="hljs-keyword">in</span> intList)&#123;<br>    Console.WriteLine(val);<br>    <span class="hljs-comment">//val++; //invalid 不可以修改元素本身的值</span><br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//100</span><br><span class="hljs-comment">//200</span><br><span class="hljs-comment">//300</span><br><span class="hljs-comment">//400</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id&#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name&#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> Price&#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;<br>&#125;<br>List&lt;Book&gt; bookList = <span class="hljs-keyword">new</span> List&lt;Book&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++;)<br>    bookList.Add(<span class="hljs-keyword">new</span> Book&#123;Id = i, Name = <span class="hljs-string">$&quot;Book-<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>, Price = <span class="hljs-number">10</span> * i&#125;);<br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">var</span> val <span class="hljs-keyword">in</span> bookList)&#123;<br>    val.Price++; <span class="hljs-comment">//valid 可以修改元素的属性的值 </span><br>&#125;<br></code></pre></td></tr></table></figure><div class="center"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Category</th><th style="text-align:left">Member</th></tr></thead><tbody><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">Contains(T)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">Exists(Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">TrueForAll(Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">IndexOf(T)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">IndexOf(T, Int32)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">IndexOf(T, Int32, Int32)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">LastIndexOf(T)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">LastIndexOf(T, Int32)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">LastIndexOf(T, Int32, Int32)</td></tr></tbody></table></div><ul><li>Contains(T) 确定某元素是否在列表中，返回一个 bool 值，如果 T 是引用类型，那么参数可以为 null。这里判断相等的方法是调用底层的 Equals 方法，我们可以重写 Equals 方法来改变判断的结果，从而影响 Contains 方法返回的值。</li><li>Exists(Predicate&lt;T&gt;) 确定是否含有与指定的委托所定义的条件相匹配的元素。</li><li>TrueForAll(Predicate&lt;T&gt;) 确定所有元素是否与指定的委托所定义的条件相匹配。</li><li>IndexOf(T) 返回整个列表中第一个与参数相等的元素的从零开始的索引。IndexOf(T, Int32) 返回整个列表中第一个与参数相等的元素的从指定位置开始的索引。IndexOf(T, Int32, Int32) 第二个参数为搜索开始的索引，第三个参数为要搜索的索引数。IndexOf(Item, 2, 3) 即表示从索引为 2 的位置开始向后搜索三个元素，并返回第一个与 Item 相等的元素的索引值。如果没有相等的元素，那么返回 -1，这里判断相等的方法也是调用底层的 Equals 方法。</li><li>LastIndexOf 方法和 IndexOf 方法相似，区别是 IndexOf 方法是从前往后找，LastIndexOf 方法是从后往前找。</li></ul><div class="center"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Category</th><th style="text-align:left">Member</th></tr></thead><tbody><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">Find(Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">FindLast(Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">FindAll(Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">FindIndex(Int32, Int32, Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">FindIndex(Int32, Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">FindIndex(Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">FindLastIndex(Int32, Int32, Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">FindLastIndex(Int32, Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">FindLastIndex(Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left">Algorithm</td><td style="text-align:left">BinarySearch(Int32, Int32, T, IComparer&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left">Algorithm</td><td style="text-align:left">BinarySearch(T)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left">Algorithm</td><td style="text-align:left">BinarySearch(T, IComparer&lt;T&gt;)</td></tr></tbody></table></div><ul><li>Find(Predicate&lt;T&gt;) 方法返回与指定的委托所定义的条件相匹配的元素，如果没有相匹配的元素，则返回类型 T 的默认值。</li><li>FindLast(Predicate&lt;T&gt;) 与 Find(Predicate&lt;T&gt;) 相似，区别是 Find 方法是从前往后找，FindLast 方法是从后往前找。</li><li>FindAll(Predicate&lt;T&gt;) 方法返回一个新的列表，其元素为与指定的委托所定义的条件相匹配的所有元素。</li><li>FindIndex(Int32, Int32, Predicate&lt;T&gt;) 搜索与指定委托所定义的条件相匹配的一个元素，并返回列表中从指定的索引开始、包含指定元素个数的元素范围内第一个匹配项的从零开始的索引。</li><li>FindIndex(Int32, Predicate&lt;T&gt;) 搜索与指定委托所定义的条件相匹配的元素，并返回列表中从指定索引到最后一个元素的元素范围内第一个匹配项的从零开始的索引。</li><li>FindIndex(Predicate&lt;T&gt;) 搜索与指定委托所定义的条件相匹配的元素，并返回整个列表中第一个匹配元素的从零开始的索引。</li><li>FindLastIndex 方法与 FindIndex 方法相似，区别是 FindIndex 方法是从前往后找，FindLastIndex 方法是从后往前找。</li><li>BinarySearch 二分查找，调用者需为有序列表，即二分查找前要么使用 Sort() 方法排序，这时排序的对象需要实现 IComparable 泛型接口，即实现 CompareTo 方法；要么使用带 IComparer&lt;T&gt; 参数的重载，使用此比较器进行排序。而二分查找时需调用底层的 Equals 方法来判定是否相等。BinarySearch 方法返回的是已经排好序的列表中相等元素的索引值。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Languages</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 模式匹配、析构元组和弃元</title>
    <link href="/posts/CSharp%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-%E6%9E%90%E6%9E%84%E5%85%83%E7%BB%84-%E5%BC%83%E5%85%83/"/>
    <url>/posts/CSharp%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-%E6%9E%90%E6%9E%84%E5%85%83%E7%BB%84-%E5%BC%83%E5%85%83/</url>
    
    <content type="html"><![CDATA[<h1>模式匹配</h1><p>“模式匹配”是一种测试表达式是否具有特定特征的方法。 C# 模式匹配提供更简洁的语法，用于测试表达式并在表达式匹配时采取措施。 “is 表达式”目前支持通过模式匹配测试表达式并有条件地声明该表达式结果。 “switch 表达式”允许你根据表达式的首次匹配模式执行操作。 这两个表达式支持丰富的模式词汇。</p><h2 id="Null-检查">Null 检查</h2><p>模式匹配最常见的方案之一是确保值不是 null。 使用以下示例进行 null 测试时，可以测试可为 null 的值类型并将其转换为其基础类型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span>? maybe = <span class="hljs-number">12</span>;<br><br><span class="hljs-keyword">if</span> (maybe <span class="hljs-keyword">is</span> <span class="hljs-built_in">int</span> number)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">$&quot;The nullable int &#x27;maybe&#x27; has the value <span class="hljs-subst">&#123;number&#125;</span>&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The nullable int &#x27;maybe&#x27; doesn&#x27;t hold a value&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>只判断是否为 null 值可以使用 not 模式</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span>? message = <span class="hljs-string">&quot;This is not the null string&quot;</span>;<br><br><span class="hljs-keyword">if</span> (message <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>)<br>&#123;<br>    Console.WriteLine(message);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类型测试">类型测试</h2><p>以下代码测试实现 IEnumerable 泛型接口的参数是否为 null 值，如果不是 null 值那么测试它是否也实现了 IList 泛型接口，并根据是否实现 IList 接口来查找中间索引。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">MidPoint</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">IEnumerable&lt;T&gt; sequence</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (sequence <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(sequence), <span class="hljs-string">&quot;Sequence can&#x27;t be null.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sequence <span class="hljs-keyword">is</span> IList&lt;T&gt; list)<br>    &#123;<br>        <span class="hljs-keyword">return</span> list[list.Count / <span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> halfLength = sequence.Count() / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (halfLength &lt; <span class="hljs-number">0</span>) halfLength = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> sequence.Skip(halfLength).First();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="比较离散值">比较离散值</h2><p>可以代替 switch 来对枚举中声明的所有可能值进行数值测试：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> State<br>&#123;<br>    Run,<br>    Idle,<br>    Jump<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">PerformState</span>(<span class="hljs-params">State state</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> state <span class="hljs-keyword">switch</span><br>    &#123;<br>        State.Idle =&gt; <span class="hljs-string">&quot;Idle&quot;</span>,<br>        State.Run =&gt; <span class="hljs-string">&quot;Run&quot;</span>,<br>        State.Jump =&gt; <span class="hljs-string">&quot;Jump&quot;</span>,<br>        _ =&gt; <span class="hljs-string">&quot;Invalid enum value for State&quot;</span><br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>_ 案例为与所有数值匹配的弃元模式。 它处理值与定义的 enum 值之一不匹配的任何错误条件。</p><div class="note note-warning">            <p>switch表达式是输出语句！</p>          </div><h2 id="关系模式">关系模式</h2><p>你可以使用关系模式测试如何将数值与常量进行比较。 例如，以下代码基于华氏温度返回水源状态：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">WaterState</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> tempInFahrenheit</span>)</span> =&gt;<br>    tempInFahrenheit <span class="hljs-keyword">switch</span><br>    &#123;<br>        (&gt; <span class="hljs-number">32</span>) <span class="hljs-keyword">and</span> (&lt; <span class="hljs-number">212</span>) =&gt; <span class="hljs-string">&quot;liquid&quot;</span>,<br>        &lt; <span class="hljs-number">32</span> =&gt; <span class="hljs-string">&quot;solid&quot;</span>,<br>        &gt; <span class="hljs-number">212</span> =&gt; <span class="hljs-string">&quot;gas&quot;</span>,<br>        <span class="hljs-number">32</span> =&gt; <span class="hljs-string">&quot;solid/liquid transition&quot;</span>,<br>        <span class="hljs-number">212</span> =&gt; <span class="hljs-string">&quot;liquid / gas transition&quot;</span>,<br>    &#125;;<br></code></pre></td></tr></table></figure><h2 id="多个输入">多个输入</h2><p>可以写入检查一个对象的多个属性的模式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Items;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Cost;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">decimal</span> <span class="hljs-title">CalculateDiscount</span>(<span class="hljs-params">Order order</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> order <span class="hljs-keyword">switch</span><br>    &#123;<br>        &#123; Items: &gt; <span class="hljs-number">10</span>, Cost: &gt; <span class="hljs-number">1000.00</span>m &#125; =&gt; <span class="hljs-number">0.10</span>m,<br>        &#123; Items: &gt; <span class="hljs-number">5</span>, Cost: &gt; <span class="hljs-number">500.00</span>m &#125; =&gt; <span class="hljs-number">0.05</span>m,<br>        &#123; Cost: &gt; <span class="hljs-number">250.00</span>m &#125; =&gt; <span class="hljs-number">0.02</span>m,<br>        <span class="hljs-literal">null</span> =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(order), <span class="hljs-string">&quot;Can&#x27;t calculate discount on null order&quot;</span>),<br>        <span class="hljs-keyword">var</span> someObject =&gt; <span class="hljs-number">0</span>m,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="列表模式">列表模式</h2><p>可以使用列表模式检查列表或数组中的元素。 列表模式提供了一种方法，将模式应用于序列的任何元素。 此外，还可以应用弃元模式 (_) 来匹配任何元素，或者应用切片模式来匹配零个或多个元素。</p><p>当数据不遵循常规结构时，列表模式是一个有价值的工具。 可以使用模式匹配来测试数据的形状和值，而不是将其转换为一组对象。</p><p>看看下面的内容，它摘录自一个包含银行交易信息的文本文件：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">04</span>-<span class="hljs-number">01</span>-<span class="hljs-number">2020</span>, DEPOSIT,    Initial deposit,            <span class="hljs-number">2250</span>.<span class="hljs-number">00</span><br><span class="hljs-attribute">04</span>-<span class="hljs-number">15</span>-<span class="hljs-number">2020</span>, DEPOSIT,    Refund,                      <span class="hljs-number">125</span>.<span class="hljs-number">65</span><br><span class="hljs-attribute">04</span>-<span class="hljs-number">18</span>-<span class="hljs-number">2020</span>, DEPOSIT,    Paycheck,                    <span class="hljs-number">825</span>.<span class="hljs-number">65</span><br><span class="hljs-attribute">04</span>-<span class="hljs-number">22</span>-<span class="hljs-number">2020</span>, WITHDRAWAL, Debit,           Groceries,  <span class="hljs-number">255</span>.<span class="hljs-number">73</span><br><span class="hljs-attribute">05</span>-<span class="hljs-number">01</span>-<span class="hljs-number">2020</span>, WITHDRAWAL, #<span class="hljs-number">1102</span>,           Rent, apt, <span class="hljs-number">2100</span>.<span class="hljs-number">00</span><br><span class="hljs-attribute">05</span>-<span class="hljs-number">02</span>-<span class="hljs-number">2020</span>, INTEREST,                                  <span class="hljs-number">0</span>.<span class="hljs-number">65</span><br><span class="hljs-attribute">05</span>-<span class="hljs-number">07</span>-<span class="hljs-number">2020</span>, WITHDRAWAL, Debit,           Movies,      <span class="hljs-number">12</span>.<span class="hljs-number">57</span><br><span class="hljs-attribute">04</span>-<span class="hljs-number">15</span>-<span class="hljs-number">2020</span>, FEE,                                       <span class="hljs-number">5</span>.<span class="hljs-number">55</span><br></code></pre></td></tr></table></figure><p>它是 CSV 格式，但某些行的列数比其他行要多。 对处理来说更糟糕的是，WITHDRAWAL 类型中的一列具有用户生成的文本，并且可以在文本中包含逗号。 一个包含弃元模式、常量模式和 var 模式的列表模式用于捕获这种格式的值处理数据：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">decimal</span> balance = <span class="hljs-number">0</span>m;<br><span class="hljs-keyword">foreach</span> (<span class="hljs-function"><span class="hljs-built_in">string</span>[] transaction <span class="hljs-keyword">in</span> <span class="hljs-title">ReadRecords</span>())</span><br>&#123;<br>    balance += transaction <span class="hljs-keyword">switch</span><br>    &#123;<br>        [<span class="hljs-meta">_, <span class="hljs-string">&quot;DEPOSIT&quot;</span>, _, var amount</span>]     =&gt; <span class="hljs-built_in">decimal</span>.Parse(amount),<br>        [<span class="hljs-meta">_, <span class="hljs-string">&quot;WITHDRAWAL&quot;</span>, .., var amount</span>] =&gt; -<span class="hljs-built_in">decimal</span>.Parse(amount),<br>        [<span class="hljs-meta">_, <span class="hljs-string">&quot;INTEREST&quot;</span>, var amount</span>]       =&gt; <span class="hljs-built_in">decimal</span>.Parse(amount),<br>        [<span class="hljs-meta">_, <span class="hljs-string">&quot;FEE&quot;</span>, var fee</span>]               =&gt; -<span class="hljs-built_in">decimal</span>.Parse(fee),<br>        _                                 =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(<span class="hljs-string">$&quot;Record <span class="hljs-subst">&#123;<span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot;, &quot;</span>, transaction)&#125;</span> is not in the expected format!&quot;</span>),<br>    &#125;;<br>    Console.WriteLine(<span class="hljs-string">$&quot;Record: <span class="hljs-subst">&#123;<span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot;, &quot;</span>, transaction)&#125;</span>, New balance: <span class="hljs-subst">&#123;balance:C&#125;</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>前面的示例采用了字符串数组，其中每个元素都是行中的一个字段。 第二个字段的 switch 表达式键，用于确定交易的类型和剩余列数。 每一行都确保数据的格式正确。 弃元模式 (_) 跳过第一个字段，以及交易的日期。 第二个字段与交易的类型匹配。 其余元素匹配跳过包含金额的字段。 最终匹配使用 var 模式来捕获金额的字符串表示形式。 表达式计算要从余额中加上或减去的金额。</p><h1>析构元组</h1><h2 id="元组">元组</h2><p>元组提供一种从方法调用中检索多个值的轻量级方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> (<span class="hljs-params"><span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">double</span></span>) <span class="hljs-title">QueryCityData</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (name == <span class="hljs-string">&quot;New York City&quot;</span>)<br>            <span class="hljs-keyword">return</span> (name, <span class="hljs-number">8175133</span>, <span class="hljs-number">468.48</span>);<br><br>        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> result = QueryCityData(<span class="hljs-string">&quot;New York City&quot;</span>);<br><br>        <span class="hljs-comment">//一旦检索到元组，就必须处理它的各个元素。 按元素逐个操作比较麻烦</span><br>        <span class="hljs-keyword">var</span> city1 = result.Item1;<br>        <span class="hljs-keyword">var</span> pop1 = result.Item2;<br>        <span class="hljs-keyword">var</span> size1 = result.Item3;<br><br>        <span class="hljs-comment">//可以在括号内显式声明每个字段的类型。</span><br>        (<span class="hljs-built_in">string</span> city2, <span class="hljs-built_in">int</span> population2, <span class="hljs-built_in">double</span> area2) = QueryCityData(<span class="hljs-string">&quot;New York City&quot;</span>);<br>         <br>        <span class="hljs-comment">//可使用 var 关键字，以便 C# 推断每个变量的类型。 将 var 关键字放在括号外。</span><br>        <span class="hljs-keyword">var</span> (city3, population3, area3) = QueryCityData(<span class="hljs-string">&quot;New York City&quot;</span>);<br><br>        <span class="hljs-comment">//还可在括号内将 var 关键字单独与任一或全部变量声明结合使用。</span><br>        (<span class="hljs-built_in">string</span> city4, <span class="hljs-keyword">var</span> population4, <span class="hljs-keyword">var</span> area4) = QueryCityData(<span class="hljs-string">&quot;New York City&quot;</span>);<br><br>        <span class="hljs-comment">//可将元组析构到已声明的变量中。</span><br>        <span class="hljs-built_in">string</span> city5 = <span class="hljs-string">&quot;Raleigh&quot;</span>;<br>        <span class="hljs-built_in">int</span> population5 = <span class="hljs-number">458880</span>;<br>        <span class="hljs-built_in">double</span> area5 = <span class="hljs-number">144.8</span>;<br><br>        (city5, population5, area5) = QueryCityData(<span class="hljs-string">&quot;New York City&quot;</span>);<br><br>        <span class="hljs-comment">//从 C# 10 开始，可在析构中混合使用变量声明和赋值。</span><br>        <span class="hljs-built_in">string</span> city = <span class="hljs-string">&quot;Raleigh&quot;</span>;<br>        <span class="hljs-built_in">int</span> population = <span class="hljs-number">458880</span>;<br><br>        (city, population, <span class="hljs-built_in">double</span> area) = QueryCityData(<span class="hljs-string">&quot;New York City&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用弃元的元组元素">使用弃元的元组元素</h2><p>析构元组时，通常只需要关注某些元素的值。 可以利用 C# 对弃元的支持，弃元是一种仅能写入的变量，且其值将被忽略。 在赋值中，通过下划线字符 (_) 指定弃元。 可弃元任意数量的值，且均由单个弃元 _ 表示。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> (_, _, area3) = QueryCityData(<span class="hljs-string">&quot;New York City&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="用户定义类型">用户定义类型</h2><p>用户作为类、结构或接口的创建者，可通过实现一个或多个 Deconstruct 方法来析构该类型的实例。 该方法返回 void，且要析构的每个值由方法签名中的 out 参数指示。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> MiddleName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> City &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> State &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> fname, <span class="hljs-built_in">string</span> mname, <span class="hljs-built_in">string</span> lname,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-built_in">string</span> cityName, <span class="hljs-built_in">string</span> stateName</span>)</span><br>    &#123;<br>        FirstName = fname;<br>        MiddleName = mname;<br>        LastName = lname;<br>        City = cityName;<br>        State = stateName;<br>    &#125;<br><br>    <span class="hljs-comment">// Return the first and last name.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deconstruct</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> fname, <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> lname</span>)</span><br>    &#123;<br>        fname = FirstName;<br>        lname = LastName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deconstruct</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> fname, <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> mname, <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> lname</span>)</span><br>    &#123;<br>        fname = FirstName;<br>        mname = MiddleName;<br>        lname = LastName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deconstruct</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> fname, <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> lname,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> city, <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> state</span>)</span><br>    &#123;<br>        fname = FirstName;<br>        lname = LastName;<br>        city = City;<br>        state = State;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExampleClassDeconstruction</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Quincy&quot;</span>, <span class="hljs-string">&quot;Adams&quot;</span>, <span class="hljs-string">&quot;Boston&quot;</span>, <span class="hljs-string">&quot;MA&quot;</span>);<br><br>        <span class="hljs-comment">// Deconstruct the person object.</span><br>        <span class="hljs-keyword">var</span> (fName, lName, city, state) = p;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Hello <span class="hljs-subst">&#123;fName&#125;</span> <span class="hljs-subst">&#123;lName&#125;</span> of <span class="hljs-subst">&#123;city&#125;</span>, <span class="hljs-subst">&#123;state&#125;</span>!&quot;</span>);<br><br><br>        <span class="hljs-keyword">var</span> (fName2, _, city2, _) = p;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Hello <span class="hljs-subst">&#123;fName2&#125;</span> of <span class="hljs-subst">&#123;city2&#125;</span>!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>弃元</h1><p>可使用独立弃元来指示要忽略的任何变量。 一种典型的用法是使用赋值来确保一个参数不为 null。 下面的代码使用弃元来强制赋值。 赋值的右侧使用 Null 合并操作符，用于在参数为 null 时引发 System.ArgumentNullException。 此代码不需要赋值结果，因此将对其使用弃元。 该表达式强制执行 null 检查。 弃元说明你的意图：不需要或不使用赋值结果。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> arg</span>)</span><br>&#123;<br>    _ = arg ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(paramName: <span class="hljs-keyword">nameof</span>(arg), message: <span class="hljs-string">&quot;arg can&#x27;t be null&quot;</span>);<br><br>    <span class="hljs-comment">// Do work with arg.</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><code>?? 操作符和 ??= 操作符</code></p><p>如果左操作数的值不为 null，则 null 合并运算符 ?? 返回该值；否则，它会计算右操作数并返回其结果。 如果左操作数的计算结果为非 null，则 ?? 运算符不会计算其右操作数。 仅当左操作数的计算结果为 null 时，Null 合并赋值运算符 ??= 才会将其右操作数的值赋值给其左操作数。 如果左操作数的计算结果为非 null，则 ??= 运算符不会计算其右操作数。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Languages</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 类和接口</title>
    <link href="/posts/CSharp%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <url>/posts/CSharp%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1>类(Class)</h1><h2 id="什么是类">什么是类</h2><ul><li><p>一种数据结构</p></li><li><p>一种数据类型</p></li><li><p>代表现实世界中的种类</p></li></ul><h2 id="构造函数和析构函数">构造函数和析构函数</h2><h3 id="构造函数">构造函数</h3><p>public ClassName(){}<br>在被new实例化时自动调用此构造器</p><p>private ClassName(){}<br>用于防止类被new ClassName()实例化</p><p>static ClassName(){}<br>只用于构造静态成员，不能用于构造实例成员</p><h3 id="析构函数">析构函数</h3><p>~ClassName(){}<br>在被GC回收托管资源时调用此析构器</p><h2 id="抽象类">抽象类</h2><ul><li><p>不能被实例化，但是有构造函数</p></li><li><p>抽象成员必须包含在抽象类中</p></li><li><p>抽象类除了抽象成员外，还可以包含别的成员(不用关键字 abstract)</p></li><li><p>子类继承抽象父类后，必须把父类中所有抽象成员都重写(非抽象成员不必重写)。除非子类也是个抽象类</p></li><li><p>抽象成员的访问修饰符不能是private</p></li><li><p>abstract关键字不能用于字段成员，但是可以用于属性</p></li><li><p>abstract关键字用于方法时，方法不能定义主体</p></li><li><p>抽象类也可实现接口，但要将接口的成员用abstract修饰</p></li></ul><h2 id="修饰符">修饰符</h2><h3 id="访问限制">访问限制</h3><ul><li><p>private：访问级别为类的成员，不能直接修饰类，仅当该类是其他类的成员的时候可以修饰。</p></li><li><p>public：访问没有限制，所有的本程序集以及其他的程序集都能够访问。</p></li><li><p>internal：本程序集内的成员可以访问，是默认的访问级别。</p></li></ul><h3 id="继承相关">继承相关</h3><ul><li><p>sealed：封闭类，修饰类时表示该类不能够被继承。</p></li><li><p>protected：类的访问级别被限制在类成员之间，例如当父类成员被protect修饰，子类成员可以访问，其他类不能访问。可以跨程序集。</p></li><li><p>abstract：修饰类的时候表示该类为抽象类，不能创建该类的实例。修饰方法的时候表示该方法需要由子类来实现，如果子类没有实现该方法那么子类同样是抽象类；且含有抽象方法的类一定是抽象类。</p></li><li><p>new：只能用于嵌套的类，表示对继承父类同名类型的隐藏。</p></li></ul><h3 id="其他">其他</h3><ul><li><p>static：修饰类时表示该类为静态类，不能实例化该类的对象，这个类也不能含有对象成员，即该类的所有成员为静态。</p></li><li><p>partial：部分类，可以将一个类分成几部分写在不同的文件中，最终编译时将合并成一个文件，且各个部分不能分散在不同程序集中。</p></li></ul><h2 id="其他补充">其他补充</h2><ul><li>父类构造器不能直接被子类全盘继承，调用时先调用父类的构造器再调用子类的构造器</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vehicle</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> owner</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.Owner = owner;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Owner &#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> : <span class="hljs-title">Vehicle</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> owner</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">owner</span>)</span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowOwner</span>()</span>&#123;<br>        Console.WriteLine(Owner);<br>    &#125;<br>&#125;<br>\\<span class="hljs-keyword">new</span> 一个新 Car 对象时先执行 Vehicle 的构造函数，再执行 Car 的构造函数<br></code></pre></td></tr></table></figure><ul><li><p>子类的访问级别不能超越父类的访问级别</p></li><li><p>父类中的虚函数(virtual)可以有方法体，被子类继承后可以重写(override)。而抽象(abstract)方法无函数体，含有抽象方法的类一定是抽象类，继承抽象类的子类必须把抽象父类中的所有抽象方法都重写，除非子类也是个抽象类。</p></li><li><p>不通过构造器创建实例的方法：</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Type t = <span class="hljs-keyword">typeof</span>(ClassName);<br><span class="hljs-built_in">object</span> o = Activator.CreateInstance(t);<br>ClassName className = o <span class="hljs-keyword">as</span> ClassName;<br></code></pre></td></tr></table></figure><h1>接口(Interface)</h1><ul><li><p>接口中只能包含方法(方法、属性、索引器、事件)，且接口中的方法不能有任何实现。</p></li><li><p>接口中的成员不能有任何访问修饰符，默认为public的</p></li><li><p>接口不能被实例化</p></li><li><p>实现接口的类，必须实现接口的所有成员，而且没有 override 关键字。</p></li><li><p>一个接口可以继承多个接口</p></li><li><p>一个类可以实现多个接口，但是只能继承一个类</p></li><li><p>如果一个类同时继承了父类并实现接口的时候，要把父类写在最前面</p></li><li><p>当父类实现了接口，子类继承父类后，则可以使用接口引用子类</p></li><li><p>接口方法的显示实现：如果多个接口里有相同的方法名，那么第一个方法名默认的引用的是排在最前面的接口，如果要使用后面接口的方法，就要显示实现：接口名.方法名。访问修饰符是private</p></li></ul><h1>其他</h1><ul><li><p>结构体可以实现接口，但是不能继承其他类或者其他结构体；结构体不能有显式的无参构造器，但是可以有显式的有参构造器。</p></li><li><p>枚举成员默认类型是 int 类型，通过继承可以声明枚举成员为其他类型，枚举类型一定是继承自 byte、sbyte、short、ushort、int、uint、long 和 ulong 中的一种，不能是其它类型。比如：</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Days : <span class="hljs-built_in">byte</span><br>&#123;<br>    Monday = <span class="hljs-number">1</span>,<br>    Tuesday = <span class="hljs-number">2</span>,<br>    Wednesday = <span class="hljs-number">3</span>,<br>    Thursday = <span class="hljs-number">4</span>,<br>    Friday = <span class="hljs-number">5</span>,<br>    Saturday = <span class="hljs-number">6</span>,<br>    Sunday = <span class="hljs-number">7</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>枚举成员如果没有手动指定成员的值的话，就是一个从 0 开始，步长为 1 的等差数列，即 1，2，3，4，5…</p></li><li><p>枚举成员如果被手动赋值的话，那么被赋值的成员的值即为所指定的值，但是其递增步长不会变，总是为 1：</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> DriveType : <span class="hljs-built_in">sbyte</span> <br>&#123;     <br>    CDRom,                                  <span class="hljs-comment">//值为0</span><br>    Fixed = <span class="hljs-number">-2</span>,                             <span class="hljs-comment">//值为-2</span><br>    Network,                                <span class="hljs-comment">//值为-1</span><br>    NoRootDirectory = <span class="hljs-number">-1</span>,                   <span class="hljs-comment">//值为-1</span><br>    Ram,                                    <span class="hljs-comment">//值为0</span><br>    Removable = Network * NoRootDirectory,  <span class="hljs-comment">//值为1</span><br>    Unknown                                 <span class="hljs-comment">//值为2</span><br>&#125;  <br></code></pre></td></tr></table></figure><ul><li>Flags关键字允许我们在使用枚举变量时,可以使用多个组合值。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Flags</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Options : <span class="hljs-built_in">byte</span><br>&#123;<br>    None    = <span class="hljs-number">0</span>,<br>    One     = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>,   <span class="hljs-comment">// 1 0b1</span><br>    Two     = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>,   <span class="hljs-comment">// 2 0b10</span><br>    Three   = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>,   <span class="hljs-comment">// 4 0b100</span><br>    Four    = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>,   <span class="hljs-comment">// 8 0b1000</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>&#123;<br>    Options option = Options.None | Options.One | Options.Two | Options.Three | Options.Four;<br>    Console.WriteLine(option.ToString());<br>    <span class="hljs-comment">//输出：One, Two, Three, Four  如果不加 Flags 的特性，输出：15</span><br>    Console.WriteLine((<span class="hljs-built_in">int</span>)option);<br>    <span class="hljs-comment">//输出：15</span><br>    Console.WriteLine(option.HasFlag(Options.None));<br>    <span class="hljs-comment">//输出：True</span><br>    Console.WriteLine(option.HasFlag(Options.One));<br>    <span class="hljs-comment">//输出：True</span><br><br>    option = Options.One | Options.Two;<br>    Console.WriteLine(option.ToString());<br>    <span class="hljs-comment">//输出：One, Two  如果不加 Flags 的特性，输出：3</span><br>    Console.WriteLine((<span class="hljs-built_in">int</span>)option)<br>    <span class="hljs-comment">//输出：3</span><br>    Console.WriteLine(option.HasFlag(Options.None));<br>    <span class="hljs-comment">//输出：True</span><br>    Console.WriteLine(option.HasFlag(Options.One));<br>    <span class="hljs-comment">//输出：True</span><br>     Console.WriteLine(option.HasFlag(Options.Three));<br>    <span class="hljs-comment">//输出：False</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以有 [Flags] 特性时尽量不要将成员的值设为 0。</p>]]></content>
    
    
    <categories>
      
      <category>Languages</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSharp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LearnVim</title>
    <link href="/posts/LearnVim/"/>
    <url>/posts/LearnVim/</url>
    
    <content type="html"><![CDATA[<h4 id="onoremap-Is-c-u-normal-F-vi-cr">onoremap Is :&lt;c-u&gt;normal! F]vi]&lt;cr&gt;</h4><p>用 onoremap 映射一个 motion，上面代码的意思为将 Is 按键映射为找到本行光标前的 ‘]’ 符号，并选择在 ‘[]’ 内的内容。按 dIs 就可以删除本行内光标位置之前的 ‘[]’ 中的内容。</p><h4 id="c-r-c-w">:&lt;c-r&gt;&lt;c-w&gt;</h4><p>在命令模式下使用 ctrl + r 加 ctrl + w，代表把当前光标下的字符串写入命令行。</p><h4 id="10i">10i#</h4><p>插入 10 个 ‘#’</p><h4 id="normal-和-normal">normal 和 normal!</h4><p>例如给 F 添加一个映射：nnoremap F x</p><p>这时 F 就有了两个含义：</p><ul><li>vim 的出厂设置定义：反向查找</li><li>用户的自定义：x 代表删除</li></ul><p>normal F 代表用户的自定义用法，即 x 删除。normal! F 代表 vim 的出厂设置定义，即反向查找。</p><h4 id="s-和-r">s 和 r</h4><p>s 是替换当前光标下的字母并进入插入模式，r 是替换当前光标下的字母并保持在当前模式。</p><h4 id="vnoremap-normal-cr">vnoremap . :normal! .&lt;cr&gt;</h4><p>可视模式下的映射，将 “.” 映射为普通模式下的 “.” 操作，普通模式下的 “.” 操作为重复执行上一步的操作。例如：</p><p>asfdasdf aslfk sdf<br>asdfklsdf fklasdjf<br>sladfjaslas sdffasd<br>asdkfjksdjfksjdf sdfj</p><p>在第一行按 “A;”，给第一行添加了分号，然后在可视模式下选中剩下的三行，按下 “.”，就可以给剩下三行也在最后添加分号。</p><h4 id="改变数字">改变数字</h4><p>当光标在数字之前，可以按 ctrl + a 来增加数字的大小，按 ctrl + x 来减小数字的大小，然而光标在数字之后不可以如此操作。因此我们可以先按 0 来将光标置于行首来改变数字大小。</p><p>如果将一列数字改变，如下：</p><p>array[0] = 0;<br>array[0] = 0;<br>array[0] = 0;<br>array[0] = 0;<br>array[0] = 0;<br>array[0] = 0;<br>array[0] = 0;</p><p>可以使用可视块模式，即 ctrl + v 选中方括号中的 0 这一列，然后按 ctrl + a 来增加选中的全部数字的大小，按 ctrl + x 来减小选中的全部数字的大小。</p><p>如果想让数字递增，第一行的数字为 1，第二行的数字为 2 等，可以按 g ctrl + a 来实现，如果想让数字递减，可以按 g ctrl + x 来实现。</p><h4 id="生成数字">生成数字</h4><p>:put =range(1, 10) 可以从当前光标所在行的下一行开始，每一行插入一个数字，第一行为 1，第二行为 2，等等。</p><p>:0put =range(1, 10) 可以从首行开始，每一行插入一个数字，第一行为 1，第二行为 2，等等。</p><p>:for i in range(1, 10) | put =‘196.168.0.’ . i | endfor 可以生成十行字符串:<br>196.168.0.1<br>196.168.0.2<br>196.168.0.3<br>196.168.0.4<br>196.168.0.5<br>196.168.0.6<br>196.168.0.7<br>196.168.0.8<br>196.168.0.9<br>196.168.0.10</p><h4 id="录制宏及替代">录制宏及替代</h4><p><strong>普通宏：</strong></p><table><thead><tr><th>q</th><th>a</th><th>&lt;operation&gt;</th><th>q</th></tr></thead><tbody><tr><td>记录宏命令</td><td>记录宏到 a 寄存器</td><td>宏操作</td><td>记录结束退出</td></tr></tbody></table><p>qa&lt;operation&gt;q</p><p>使用宏：@a 或者 &lt;number&gt;@a 来重复执行 number 次。</p><p><strong>录制套娃宏：</strong></p><table><thead><tr><th>q</th><th>a</th><th>&lt;operation&gt;</th><th>@a</th><th>q</th></tr></thead><tbody><tr><td>记录宏命令</td><td>记录宏到 a 寄存器</td><td>宏操作</td><td>套娃</td><td>记录结束退出</td></tr></tbody></table><p>qa&lt;operation&gt;@aq</p><p>使用宏：@a</p><p><strong>替代方案：</strong></p><p>nnoremap &lt;leader&gt;nl :%s/^/\=printf(‘%-4d’, line(‘.’))&lt;cr&gt; 给所有行添加行标。</p><p>vnoremap &lt;leader&gt;vn : s/^/\=printf(“%d. “, line(”.”) - line(“'&lt;”) + 1)&lt;cr&gt; 可视模式下给选中的行加行标。</p><h4 id="set-path">set path+=**</h4><p>递归搜索目录，即搜索所有的目录，包括它们的子目录，子目录的子目录，一直循环下去，意味着目录下所有的文件和文件夹都要搜索。以 find 命令为例，添加这个设置后，可以找到子目录下的文件。</p><h4 id="set-textwidth-70-和-set-fo-Mm">set textwidth=70 和 set fo+=Mm</h4><p>set textwidth=70 可以让一行显示70个字母，多的会自动换行，set fo+=Mm 可以让 textwidth 设置同样应用到中文，一行只显示 70 个汉字。</p><h4 id="搜索-和">搜索 / 和 ?</h4><p>用 / 是从上往下搜索，按 n 是从上往下搜索下一个，按 N 是从下往上搜索上一个。用 ? 搜索，方向与 / 相反。</p><h4 id="搜索-和-2">搜索 * 和 #</h4><p>从上到下：</p><ul><li>精确搜索：*</li><li>模糊搜索：g*</li></ul><p>从下到上：</p><ul><li>精确搜索：#</li><li>模糊搜索：g#</li></ul><h4 id="正则表达式">正则表达式</h4><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>[ab1]</td><td>a 或者 b 或者 1</td></tr><tr><td>[0-9]</td><td>0 到 9 里的任意数字</td></tr><tr><td>[a-z]</td><td>a 到 z 里的任意字母</td></tr><tr><td>[A-Z]</td><td>A 到 Z 里的任意字母</td></tr><tr><td>[^0-9]</td><td>非 0-9 数字的任意字符</td></tr></tbody></table><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>任意一个字符</td></tr><tr><td>?</td><td>没有或者一个</td></tr><tr><td>*</td><td>没有或者多个</td></tr><tr><td>+</td><td>一个或者多个</td></tr><tr><td>[^a]</td><td>不是 a 的字符</td></tr><tr><td>^</td><td>行首</td></tr><tr><td>$</td><td>行末</td></tr><tr><td>\d</td><td>[0-9]</td></tr><tr><td>\D</td><td>[^0-9]</td></tr><tr><td>\w</td><td>[a-zA-Z0-9_]</td></tr><tr><td>\W</td><td>[^a-zA-Z0-9_]</td></tr><tr><td>\s</td><td>空格</td></tr><tr><td>\S</td><td>非空格</td></tr><tr><td>{min,max}</td><td>重复</td></tr><tr><td>()</td><td>组</td></tr><tr><td>(A|B)</td><td>组 A 或者组 B</td></tr></tbody></table><h4 id="计算混合运算">计算混合运算</h4><p>inoremap &lt;leader&gt;js &lt;C-O&gt;yiW&lt;End&gt;=&lt;C-R&gt;=&lt;C-R&gt;0&lt;CR&gt;<br>在插入模式下按 &lt;leader&gt;js 就可以计算式子，其中&lt;C-O&gt;为一次性使用命令，使用后仍回到插入模式，&lt;C-R&gt;为调用寄存器</p><h4 id="窗口管理">窗口管理</h4><p>命令行下</p><p>vim -o &lt;filename1&gt;&lt;filename2&gt; 依次水平打开窗口<br>vim -O &lt;filename1&gt;&lt;filename2&gt; 依次垂直打开窗口</p><p>&lt;c-w&gt;| 最大化宽度<br>&lt;c-w&gt;_ 最大化高度</p><p>:on 或者 :only 关闭除当前光标所在窗口外的所有窗口</p><p>:mksession&lt;filename&gt; 将当前窗口的 layout 记录到文件里，想要回到这样的 layout 就使用 :so&lt;filename&gt; 命令</p><h4 id="替换搜索到的字符">替换搜索到的字符</h4><p>nnoremap &lt;leader&gt;s :%s/\&lt;&lt;C-R&gt;&lt;C-W&gt;&gt;//g&lt;left&gt;&lt;left&gt;</p><h4 id="cnoreabbrev-Q-q">cnoreabbrev Q! q!</h4><p>在命令模式下，将 Q! 映射为 q!</p><ul><li>c：命令行指令，也就是说该命令只在命令行里起作用</li><li>nore：不循环映射</li><li>abbrev：映射命令</li></ul><h4 id="在命令行快速移动及修改">在命令行快速移动及修改</h4><p><strong>移动</strong></p><table><thead><tr><th>快捷键</th><th>含义</th></tr></thead><tbody><tr><td>&lt;-</td><td>向左移动一个位置</td></tr><tr><td>-&gt;</td><td>向右移动一个位置</td></tr><tr><td>&lt;S-Left&gt; or &lt;C-Left&gt;</td><td>向左移动一个 word 位置</td></tr><tr><td>&lt;S-Right&gt; or &lt;C-Right&gt;</td><td>向右移动一个 word 位置</td></tr><tr><td>CTRL-B or &lt;Home&gt;</td><td>到行首位置</td></tr><tr><td>CTRL-E or &lt;End&gt;</td><td>到行尾位置</td></tr></tbody></table><p><strong>删除</strong></p><table><thead><tr><th>快捷键</th><th>含义</th></tr></thead><tbody><tr><td>CTRL-w</td><td>删除一个 word</td></tr><tr><td>CTRL-u</td><td>从光标位置删除到行首</td></tr></tbody></table><p><strong>覆盖</strong></p><p>&lt;Insert&gt;: 进入覆盖模式，输入的字符覆盖以前的字符，再次按 &lt;Insert&gt; 退出覆盖模式。</p><p><strong>取消输入，回到 Normal 模式</strong></p><ul><li>CTRL-c</li><li>&lt;Esc&gt;</li></ul><h4 id="命令行窗口">命令行窗口</h4><p>在命令行窗口可以使用 normal 模式下的移动，可以使用各种 vimrc 里的映射。</p><p>可以通过两种方式打开这个窗口：</p><ul><li>如果已经在命令行：‘ctrl-f’</li><li>如果在 normal 模式：‘q:’</li></ul><p>退出 command-line window：</p><ul><li>执行命令退出回到编辑窗口：&lt;CR&gt;</li><li>通常使用的方式：‘:q’，‘:qa’，‘:qa!’</li><li>ctrl-c：进入命令行，‘q’，‘qa’，‘qa!’</li></ul><p>甚至搜索模式下，也可以使用以下方式来打开 command-line 窗口来进行编辑：</p><ul><li>从上到下的搜索：‘q/’</li><li>从下到上的搜索：‘q?’</li></ul><p>如果在命令行的命令比较长，或者避免使用箭头按键来移动，就可以使用命令行窗口。</p><h4 id="IdeaVimrc">IdeaVimrc</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-string">&quot; ================================================================================================</span><br><span class="hljs-string">&quot;</span> <span class="hljs-title class_">Extensions</span> <br><span class="hljs-string">&quot; ================================================================================================</span><br><span class="hljs-string">&quot;</span>下列插件需要在<span class="hljs-title class_">IDEA</span>中下载<br><span class="hljs-string">&quot;ideaVim</span><br><span class="hljs-string">&quot;</span><span class="hljs-title class_">IdeaVim</span>-<span class="hljs-title class_">EasyMotion</span><br><span class="hljs-string">&quot;IdeaVimExtension</span><br><span class="hljs-string">&quot;</span><span class="hljs-title class_">CodeGlance</span> <span class="hljs-title class_">Pro</span><br><br><span class="hljs-string">&quot; ================================================================================================</span><br><span class="hljs-string">&quot;</span> <span class="hljs-title class_">Basic</span> settings<br><span class="hljs-string">&quot; ================================================================================================</span><br><span class="hljs-string">&quot;</span>设置在光标距离窗口顶部或底部一定行数时，开始滚动屏幕内容的行为<br>set scrolloff=<span class="hljs-number">5</span><br><br>set easymotion<br><br>set cursorline<br><br>set showmatch<br><br>set nobackup<br><br>set surround<br><br>set ruler<br><br>set clipboard^=unnamed,unnamedplus<br><br><span class="hljs-string">&quot;--递增搜索功能：在执行搜索（使用 / 或 ? 命令）时，</span><br><span class="hljs-string">&quot;</span><span class="hljs-title class_">Vim</span> 会在您输入搜索模式的过程中逐步匹配并高亮显示匹配的文本。<br>set incsearch<br><br><span class="hljs-string">&quot;--在搜索时忽略大小写</span><br><span class="hljs-string">set ignorecase</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;</span>--将搜索匹配的文本高亮显示<br>set hlsearch<br><br><span class="hljs-string">&quot;--设置相对行号 和 当前行的绝对行号</span><br><span class="hljs-string">set number relativenumber</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;</span>--设置返回normal模式时回到英文输入法<br>set keep-english-<span class="hljs-keyword">in</span>-normal<br><br><span class="hljs-string">&quot; ================================================================================================</span><br><span class="hljs-string">&quot;</span> <span class="hljs-title class_">No</span> <span class="hljs-title class_">Leader</span> <span class="hljs-title class_">Keymaps</span><br><span class="hljs-string">&quot; ================================================================================================</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;</span> go to somewhere (g <span class="hljs-keyword">in</span> normal mode <span class="hljs-keyword">for</span> goto somewhere)<br>nnoremap ga <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">GotoAction</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gb <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">JumpToLastChange</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gc <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">GotoClass</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gd <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">GotoDeclaration</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gs <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">GotoSuperMethod</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gi <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">GotoImplementation</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gf <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">GotoFile</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gm <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">GotoSymbol</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gu <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">ShowUsages</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gt <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">GotoTest</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gr <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">RecentFiles</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gh <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">Back</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gl <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">Forward</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br><br>nnoremap ta <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">Annotate</span>&lt;cr&gt;<br>nnoremap tb <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">ToggleLineBreakpoint</span>&lt;cr&gt;<br>nnoremap tm <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">ToggleBookmark</span>&lt;cr&gt;<br>nnoremap tp <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">ActivateProjectToolWindow</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br><br>nnoremap &lt;C-f&gt; <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">ReformatCode</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap J <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">MethodDown</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap K <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">MethodUp</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap &lt;S-<span class="hljs-title class_">Down</span>&gt; <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">EditorCloneCaretBelow</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap &lt;S-<span class="hljs-title class_">Up</span>&gt; <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">EditorCloneCaretAbove</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br><br><span class="hljs-string">&quot; ================================================================================================</span><br><span class="hljs-string">&quot;</span>️️ <span class="hljs-title class_">Leader</span> <span class="hljs-title class_">Keymaps</span><br><span class="hljs-string">&quot; ================================================================================================</span><br><span class="hljs-string">let mapleader = &quot;</span> <span class="hljs-string">&quot;</span><br><span class="hljs-string">nnoremap &lt;Leader&gt;o :&lt;C-u&gt;action RecentProjectListGroup&lt;CR&gt;</span><br><span class="hljs-string">nnoremap &lt;Leader&gt;r :&lt;C-u&gt;action Replace&lt;CR&gt;</span><br><span class="hljs-string">vnoremap &lt;Leader&gt;r :&lt;C-u&gt;action Replace&lt;CR&gt;</span><br><span class="hljs-string">nnoremap &lt;Leader&gt;R :&lt;C-u&gt;action ReplaceInPath&lt;CR&gt;</span><br><span class="hljs-string">vnoremap &lt;Leader&gt;R :&lt;C-u&gt;action ReplaceInPath&lt;CR&gt;</span><br><span class="hljs-string">nnoremap &lt;Leader&gt;f :&lt;C-u&gt;action Find&lt;CR&gt;</span><br><span class="hljs-string">vnoremap &lt;Leader&gt;f :&lt;C-u&gt;action Find&lt;CR&gt;</span><br><span class="hljs-string">nnoremap &lt;Leader&gt;F :&lt;C-u&gt;action FindInPath&lt;CR&gt;</span><br><span class="hljs-string">vnoremap &lt;Leader&gt;F :&lt;C-u&gt;action FindInPath&lt;CR&gt;</span><br><span class="hljs-string">nnoremap &lt;Leader&gt;h gT</span><br><span class="hljs-string">nnoremap &lt;Leader&gt;l gt</span><br><span class="hljs-string">nnoremap &lt;leader&gt;ns :action NextSplitter&lt;CR&gt;</span><br><span class="hljs-string">nnoremap &lt;leader&gt;ps :action PrevSplitter&lt;CR&gt;</span><br><span class="hljs-string">nnoremap &lt;leader&gt;sh :action SplitHorizontally&lt;CR&gt;</span><br><span class="hljs-string">nnoremap &lt;leader&gt;sv :action SplitVertically&lt;CR&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Editor</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>画线和画三角形方法</title>
    <link href="/posts/%E7%94%BB%E7%BA%BF%E5%92%8C%E7%94%BB%E9%9D%A2%E7%AE%97%E6%B3%95/"/>
    <url>/posts/%E7%94%BB%E7%BA%BF%E5%92%8C%E7%94%BB%E9%9D%A2%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="画线算法">画线算法</h2><h3 id="DDA画线">DDA画线</h3><p>直线方程表示为 $y = kx + b$</p><p>当 $\lVert k \rVert &lt;= 1$时，$x$ 每递增$1$，$y$ 递增$k$。</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_1.png" alt=""></p><p>当 $\lVert k \rVert \geq 1$时，$x$ 每递增$1/k$，$y$ 递增$1$。</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_2.png" alt=""></p><p>因为光栅化不能绘制半个像素点，所以求出的值需要进行四舍五入即加 0.5 后再进行取整。</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_3.png" alt=""></p><p>DDA 算法是一个增量算法，它直观且容易实现，然而 $x$ 和 $y$ 都必须用浮点值表示，而且每一步都需要对 $y$ 进行舍入取整，不利于硬件实现。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawLine_DDA</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x1,<span class="hljs-built_in">int</span> y1,<span class="hljs-built_in">int</span> x2,<span class="hljs-built_in">int</span> y2</span>)</span>&#123;<br>    <span class="hljs-built_in">int</span> dx = x2 - x1;<br>    <span class="hljs-built_in">int</span> dy = y2 - y1;<br><br>    <span class="hljs-built_in">int</span> step = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(Math.Abs(dy) &gt; Math.Abs(dx))&#123;<br>        step = Math.Abs(dy);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        step = Math.Abs(dx);<br>    &#125;<br><br>    <span class="hljs-built_in">float</span> stepX = <span class="hljs-number">1.0f</span> * dx / step;<br>    <span class="hljs-built_in">float</span> stepY = <span class="hljs-number">1.0f</span> * dy / step;<br><br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">float</span> x = x1;<br>    <span class="hljs-built_in">float</span> y = y1;<br>    DrawPoint((<span class="hljs-built_in">int</span>)x, (<span class="hljs-built_in">int</span>)y);<br>    <span class="hljs-keyword">while</span> ((i++)&lt;step)&#123;<br>        x += stepX;<br>        y += stepY;<br>        DrawPoint((<span class="hljs-built_in">int</span>)x, (<span class="hljs-built_in">int</span>)(y+<span class="hljs-number">0.5f</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Bresenham画线">Bresenham画线</h3><p>Bresenham 算法只用 int 类型的加减和比较来绘制直线，大大降低了需要的计算资源。</p><p>它的思路是：水平直线、竖直直线单独处理，剩余的部分等分为 8 个区域，然后从最简单的斜率大于 0 小于 1 的部分开始，剩下的 7 个部分稍作修改即可。</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_4.png" alt=""></p><p>当斜率大于 0 小于 1 时，起始点为 ($x_0$, $y_0$)，终点为 ($x_1$, $y_1$)，我们遍历横坐标，找出每个横坐标对应的纵坐标。$x_{0+i}$ 对应的纵坐标应该为 $y_0 + i \times slope$，四舍五入获得的像素坐标为：int($y_0 + i \times slope + 0.5$)</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_5.png" alt=""></p><p>由于斜率大于 0 小于 1，相邻横坐标对应的纵坐标最多加 1。比如 $x_{0+1}$ 处的纵坐标要么还是 $y_0$，要么是 $y_{0+1}$。绝不可能是 $y_{0+2}$</p><p>然而 Bresenham 算法是想避免 float 类型的运算和比较。以 $x_{0+1}$ 为例：</p><p>$1 \times slope &lt; 0.5$ 则四舍，$1 \times slope \geq 0.5$ 则五入。然而实际判断 $1 \times slope &lt; 0.5$ 等价于 $2 \times slope &lt; 1$，等价于 $2 \times \Delta y &lt; \Delta x$，等价于 $2 \times \Delta y - \Delta x &lt; 0$，这时则完全没有 float 类型计算和比较了。($\Delta y = y_1 - y_0, \Delta x = x_1 - x_0$)。</p><p>若 $2 \times \Delta y - \Delta x &lt; 0$，则 $y(x_{0+1}) = y_0$，</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_6.png" alt=""></p><p>否则 $y(x_{0+1}) = y_{0+1}$</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_7.png" alt=""></p><p>接着再考虑 $x_{0+2}$ 处，</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_8.png" alt=""></p><p>若前一个像素自右上方衍生出，需要比较 $2 \times slope &lt; 1.5$，等价于 $4 \times \Delta y - 3 \times \Delta x &lt; 0$，注意 $4 \times \Delta y - 3 \times \Delta x = 2 \times \Delta y - \Delta x + (2 \times \Delta y - 2 \times \Delta x)$</p><p>若前一个像素自右方衍生出，需要比较 $2 \times slope &lt; 0.5$，等价于 $4 \times \Delta y - \Delta x &lt; 0$，注意 $4 \times \Delta y - \Delta x = 2 \times \Delta y - \Delta x + (2 \times \Delta y)$</p><p>同样的思路可以一直推下去直到线段的末尾。</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_9.png" alt=""></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawLine_Bresenham</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x0, <span class="hljs-built_in">int</span> x1, <span class="hljs-built_in">int</span> y0, <span class="hljs-built_in">int</span> y1</span>)</span><br>&#123;<br>    <span class="hljs-built_in">bool</span> steep = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(Math.Abs(x0 - x1) &lt; Math.Abs(y0 - y1))<br>    &#123;<br>        TempSwap(<span class="hljs-keyword">ref</span> x0, <span class="hljs-keyword">ref</span> y0);<br>        TempSwap(<span class="hljs-keyword">ref</span> x1, <span class="hljs-keyword">ref</span> y1);<br>        steep = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(x0 &gt; x1)<br>    &#123;<br>        TempSwap(<span class="hljs-keyword">ref</span> x0, <span class="hljs-keyword">ref</span> x1);<br>        TempSwap(<span class="hljs-keyword">ref</span> y0, <span class="hljs-keyword">ref</span> y1);<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> dx = x1 - x0;<br>    <span class="hljs-built_in">int</span> dy = y1 - y0;<br><br>    <span class="hljs-built_in">int</span> derror = Math.Abs(dy) * <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">int</span> error = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> y = y0;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> x = x0; x &lt;= x1; x++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (steep)<br>        &#123;<br>            DrawPoint(y, x);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            DrawPoint(x, y);<br>        &#125;<br><br>        error += derror;<br>        <br>        <span class="hljs-keyword">if</span> (error &gt; dx)<br>        &#123;<br>            y += (y1 &gt; y0 ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>);<br>            error -= dx * <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中点画线">中点画线</h3><p>如下图</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_10.png" alt=""></p><p>其中，<br>$$<br>\begin{aligned}<br>P &amp;= p_0 + (P_1 - P_0)t\<br>&amp;= P_0 - tP_0 + tP_1\<br>&amp;= (1 - t)P_0 + tP_1<br>\end{aligned}<br>$$</p><p>那么<br>$$<br>f(x) = (1 - t) \times f(x_0) + t \times f(x_1)<br>$$</p><p>直线隐函数方程为：<br>$$<br>F(x, y) = y - kx - b = 0<br>$$</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_11.png" alt=""></p><p>假设已经确定了要显示的点 ($x_i$, $y_i$)，那么需要确定下一个点绘制的位置，这里需要用到中点误差项。</p><p>$$<br>d_i = F(x_i + 1, y_i + 0.5) = y_i + 0.5 - k(x_i + 1) - b<br>$$</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_12.png" alt=""></p><p>$$<br>y_{i+1} = \begin{cases}<br>y_i + 1, (d_i &lt; 0)\<br>y_i,\quad(d_i \geq 0)<br>\end{cases}<br>$$</p><p>当 $d_i &lt; 0$ 时，<br>$$<br>\begin{aligned}<br>d_{i+1} &amp;= F(x_i + 2, y_i + 1.5)\<br>&amp;= y_i + 1.5 - k(x_i + 2) - b\<br>&amp;= y_i + 0.5 - k(x_i + 1) - b + 1 - k\<br>&amp;= d_i + 1 - k<br>\end{aligned}<br>$$</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_13.png" alt=""></p><p>当 $d_i \geq 0$ 时，<br>$$<br>\begin{aligned}<br>d_{i+1} &amp;= F(x_i + 2, y_i + 0.5)\<br>&amp;= y_i + 0.5 - k(x_i + 2) - b\<br>&amp;= y_i + 0.5 - k(x_i + 1) - b - k\<br>&amp;= d_i - k<br>\end{aligned}<br>$$</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_14.png" alt=""></p><p>当 $d_i &lt; 0$ 时，$d_{i+1} = d_i + 1 - k$，当 $d_i \geq 0$ 时，$d_{i+1} = d_i - k$</p><p>中点误差项初始值为：<br>$$<br>\begin{aligned}<br>d_0 &amp;= F(x_0 + 1, y_0 + 0.5)\<br>&amp;= y_0 + 0.5 - k(x_0 + 1) - b\<br>&amp;= y_0 - kx - b - k + 0.5\<br>&amp;= 0.5 - k<br>\end{aligned}<br>$$</p><p>接下来，我们需要进行整数化处理：</p><p>令 $d$ 乘以 $2\Delta x$ 得到 $e$，误差项正负值不变，不会影响 $y$ 的增量<br>$$<br>e = 2d\Delta x<br>$$<br>此时误差项初始值为：<br>$$<br>e_0 = 2d_0\Delta x = 2(0.5 - k)\Delta x = \Delta x - 2\Delta y<br>$$</p><p>此时误差项的递推公式为：<br>$$<br>\begin{aligned}<br>e &lt; 0, e &amp;= 2(d + 1 - k)\Delta x = 2d\Delta x + 2\Delta x - 2k\Delta x = e + 2\Delta x - 2\Delta y\<br>e \geq 0, e &amp;= 2(d - k)\Delta x = 2d\Delta x - 2k\Delta x = e - 2\Delta y<br>\end{aligned}<br>$$</p><p>$$<br>e_{i+1} = \begin{cases}<br>e_i + 2\Delta x - 2\Delta y, (e &lt; 0)\<br>e_i - 2\Delta y,\quad(e \geq 0)<br>\end{cases}<br>$$</p><p>那么此时进行画线操作，从 $P_0$ 开始到 $P_1$ 点沿 $x$ 轴方向，判断 $e$ 的符号来绘制点 ($x$, $y$)，若 $e &lt; 0$，将点更新为 ($x+1$, $y+1$)，$e = e + 2\Delta x - 2\Delta y$；否则将点更新为 ($x+1$, $y$)，$e = e - 2\Delta y$</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawLine_MidPoint</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x0,<span class="hljs-built_in">int</span> y0,<span class="hljs-built_in">int</span> x1,<span class="hljs-built_in">int</span> y1</span>)</span><br>&#123;<br>    <span class="hljs-built_in">bool</span> bInterchange = <span class="hljs-literal">false</span>;<br><br><span class="hljs-built_in">int</span> dx = abs(x1 - x0);<br>    <span class="hljs-built_in">int</span> dy = abs(y1 - y0);<br>    <span class="hljs-built_in">int</span> signx = x0 &lt; x1 ? <span class="hljs-number">1</span>: <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">int</span> signy = y0 &lt; y1 ? <span class="hljs-number">1</span>: <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span>(dy &gt; dx)&#123;<br>        <span class="hljs-built_in">int</span> temp = dy;<br>        dy = dx;<br>        dx = temp;<br>        bInterchange = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> e = dx - <span class="hljs-number">2</span> * dy;<br>    <span class="hljs-built_in">int</span> x = x0;<br>    <span class="hljs-built_in">int</span> y = y0;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= dx; i++)&#123;<br>        DrawPoint(x, y);<br>        <span class="hljs-keyword">if</span>(bInterchange)&#123;<br>            y += signy;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            x += signx;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(e &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(bInterchange)&#123;<br>                x += signx;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                y += signy;<br>            &#125;<br>            e += <span class="hljs-number">2</span> * dx - <span class="hljs-number">2</span> * dy;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            e -= <span class="hljs-number">2</span> * dy;<br>        &#125;<br>    &#125;<br> <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="画三角形方法">画三角形方法</h2><h3 id="利用线性插值画三角形">利用线性插值画三角形</h3><p>让我们假设三角形的三个点 t0，t1, t2，通过 y 坐标的大小排序成升序。 那么，边界 A 在是 t0 和 t2 之间的线段，边界 B 是 t0 和 t1 之间线段，最后的在 t1 和 t2 之间的线段。以高度差作为循环控制变量，从左到右对相同高度的像素进行着色。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawTriangle1</span>(<span class="hljs-params">Point t0, Point t1, Point t2</span>)</span><br>&#123;<br>    <span class="hljs-comment">//三角形的三个点y值相同，面积为0</span><br>    <span class="hljs-keyword">if</span> (t0.y == t1.y &amp;&amp; t1.y == t2.y) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//根据y值大小对坐标进行排序</span><br>    <span class="hljs-keyword">if</span> (t0.y &gt; t1.y)<br>    &#123;<br>        TempSwap(<span class="hljs-keyword">ref</span> t0, <span class="hljs-keyword">ref</span> t1);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (t0.y &gt; t2.y)<br>    &#123;<br>        TempSwap(<span class="hljs-keyword">ref</span> t0, <span class="hljs-keyword">ref</span> t2);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (t1.y &gt; t2.y)<br>    &#123;<br>        TempSwap(<span class="hljs-keyword">ref</span> t1, <span class="hljs-keyword">ref</span> t2);<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> total_height = t2.y - t0.y;<br>    <span class="hljs-comment">//以高度差作为循环控制变量，此时不需要考虑斜率，因为着色完后每行都会被填充</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; total_height; i++)<br>    &#123;<br>        <span class="hljs-built_in">bool</span> second_half = i &gt; t1.y - t0.y || t1.y == t0.y;<br><br>        <span class="hljs-built_in">int</span> segment_height = second_half ? t2.y - t1.y : t1.y - t0.y;<br>        <span class="hljs-built_in">float</span> alpha = (<span class="hljs-built_in">float</span>)i / total_height;<br>        <span class="hljs-built_in">float</span> beta = (<span class="hljs-built_in">float</span>)(i - (second_half ? t1.y - t0.y : <span class="hljs-number">0</span>)) / segment_height;<br>        <span class="hljs-comment">//计算A，B两点的坐标</span><br>        Point A = t0 + (t2 - t0) * alpha;<br>        Point B = second_half ? t1 + (t2 - t1) * beta : t0 + (t1 - t0) * <span class="hljs-function">beta</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">if</span> (<span class="hljs-params">A.x &gt; B.x</span>)</span><br>        &#123;<br>            TempSwap(<span class="hljs-keyword">ref</span> A, <span class="hljs-keyword">ref</span> B);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = A.x; j &lt;= B.x; j++)<br>        &#123;<br>            <span class="hljs-built_in">float</span> phi = B.x == A.x ? <span class="hljs-number">1f</span> : (<span class="hljs-built_in">float</span>)(j - A.x) / (<span class="hljs-built_in">float</span>)(B.x - A.x);<br>            Point P = A + (B - A) * phi;<br>            DrawPoint(P.x, P.y);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="利用叉乘画三角形">利用叉乘画三角形</h3><p>对于三角形 $\triangle ABC$ 来说，把三条边看作 $\overset{\longrightarrow}{AB}$、$\overset{\longrightarrow}{BC}$、$\overset{\longrightarrow}{CA}$ 三条首尾相连的向量，平面内有一个点 $P$，我们通过向量叉乘来判断相对位置。</p><p>对二维向量叉乘做一个定义：</p><p>假设有两个二维向量 $\vec{a}$ 和 $\vec{b}$，我们把它们视为三维向量，$z$ 轴补 0，那么这个时候的 $\vec{a}$ 和 $\vec{b}$ 叉乘的结果为 $\vec{c}$，$\vec{c}$ 的 $x$ 值为 0， $y$ 值为 0， $z$ 值为 $a.x \times b.y - b.x \times a.y$，这个时候可以吧二维向量的叉乘定义为得到一个值，即为 $\vec{c}$ 的 $z$ 值。</p><ul><li>如果 $z$ 值大于 0，表示 $\vec{b}$ 在 $\vec{a}$ 的左侧</li><li>如果 $z$ 值小于 0，表示 $\vec{b}$ 在 $\vec{a}$ 的右侧</li><li>如果 $z$ 值等于 0，表示 $\vec{b}$ 与 $\vec{a}$ 共线</li></ul><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_15.png" alt=""></p><ul><li>$\overset{\longrightarrow}{AB} \times \overset{\longrightarrow}{AP}$，值为正，则 $P$ 在 $AB$ 左侧</li><li>$\overset{\longrightarrow}{BC} \times \overset{\longrightarrow}{BP}$，值为正，则 $P$ 在 $BC$ 左侧</li><li>$\overset{\longrightarrow}{CA} \times \overset{\longrightarrow}{CP}$，值为正，则 $P$ 在 $AC$ 左侧</li></ul><p>综合以上三个条件，我们可以判断 $P$ 在 $\triangle ABC$ 内。如果三个计算中有值为负的情况，说明 $P$ 在 $\triangle ABC$ 外。如果有值为 0 的情况，说明 $P$ 在 $\triangle ABC$ 的边或顶点上。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-function">Vector3 <span class="hljs-title">crossProduct</span>(<span class="hljs-params">Point[] points, Point P</span>)</span><br>&#123;<br>    Vector2 AB = <span class="hljs-keyword">new</span> Vector2(points[<span class="hljs-number">1</span>].x - points[<span class="hljs-number">0</span>].x, points[<span class="hljs-number">1</span>].y - points[<span class="hljs-number">0</span>].y);<br>    Vector2 BC = <span class="hljs-keyword">new</span> Vector2(points[<span class="hljs-number">2</span>].x - points[<span class="hljs-number">1</span>].x, points[<span class="hljs-number">2</span>].y - points[<span class="hljs-number">1</span>].y);<br>    Vector2 CA = <span class="hljs-keyword">new</span> Vector2(points[<span class="hljs-number">0</span>].x - points[<span class="hljs-number">2</span>].x, points[<span class="hljs-number">0</span>].y - points[<span class="hljs-number">2</span>].y);<br><br>    Vector2 AP = <span class="hljs-keyword">new</span> Vector2(P.x - points[<span class="hljs-number">0</span>].x, P.y - points[<span class="hljs-number">0</span>].y);<br>    Vector2 BP = <span class="hljs-keyword">new</span> Vector2(P.x - points[<span class="hljs-number">1</span>].x, P.y - points[<span class="hljs-number">0</span>].y);<br>    Vector2 CP = <span class="hljs-keyword">new</span> Vector2(P.x - points[<span class="hljs-number">2</span>].x, P.y - points[<span class="hljs-number">0</span>].y);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector3(AB.x * AP.y - AP.x * AB.y, BC.x * BP.y - BP.x * BC.y, CA.x * CP.y - CP.x * CA.y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawTriangle2</span>(<span class="hljs-params">Point[] points</span>)</span><br>&#123;<br>    Vector2 bboxmin = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-built_in">float</span>.MaxValue,<span class="hljs-built_in">float</span>.MaxValue);<br>    Vector2 bboxmax = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-built_in">float</span>.MinValue,<span class="hljs-built_in">float</span>.MinValue);<br>    Vector2 clamp = <span class="hljs-keyword">new</span> Vector2(canvas.Width - <span class="hljs-number">1</span>, canvas.Height - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        bboxmin.x = Math.Max(<span class="hljs-number">0f</span>, Math.Min(bboxmin.x, points[i].x));<br>        bboxmin.y = Math.Max(<span class="hljs-number">0f</span>, Math.Min(bboxmin.y, points[i].y));<br>        bboxmax.x = Math.Min(clamp.x, Math.Max(bboxmax.x, points[i].x));<br>        bboxmax.y = Math.Min(clamp.y, Math.Max(bboxmax.y, points[i].y));<br>    &#125;<br><br>    Point p;<br>    <span class="hljs-keyword">for</span>(p.x = (<span class="hljs-built_in">int</span>)Math.Ceiling(bboxmin.x); p.x &lt;= (<span class="hljs-built_in">int</span>)Math.Floor(bboxmax.x); p.x++)&#123;<br>        <span class="hljs-keyword">for</span>(p.y = (<span class="hljs-built_in">int</span>)Math.Ceiling(bboxmin.y); p.y &lt;= (<span class="hljs-built_in">int</span>)Math.Floor(bboxmax.y); p.y++)&#123;<br>            Vector3 cross = crossProduct(points, p);<br>            <span class="hljs-keyword">if</span>(cross.x &lt; <span class="hljs-number">0</span> || cross.y &lt; <span class="hljs-number">0</span> || cross.z &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            DrawPoint(p.x, p.y);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="利用三角形重心画三角形">利用三角形重心画三角形</h3><p>有关于三角形重心的介绍可以参考上一篇博文，下面给出代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> Vector3 <span class="hljs-title">CrossProduct</span>(<span class="hljs-params">Vector3 v1, Vector3 v2</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector3(<br>        v1.y * v2.z - v1.z * v2.y,<br>        v1.z * v2.x - v1.x * v2.z,<br>        v1.x * v2.y - v1.y * v2.x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Vector3 <span class="hljs-title">Barycentric</span>(<span class="hljs-params">Point A, Point B, Point C, Point P</span>)</span><br>&#123;<br>    Vector3 x = <span class="hljs-keyword">new</span> Vector3(B.x - A.x, C.x - A.x, A.x - P.x);<br>    Vector3 y = <span class="hljs-keyword">new</span> Vector3(B.y - A.y, C.y - A.y, A.y - P.y);<br>    Vector3 u = CrossProduct(x, y);<br><br>    <span class="hljs-keyword">if</span> (Math.Abs(u.z) &gt; <span class="hljs-built_in">float</span>.Epsilon)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1f</span> - (u.x + u.y) / u.z, u.y / u.z, u.x / u.z);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawTriangle3</span>(<span class="hljs-params">Point[] points</span>)</span><br>&#123;<br>    Vector2 bboxmin = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-built_in">float</span>.MaxValue,<span class="hljs-built_in">float</span>.MaxValue);<br>    Vector2 bboxmax = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-built_in">float</span>.MinValue,<span class="hljs-built_in">float</span>.MinValue);<br>    Vector2 clamp = <span class="hljs-keyword">new</span> Vector2(canvas.Width - <span class="hljs-number">1</span>, canvas.Height - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        bboxmin.x = Math.Max(<span class="hljs-number">0f</span>, Math.Min(bboxmin.x, points[i].x));<br>        bboxmin.y = Math.Max(<span class="hljs-number">0f</span>, Math.Min(bboxmin.y, points[i].y));<br>        bboxmax.x = Math.Min(clamp.x, Math.Max(bboxmax.x, points[i].x));<br>        bboxmax.y = Math.Min(clamp.y, Math.Max(bboxmax.y, points[i].y));<br>    &#125;<br><br>    Point p;<br>    <span class="hljs-keyword">for</span>(p.x = (<span class="hljs-built_in">int</span>)Math.Ceiling(bboxmin.x); p.x &lt;= (<span class="hljs-built_in">int</span>)Math.Floor(bboxmax.x); p.x++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(p.y = (<span class="hljs-built_in">int</span>)Math.Ceiling(bboxmin.y); p.y &lt;= (<span class="hljs-built_in">int</span>)Math.Floor(bboxmax.y); p.y++)<br>        &#123;<br>            Vector3 bc_screen = Barycentric(points[<span class="hljs-number">0</span>], points[<span class="hljs-number">1</span>], points[<span class="hljs-number">2</span>], p);<br>            <span class="hljs-keyword">if</span> (bc_screen.x &lt; <span class="hljs-number">0f</span> || bc_screen.y &lt; <span class="hljs-number">0f</span> || bc_screen.z &lt; <span class="hljs-number">0f</span>) <span class="hljs-keyword">continue</span>;<br>            DrawPoint(p.x, p.y);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三角形重心坐标</title>
    <link href="/posts/%E4%B8%89%E8%A7%92%E5%BD%A2%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/"/>
    <url>/posts/%E4%B8%89%E8%A7%92%E5%BD%A2%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h2 id="三角形">三角形</h2><p>想要定义一个三角形只需列出其 3 个顶点即可，但是列出这三个顶点的顺序非常重要。在左手坐标系并且从三角形正面看时，通常按照顺时针顺序枚举顶点。我们将这 3 个顶点分别称为 $\bf v_1$， $\bf v_2$， $\bf v_3$。</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_1.png" alt=""></p><p>其中的边长和长度可以表示为：<br>$$<br>\begin{aligned}<br>{\bf e_1} &amp;= {\bf v_3} - {\bf v_2} &amp; {\bf e_2} &amp;= {\bf v_1} - {\bf v_3} &amp; {\bf e_3} &amp;= {\bf v_2} - {\bf v_1}\<br>l_1 &amp;= \lVert {\bf e_1} \rVert &amp; l_2 &amp;= \lVert {\bf e_2} \rVert &amp; l_3 &amp;= \lVert {\bf e_3} \rVert<br>\end{aligned}<br>$$</p><p>正弦定理：<br>$$<br>\frac{\sin(\theta_1)}{l_1} = \frac{\sin(\theta_2)}{l_2} = \frac{\sin(\theta_3)}{l_3}<br>$$</p><p>余弦定理：<br>$$<br>\begin{aligned}<br>l_1^2 = l_2^2 + l_3^2 - 2l_2l_3\cos\theta_1\<br>l_2^2 = l_1^2 + l_3^2 - 2l_1l_3\cos\theta_2\<br>l_3^2 = l_1^2 + l_2^2 - 2l_1l_2\cos\theta_3\<br>\end{aligned}<br>$$</p><p>三角形周长：<br>$$<br>p = l_1 + l_2 + l_3<br>$$</p><h2 id="三角形面积">三角形面积</h2><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_2.png" alt=""></p><p>三角形面积：<br>$$<br>A = bh/2<br>$$</p><p>如果高度未知，则可以使用海伦公式，该公式只需要三边的边长即可求三角形的面积：<br>$$<br>\begin{aligned}<br>s = \frac{l_1 + l_2 + l_3}{2} = \frac{p}{2}<br>A = \sqrt{s(s - l_1)(s - l_2)(s - l_3)}<br>\end{aligned}<br>$$</p><p>我们还可以单独通过顶点坐标来计算三角形的面积，其基本思想是，为三角形的三条边中的每一条边计算梯形的有符号的面积，该面积由边和下方的 x 轴所界定，如下图所示</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_3.png" alt=""></p><p>“有符号的面积”是指如果边的指向是从左到右，则该面积为正；如果边的指向是从右到左，则面积为负。请注意，无论三角形如何定向，总会有至少一条边的面积为正值并且至少一条边的面积为负值。垂直边的面积为零。每条边下的面积公式为：<br>$$<br>\begin{aligned}<br>A({\bf e_1}) = \frac{(y_3 + y_2)(x_3 - x_2)}{2}\<br>A({\bf e_2}) = \frac{(y_1 + y_3)(x_1 - x_3)}{2}\<br>A({\bf e_3}) = \frac{(y_2 + y_1)(x_2 - x_1)}{2}\<br>\end{aligned}<br>$$</p><p>通过对 3 个梯形的有符号面积求和，可以获得三角形本身的面积。假设三角形周围的顶点按顺时针排序（如果按相反的顺序排序会反转面积的符号），可以通过下式对梯形的面积求和来计算三角形的有符号面积：<br>$$<br>\begin{aligned}<br>A &amp;= A({\bf e_1}) + A({\bf e_2}) + A({\bf e_3})\<br>&amp;= \frac{(y_3 + y_2)(x_3 - x_2) + (y_1 + y_3)(x_1 - x_3) + (y_2 + y_1)(x_2 - x_1)}{2}\<br>&amp;= \frac{y_3x_3 - y_3x_2 + y_2x_3 - y_2x_2 + y_1x_1 - y_1x_3 + y_3x_1 - y_3x_3 + y_2x_2 - y_2x_1 + y_1x_2 - y_1x_1}{2}\<br>&amp;= \frac{-y_3x_2 + y_2x_3 - y_1x_3 + y_3x_1 - y_2x_1 + y_1x_2}{2}\<br>&amp;= \frac{y_1(x_2 - x_3) + y_2(x_3 - x_1) + y_3(x_1 - x_2)}{2}<br>\end{aligned}<br>$$</p><p>我们还可以进一步化简这个式子，因为我们可以在不影响面积的情况下平移三角形，比如将三角形垂直移动直到一点落在 x 轴上。例如当第三个点落到 x 轴上时，我们可以从每个 y 坐标中减去 $y_3$：<br>$$<br>\begin{aligned}<br>A &amp;= \frac{y_1(x_2 - x_3) + y_2(x_3 - x_1) + y_3(x_1 - x_2)}{2}\<br>&amp;= \frac{(y_1 - y_3)(x_2 - x_3) + (y_2 - y_3)(x_3 - x_1) + (y_3 - y_3)(x_1 - x_2)}{2}\<br>&amp;= \frac{(y_1 - y_3)(x_2 - x_3) + (y_2 - y_3)(x_3 - x_1)}{2}<br>\end{aligned}<br>$$</p><p>在三维中，可以使用叉积来计算三角形的面积，两个矢量 ${\bf a}$ 和 ${\bf b}$ 的叉积的大小等于通过 ${\bf a}$ 和 ${\bf b}$ 这两条边形成的平行四边形的面积。由于三角形的面积是封闭的平行四边形面积的一半，那么，给定来自三角形的两个边矢量 ${\bf e_1}$ 和 ${\bf e_2}$，该三角形的面积为：<br>$$<br>A = \frac{\lVert{\bf e_1 \times e_2}\rVert}{2}<br>$$</p><h2 id="重心空间">重心空间</h2><p>三角形平面中的任何点都可以表示为顶点的加权平均值。这些加权称为重心坐标。从重心坐标 ($b_1$, $b_2$, $b_3$) 到标准三维空间的转换可由下式定义：<br>$$<br>(b_1, b_2, b_3) \equiv b_1{\bf v_1}  + b_2{\bf v_2}  + b_3{\bf v_3}<br>$$<br>重心坐标是一些矢量的线性组合，而普通笛卡尔坐标也可以解释为基矢量的线性组合，但重心坐标和普通笛卡尔坐标之间有一个细微的区别，那就是重心坐标的坐标之和被限制为 1，其定义如下：<br>$$<br>b_1 + b_2 + b_3 = 1<br>$$<br>值 $b_1$、$b_2$、$b_3$ 分别是每个顶点对该点的“贡献”或“权重”。下图显示了点及其重心坐标的一些示例。</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_4.png" alt=""></p><p>上图中的三角形的 3 个顶点在重心坐标中具有以下很简单的形式：<br>$$<br>(1, 0, 0) \equiv {\bf v_1} \qquad (0, 1, 0) \equiv {\bf v_2} \qquad (0, 0, 1) \equiv {\bf v_3}<br>$$<br>而且，与顶点相对的一条边上的所有点对应于该顶点的重心坐标将具有零值。例如，对于包含 ${\bf e_1}$（与 ${\bf v_1}$ 相对）的直线上的所有点，$b_1 = 0$。</p><p>平面中的任何点都可以用重心坐标来描述，而不仅仅是三角形内的点。三角形内部的点的重心坐标都在 [0, 1] 范围内，三角形外的任何点都将至少有一个负坐标值。重心空间可以将平面以与原始三角形大小相同的三角形来网格化，如下图所示。</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_5.png" alt=""></p><p>还有另一种思考重心坐标的方法。丢弃 $b_3$，我们可以将 ($b_1$, $b_2$) 解释为常规的 (x, y) 二维坐标，其中，原点位于 ${\bf v_3}$，x 轴是 ${\bf v_1 - v_3}$，y 轴是 ${\bf v_2 - v_3}$：<br>$$<br>\begin{aligned}<br>(b_1, b_2, b_3) &amp;\equiv b_1{\bf v_1} + b_2{\bf v_2} + b_3{\bf v_3}\<br>&amp;\equiv b_1{\bf v_1} + b_2{\bf v_2} + (1 - b_1 - b_2){\bf v_3}\<br>&amp;\equiv b_1{\bf v_1} + b_2{\bf v_2} + {\bf v_3} - b_1{\bf v_3} - b_2{\bf v_3}\<br>&amp;\equiv {\bf v_3} + b_1({\bf v_1 - v_3}) + b_2({\bf v_2 - v_3})<br>\end{aligned}<br>$$</p><h2 id="计算重心坐标">计算重心坐标</h2><p>现在来看一看如何确定笛卡尔坐标的重心坐标。先从下图的二维开始，它显示了 ${\bf v_1}$、${\bf v_2}$ 和 ${\bf v_3}$ 这三个顶点以及点 ${\bf p}$。我们还标记了 3 个分割出来的子三角形 $T_1$、$T_2$、$T_3$，它们与同一索引的顶点相对。</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_6.png" alt=""></p><p>已知 3 个顶点和点 ${\bf p}$ 的笛卡尔坐标，求重心坐标 $b_1$、$b_2$ 和 $b_3$。以下给了 3 个方程和 3 个未知数：<br>$$<br>\begin{aligned}<br>b_1x_1 + b_2x_2 + b_3x_3 &amp;= p_x,\<br>b_1y_1 + b_2y_2 + b_3y_3 &amp;= p_y,\<br>b_1 + b_2 + b_3 &amp;= 1<br>\end{aligned}<br>$$</p><p>求解该方程组得出以下结果：<br>$$<br>\begin{aligned}<br>b_1 &amp;= \frac{(p_y - y_3)(x_2 - x_3) + (y_2 - y_3)(x_3 - p_x)}{(y_1 - y_3)(x_2 - x_3) + (y_2 - y_3)(x_3 - x_1)},\<br>b_2 &amp;= \frac{(p_y - y_1)(x_3 - x_1) + (y_3 - y_1)(x_1 - p_x)}{(y_1 - y_3)(x_2 - x_3) + (y_2 - y_3)(x_3 - x_1)},\<br>b_3 &amp;= \frac{(p_y - y_2)(x_1 - x_2) + (y_1 - y_2)(x_2 - p_x)}{(y_1 - y_3)(x_2 - x_3) + (y_2 - y_3)(x_3 - x_1)}\<br>\end{aligned}<br>$$</p><p>可以看到每个表达式中的分母是相同的，而且由海伦公式的变形可知它等于三角形面积的两倍。而对于每个重心坐标 $b_i$ 来说，其分子等于子三角形 $T_i$ 的面积的两倍，换言之：<br>$$<br>b_1 = A(T_1)/A(T),\qquad b_2 = A(T_2)/A(T),\qquad b_3 = A(T_3)/A(T)<br>$$</p><p>请注意，即使 ${\bf p}$ 在三角形之外，此解释也是适用的，因为如果顶点以逆时针顺序枚举，则计算面积的公式会产生负值结果。如果三角形的三个顶点是共线的，那么分母中的面积将为零，因此不能计算重心坐标。</p><p>计算三维中任意点 ${\bf p}$ 的重心坐标比在二维中更复杂。我们不能像以前一样求解方程组，因为有 3 个未知数和 4 个方程。另一个复杂因素是 ${\bf p}$ 可能不在包含三角形的平面中，在这种情况下，重心坐标是不确定的。现在，先假设 ${\bf p}$ 位于包含三角形的平面中的情形。</p><p>一个有效的技巧是，通过丢弃 x、y 或 z 中的一个来将三维问题转变为二维问题。这具有将三角形投影到 3 个基本平面之一上的效果。以直觉而言，这是有效的，因为投影面积与原始面积成正比。</p><p>但是，应该丢弃哪一个坐标呢？我们不能总丢弃相同的，因为如果三角形垂直于投影平面，投影点将是共线的。如果三角形几乎垂直于投影平面，那么将遇到浮点精度问题。解决这个问题的方法是选择投影平面，以便最大化投影三角形的面积。这可以通过检查平面法线来完成，具有最大绝对值的坐标就是我们将要丢弃的坐标。例如，如果法线是 [0.267, -0.802, 0.535]，那么将丢弃顶点和 ${\bf p}$ 点的 y 值，投影到 xz 平面上。</p><p>下面代码展示如何计算任意三维点的重心坐标：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">computeBarycentricCoords3d</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">const</span> Vector3 v[<span class="hljs-number">3</span>], <span class="hljs-comment">// vertices of the triangle</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> Vector3 &amp;p,   <span class="hljs-comment">// point that we wish to compute coords for</span></span><br><span class="hljs-params">    <span class="hljs-type">float</span> b[<span class="hljs-number">3</span>]          <span class="hljs-comment">// barycentric coords returned here</span></span><br><span class="hljs-params">)</span> &#123;<br><br>    <span class="hljs-comment">// First, compute two clockwise edge vectors</span><br>    Vector3 d1 = v[<span class="hljs-number">1</span>] - v[<span class="hljs-number">0</span>];<br>    Vector3 d2 = v[<span class="hljs-number">2</span>] - v[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// Compute surface normal using cross product.  In many cases</span><br>    <span class="hljs-comment">// this step could be skipped, since we would have the surface</span><br>    <span class="hljs-comment">// normal precomputed.  We do not need to normalize it, although</span><br>    <span class="hljs-comment">// if a precomputed normal was normalized, it would be OK.</span><br>    Vector3 n = crossProduct(d1, d2);<br><br>    <span class="hljs-comment">// Locate dominant axis of normal, and select plane of projection</span><br>    <span class="hljs-type">float</span> u1, u2, u3, u4;<br>    <span class="hljs-type">float</span> v1, v2, v3, v4;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">fabs</span>(n.x) &gt;= <span class="hljs-built_in">fabs</span>(n.y)) &amp;&amp; (<span class="hljs-built_in">fabs</span>(n.x) &gt;= <span class="hljs-built_in">fabs</span>(n.z))) &#123;<br><br>        <span class="hljs-comment">// Discard x, project onto yz plane</span><br>        u1 = v[<span class="hljs-number">0</span>].y - v[<span class="hljs-number">2</span>].y;<br>        u2 = v[<span class="hljs-number">1</span>].y - v[<span class="hljs-number">2</span>].y;<br>        u3 = p.y - v[<span class="hljs-number">0</span>].y;<br>        u4 = p.y - v[<span class="hljs-number">2</span>].y;<br><br>        v1 = v[<span class="hljs-number">0</span>].z - v[<span class="hljs-number">2</span>].z;<br>        v2 = v[<span class="hljs-number">1</span>].z - v[<span class="hljs-number">2</span>].z;<br>        v3 = p.z - v[<span class="hljs-number">0</span>].z;<br>        v4 = p.z - v[<span class="hljs-number">2</span>].z;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(n.y) &gt;= <span class="hljs-built_in">fabs</span>(n.z)) &#123;<br><br>        <span class="hljs-comment">// Discard y, project onto xz plane</span><br>        u1 = v[<span class="hljs-number">0</span>].z - v[<span class="hljs-number">2</span>].z;<br>        u2 = v[<span class="hljs-number">1</span>].z - v[<span class="hljs-number">2</span>].z;<br>        u3 = p.z - v[<span class="hljs-number">0</span>].z;<br>        u4 = p.z - v[<span class="hljs-number">2</span>].z;<br><br>        v1 = v[<span class="hljs-number">0</span>].x - v[<span class="hljs-number">2</span>].x;<br>        v2 = v[<span class="hljs-number">1</span>].x - v[<span class="hljs-number">2</span>].x;<br>        v3 = p.x - v[<span class="hljs-number">0</span>].x;<br>        v4 = p.x - v[<span class="hljs-number">2</span>].x;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>        <span class="hljs-comment">// Discard z, project onto xy plane</span><br>        u1 = v[<span class="hljs-number">0</span>].x - v[<span class="hljs-number">2</span>].x;<br>        u2 = v[<span class="hljs-number">1</span>].x - v[<span class="hljs-number">2</span>].x;<br>        u3 = p.x - v[<span class="hljs-number">0</span>].x;<br>        u4 = p.x - v[<span class="hljs-number">2</span>].x;<br><br>        v1 = v[<span class="hljs-number">0</span>].y - v[<span class="hljs-number">2</span>].y;<br>        v2 = v[<span class="hljs-number">1</span>].y - v[<span class="hljs-number">2</span>].y;<br>        v3 = p.y - v[<span class="hljs-number">0</span>].y;<br>        v4 = p.y - v[<span class="hljs-number">2</span>].y;<br>    &#125;<br><br>    <span class="hljs-comment">// Compute denominator, check for invalid</span><br>    <span class="hljs-type">float</span> denom = v1*u2 - v2*u1;<br>    <span class="hljs-keyword">if</span> (denom == <span class="hljs-number">0.0f</span>) &#123;<br><br>        <span class="hljs-comment">// Bogus triangle - probably triangle has zero area</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Compute barycentric coordinates</span><br>    <span class="hljs-type">float</span> oneOverDenom = <span class="hljs-number">1.0f</span> / denom;<br>    b[<span class="hljs-number">0</span>] = (v4*u2 - v2*u4) * oneOverDenom;<br>    b[<span class="hljs-number">1</span>] = (v1*u3 - v3*u1) * oneOverDenom;<br>    b[<span class="hljs-number">2</span>] = <span class="hljs-number">1.0f</span> - b[<span class="hljs-number">0</span>] - b[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// OK</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种技术可以用于计算三维中的重心坐标，那就是使用叉积来计算三维三角形的面积的方法。给定三角形的两个边矢量 $\bf e_1$ 和 $\bf e_2$，可以将三角形的面积计算为 $\lVert{\bf e_1 \times e_2}\rVert /2$。只要得到整个三角形的面积和 3 个子三角形的面积，就可以计算出其重心坐标。</p><p>当然，这里有一个小问题：叉积的大小对顶点的排序不敏感——按照定义，其大小总是正的。那么三角形之外的点就不适用了，因为三角形之外的点必须始终至少有一个负重心坐标。看起来我们真正需要的是一种计算叉积矢量长度的方法，如果顶点以“不正确”的顺序枚举，则会产生负值。事实证明，使用点积有一种非常简单的方法。</p><p>假设将 $\bf c$ 指定为三角形的两个边矢量的叉积，$\bf c$ 的大小将等于三角形面积的两倍。假设有一个单位长度的法线 $\bf \hat{n}$。现在 $\bf c$ 和 $\bf \hat{n}$ 是平行的，因为它们都垂直于三角形所在的平面。但是，它们可能指向相反的方向，所以：<br>$$<br>\begin{aligned}<br>{\bf c} \cdot {\bf \hat{n}} &amp;= \lVert {\bf c} \rVert \lVert {\bf \hat{n}} \rVert \cos\theta\<br>&amp;= \lVert {\bf c} \rVert(1)(\pm 1)\<br>&amp;= \pm \lVert {\bf c} \rVert<br>\end{aligned}<br>$$</p><p>将此结果除以 2，就可以计算三维中三角形的“有符号面积”。</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_7.png" alt=""></p><p>在上图中，每个顶点都有一个从 $\bf v_i$ 到 $\bf p$ 的矢量，名为 $\bf d_i$。<br>$$<br>\begin{aligned}<br>{\bf e_1} &amp;= {\bf v_3} - {\bf v_2} &amp; {\bf e_2} &amp;= {\bf v_1} - {\bf v_3} &amp; {\bf e_3} &amp;= {\bf v_2} - {\bf v_1}\<br>{\bf d_1} &amp;= {\bf p} - {\bf v_1} &amp; {\bf d_2} &amp;= {\bf p} - {\bf v_2} &amp; {\bf d_3} &amp;= {\bf p} - {\bf v_3}<br>\end{aligned}<br>$$</p><p>我们还需要一个表面法线，可以通过下式计算：<br>$$<br>\bf \hat{n} = \frac{e_1 \times e_2}{\lVert e_1 \times e_2 \rVert}<br>$$</p><p>现在整个三角形（简称为 $T$）的面积和 3 个子三角形的面积可由下式给出：<br>$$<br>\begin{aligned}<br>A(T) &amp;= (({\bf e_1 \times e_2})\cdot{\bf\hat{n}})/2\<br>A(T_1) &amp;= (({\bf e_1 \times d_3})\cdot{\bf\hat{n}})/2\<br>A(T_2) &amp;= (({\bf e_2 \times d_1})\cdot{\bf\hat{n}})/2\<br>A(T_3) &amp;= (({\bf e_3 \times d_2})\cdot{\bf\hat{n}})/2<br>\end{aligned}<br>$$</p><p>每个重心坐标 $b_i$ 可由 $A(T_i)/A(T)$ 给出：<br>$$<br>\begin{aligned}<br>b_1 = A(T_1)/A(T) = \frac{({\bf e_1 \times d_3})\cdot{\bf\hat{n}}}{({\bf e_1 \times e_2})\cdot{\bf\hat{n}}}\<br>b_2 = A(T_2)/A(T) = \frac{({\bf e_2 \times d_1})\cdot{\bf\hat{n}}}{({\bf e_1 \times e_2})\cdot{\bf\hat{n}}}\<br>b_3 = A(T_3)/A(T) = \frac{({\bf e_3 \times d_2})\cdot{\bf\hat{n}}}{({\bf e_1 \times e_2})\cdot{\bf\hat{n}}}\<br>\end{aligned}<br>$$</p><p>请注意，$\bf \hat{n}$ 被用于所有的分子和分母，所以它不一定必须是单位矢量。</p><h2 id="特殊点">特殊点</h2><h3 id="重心">重心</h3><p>重心是三角形完美的平衡点，它是中线的交点（中线是从一个顶点到对边中点的直线）。</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_8.png" alt=""></p><p>重心是 3 个顶点的几何平均值：<br>$$<br>{\bf c_{Grav}} = \frac{\bf v_1 + v_2 + v_3}{3}<br>$$</p><p>重心坐标为：<br>$$<br>(\frac{1}{3}, \frac{1}{3}, \frac{1}{3})<br>$$<br>重心也被称为质心。</p><h3 id="内心">内心</h3><p>三角形的内心是三角形 3 条角平分线的焦点，它之所以被称为内心，是因为它也是三角形内切圆的圆心。由该特性可知，内心与三角形各条边的距离是相等的。</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_9.png" alt=""></p><p>内心可通过下式计算：<br>$$<br>{\bf c_{In}} = \frac{l_1{\bf v_1} + l_2{\bf v_2} + l_3{\bf v_3}}{p}<br>$$<br>其中，$p = l_1 + l_2 + l_3$ 是三角形的周长。因此，内心的重心坐标为：<br>$$<br>(\frac{l_1}{p}, \frac{l_2}{p}, \frac{l_3}{p})<br>$$<br>可以通过下式将三角形的面积除以其周长来计算内切圆的半径：<br>$$<br>r_{In} = \frac{A}{p}<br>$$<br>内切圆解决了找到与 3 条线相切的圆的问题。</p><h3 id="外心">外心</h3><p>外心是三角形中与顶点等距的点，它是围绕三角形的外接圆的圆心。外心构造为各条边的垂直平分线的交点。</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_10.png" alt=""></p><p>要计算外心，需要先定义以下的中间值：<br>$$<br>\begin{aligned}<br>d_1 &amp;= -{\bf e_2}\cdot{\bf e_3},\<br>d_2 &amp;= -{\bf e_3}\cdot{\bf e_1},\<br>d_3 &amp;= -{\bf e_1}\cdot{\bf e_2},\<br>c_1 &amp;= d_2d_3,\<br>c_2 &amp;= d_3d_1,\<br>c_3 &amp;= d_1d_2,\<br>c &amp;= c_1 + c_2 + c_3<br>\end{aligned}<br>$$<br>在取得这些中间值后，即可按下式给出外心的重心坐标：<br>$$<br>(\frac{c_2 + c_3}{2c}, \frac{c_3 + c_1}{2c}, \frac{c_1 + c_2}{2c})<br>$$</p><p>由此，外心可通过下式计算：<br>$$<br>{\bf c_{Circ}} = \frac{(c_2 + c_3){\bf v_1} + (c_3 + c_1){\bf v_2} + (c_1 + c_2){\bf v_3}}{2c}<br>$$</p><p>外接圆半径的计算公式为：<br>$$<br>r_{Circ} = \frac{\sqrt{(d_1 + d_2)(d_2 + d_3)(d_3 + d_1)/c}}{2}<br>$$<br>外接圆半径和外心解决了找到通过三个点的圆的问题。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四元数和三维旋转(三)</title>
    <link href="/posts/%E5%9B%9B%E5%85%83%E6%95%B0%E5%92%8C%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC(%E4%B8%89)/"/>
    <url>/posts/%E5%9B%9B%E5%85%83%E6%95%B0%E5%92%8C%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<h2 id="四元数插值">四元数插值</h2><p>假设有两个旋转变换 $q_0 = [\cos(\theta_{0}), \sin(\theta_{0})\pmb{u_0}]$ 和 $q_1 = [\cos(\theta_{1}), \sin(\theta_{1})\pmb{u_1}]$，我们希望找出一些中间变换 $q_{t}$，让初始变换 $q_{0}$ 能够平滑地过渡到最终变换 $q_{1}$，$t$ 的取值可以是 $t \in [0, 1]$，当 $t = 0$ 时 $q_{t}$ 等同于初始变换 $q_{0}$，而 $t = 1$ 时 $q_{t}$ 等同于最终变换 $q_{1}$。</p><p>由于插值的对象是两个<strong>变换</strong>，想象起来可能非常困难，我们不妨假设 3D 空间中有任意一个向量 $v$，那么 $q_{0}$ 会将 $v$ 变换到 $v_{0} = q_{0}vq_{0}^<em>$，而 $q_{1}$ 会将 $v$ 变换到 $v_{1} = q_{1}vq_{1}^</em>$。我们需要找出中间向量 $v_{t} = q_{t}vq_{t}^*$ 所对应的变换 $q_{t}$，使 $v$ 旋转到 $v_{0}$ 与 $v_{1}$ 中间的某个位置 $v_{t}$:</p><p><img src="/posts_image/Quaternion/Quaternion_9.png" alt=""></p><p>我们可以看到，这个<strong>旋转的变化量</strong>其实对应的仍是一个旋转。它将由 $q_{0}$ 变换到 $v_{0}$ 的向量进一步旋转到 $v_{t}$。这个旋转拥有某一个固定的旋转轴 $\pmb{u_{t}}$，我们只需要缩放这个变换所对应的角度 $\phi$ 就能够达到插值的目的了。</p><p>那么，现在的问题是，我们该怎么获得这个旋转的变化量。我们不妨考虑一下什么变换 $\Delta q$ 能将已经旋转到 $v_{0}$ 的向量 $v$ 直接变换到 $v_{1}$。这其实就是一个旋转的复合，我们先进行 $q_{0}$ 变换，再进行 $\Delta q$ 变换，它们复合的结果需要等于 $q_{1}$ 变换，也就是说：<br>$$<br>\Delta qq_{0} = q_{1}<br>$$<br>那么，<br>$$<br>\begin{aligned}<br>\Delta qq_{0}q_{0}^{-1} &amp;= q_{1}q_{0}^{-1}\<br>\<br>\Delta q &amp;= q_{1}q_{0}^{-1}\<br>\end{aligned}<br>$$</p><p>因为所有的旋转 $q$ 都是单位四元数，$q^{-1} = q^<em>$，它又可以写成：<br>$$<br>\Delta q = q_{1}q_{0}^</em><br>$$</p><p>如果我们对 $\Delta q$ 取 $t$ 次方，$(\Delta q)^t$ 就能缩放这个旋转所对应的角度了。所以，我们就能得出插值的公式：</p><p>$$<br>q_t = Slerp(q_0, q_1; t) = (q_1q_0^<em>)^tq_0<br>$$<br>可以发现，当 $t = 0$ 时，$q_t = q_0$；而当 $t = 1$ 时，$q_t = q_1$；如果 $t$ 为中间值，比如说 $t = 0.4$ 时，$q_t = (q_{1}q_{0}^</em>)^{0.4}q_{0}$，它会先进行 $q_0$ 变换将 $v$ 变换到 $v_0$，并在此基础上向 $v_1$ 旋转 40%.</p><p>这个插值方法称为Slerp，但它涉及到多个四元数的乘法，而且还包含幂运算，实际应用中效率很低。为了理解它我们还需要研究一下 3D 空间的旋转与四元数的 4D 向量空间之间的关系</p><h3 id="3D空间旋转变化量-vs-四元数4D向量空间夹角">3D空间旋转变化量 vs. 四元数4D向量空间夹角</h3><p>为了探讨这个关系，我们来实际计算一下 $\Delta q$。由于这个关系和角度有关，我们只需要关心 $\Delta q$ 的实部就可以了：</p><p>$$<br>\begin{aligned}<br>\Delta q &amp;= q_{1}q_{0}^*\<br>&amp;= [\cos(\theta_{1}), \sin(\theta_{1})\pmb{u_1}][\cos(\theta_{0}), -\sin(\theta_{0})\pmb{u_0}]\<br>&amp;= [\cos(\theta_{0})\cos(\theta_{1}) - (\sin(\theta_{1})\pmb{u_1})\cdot(-\sin(\theta_{0})\pmb{u_0}), \dots]\<br>&amp;= [\cos(\theta_{0})\cos(\theta_{1}) + (\sin(\theta_{1})\pmb{u_1})\cdot(\sin(\theta_{0})\pmb{u_0}), \dots]\<br>\end{aligned}<br>$$</p><p>如果将 $q_{0}$ 和 $q_{1}$ 看作是两个四维向量，我们可以发现 $\Delta q$ 的实部正好就是 $q_{0}$ 和 $q_{1}$ 点乘的结果 $q_{0} \cdot q_{1}$，因为 $q_{0}$ 和 $q_{1}$ 都是单位四元数，$q_{0} \cdot q_{1}$ 正好是这两个四元数在 4D 空间中夹角的余弦值，我们将这个夹角称为 $\theta$，那么 $q_{0} \cdot q_{1} = \cos(\theta)$</p><p>我们又知道，$\Delta q$ 表示的也是一个旋转，而如果它代表的旋转的角度是 $2\phi$，那么 $\Delta q$ 的实数部为 $\Delta q = [\cos(\phi), \dots]$。所以<br>$$<br>\Delta q = [\cos(\phi), \dots] = [\cos(\theta), \dots]\<br>\cos(\phi) = \cos(\theta)<br>$$</p><p>因为 $\phi$ 和 $\theta$ 都是夹角，$\phi，\theta \in [0, \pi]$，所以这个方程有唯一的解<br>$$<br>\phi = \theta<br>$$</p><p>这也就是说，$q_{0}$ 与 $q_{1}$ 作为向量在 4D 四元数空间中的夹角 $\theta$，正好是它们旋转变化量 $\Delta q$ 的所代表旋转的角度的一半，即 $\theta = \frac{1}{2}(2\phi)$。所以，我们可以直接用插值向量的方法对旋转进行插值。</p><p>为了更直观的理解这层关系，请看下面这两幅图。虽然四元数是出于四维空间之内的，但是因为只有两个四元数，我们可以将它们投影到一个二维的圆上来，也就是左图。右侧则是 3D 空间中发生的旋转改变</p><p><img src="/posts_image/Quaternion/Quaternion_10.png" alt=""></p><p>可以看到，当 $q_{1}$ 与 $q_{0}$ 之间的夹角为 $\theta$ 时，旋转的变化量正好是 $2\theta$。如果我们在圆上有一个单位四元数 $q_{t}$，使得它与 $q_{0}$ 的夹角为 $t\theta$，与 $q_{1}$ 的夹角为 $(1 - t)\theta$，那么我们就能保证在 3D 空间中，它相对于 $q_{0}$ 的旋转变化量为 $2t\theta$，相对于 $q_{1}$ 的旋转变化量为 $2(1 - t)\theta$。</p><p>现在，两个单位四元数的插值就被我们简化为了一个圆上（其实是超球面的一部分）两个向量的插值，我们能直接套用向量的插值公式对两个四元数进行插值。接下来，我们就来讨论如何对两个向量进行插值。</p><h2 id="Lerp-Nlerp-Slerp">Lerp, Nlerp, Slerp</h2><p>不论是哪种插值方法，我们都希望将中间向量 $v_{t}$ 写为初始向量 $v_{0}$ 和最终向量 $v_{1}$ 的线性组合，也就是说：<br>$$<br>v_{t} = \alpha v_{0} + \beta v_{1}<br>$$<br>其中，系数 $\alpha$ 与 $\beta$ 都是 $t$ 的函数。不同的插值方法只是拥有不同的系数而已。</p><h3 id="Lerp">Lerp</h3><p>首先是两个向量插值最简单的一种形式：<strong>线性插值</strong>，也叫做“Lerp”。Lerp 会沿着一条直线进行插值，如果将 $\pmb{v_{0}}$ 和 $\pmb{v_{1}}$ 看做是三角形的两个边，那么 $\pmb{v_{t}}$ 会指向三角形的第三条边。</p><p><img src="/posts_image/Quaternion/Quaternion_11.png" alt=""></p><p>我们能将 $\pmb{v_{t}}$ 写为两个向量的和。<br>$$<br>\begin{aligned}<br>\pmb{v_{t}} = Lerp(\pmb{v_{0}}, \pmb{v_{1}}, t) &amp;= \pmb{v_{0}} + t(\pmb{v_{1}} - \pmb{v_{0}})\<br>&amp;= (1 - t)\pmb{v_{0}} + t\pmb{v_{1}}<br>\end{aligned}<br>$$</p><p>如果将 Lerp 的结果应用到单位四元数上，我们可以得到：<br>$$<br>q_{t} = Lerp(q_{0}, q_{1}, t) = (1 - t)q_{0} + tq_{1}<br>$$<br>当然，因为我们是沿着一条直线（也就是圆上的一个弦）进行插值的，这样插值出来的四元数并不是单位四元数。</p><p><img src="/posts_image/Quaternion/Quaternion_12.png" alt=""></p><h3 id="Nlerp">Nlerp</h3><p>虽然这样插值出来的 $q_{t}$ 并不是单位四元数，但只要将 $q_{t}$ 除以他的模长 $\lVert q_{t} \rVert$ 就能够将其转化为一个单位四元数了。</p><p><img src="/posts_image/Quaternion/Quaternion_13.png" alt=""></p><p>我们将这种先对向量进行插值，再进行正规化的插值方法称为<strong>正规化线性插值</strong>，或者“Nlerp”。与 Lerp 不同，Nlerp 的两个输入向量必须是单位向量，否则插值出来的结果不会经过初始和最终向量。下面分别是向量和四元数的 Nlerp 公式。</p><p>$$<br>v_{t} = Nlerp(\pmb{v_{0}}, \pmb{v_{1}}, t) = \frac{(1 - t)\pmb{v_{0}} + t\pmb{v_{1}}}{\lVert (1 - t)\pmb{v_{0}} + t\pmb{v_{1}} \rVert}\<br>\<br>q_{t} = Nlerp(q_{0}, q_{1}, t) = \frac{(1 - t)q_{0} + tq_{1}}{\lVert (1 - t)q_{0} + tq_{1} \rVert}<br>$$</p><p>Nlerp 插值仍然存在有一定的问题，当需要插值的弧比较大时，$\pmb{v_{t}}$ 的角速度会有显著的变化．我们可以来看一个例子：</p><p><img src="/posts_image/Quaternion/Quaternion_14.png" alt=""></p><p>这五个 $t$ 值将整个弧和弦分割成了四个部分．虽然弦上的四段是等长的，但是四个弧是完全不相等的。$t = 0$ 到 $t = 0.25$ 之间的弧（红色）明显比 $t = 0.25$ 到 $t = 0.50$ 的弧（蓝色）要短了不少．</p><p>这也就是说，在同等时间内，$\pmb{v_{t}}$ 扫过的角度是不同的。$\pmb{v_{t}}$ 扫过的速度（或者说角速度）首先会不断地增加，到 $t = 0.50$ 之后会开始减速，所以 Nlerp 插值不能保证均匀的角速度．</p><h3 id="Slerp">Slerp</h3><p>为了解决这个问题，我们可以转而对角度进行线性插值。也就是说，如果 $\pmb{v_{1}}$ 和 $\pmb{v_{2}}$ 之间的夹角为 $\theta$，那么<br>$$<br>\theta_{t} = (1 - t)\cdot 0 + t\theta = t\theta<br>$$<br>因为对角度线性插值直接是让向量在球面上的一个弧上旋转，所以又称球面线性插值，或者“Slerp”。</p><p>上面的公式并没有涉及到任何的向量，我们希望将 $\pmb{v_{t}}$ 写为 $\pmb{v_{0}}$ 和 $\pmb{v_{1}}$ 的线性组合<br>$$<br>\pmb{v_{t}} = \alpha\pmb{v_{0}} + \beta\pmb{v_{1}}<br>\tag{1}<br>$$<br>这里的 $\pmb{v_{0}}$ 和 $\pmb{v_{1}}$ 仍是单位向量，为了求出这其中的 $\alpha$ 和 $\beta$，我们需要借助图像来找出一些关系：</p><p><img src="/posts_image/Quaternion/Quaternion_15.png" alt=""></p><p>我们可以先对(1)式的两边同时点乘 $\pmb{v_{0}}$<br>$$<br>\begin{aligned}<br>\pmb{v_{0}}\cdot\pmb{v_{t}} &amp;= \pmb{v_{0}}\cdot(\alpha\pmb{v_{0}} + \beta\pmb{v_{1}})\<br>\pmb{v_{0}}\cdot\pmb{v_{t}} &amp;= \alpha(\pmb{v_{0}}\cdot\pmb{v_{0}}) + \beta(\pmb{v_{0}}\cdot\pmb{v_{1}})<br>\end{aligned}<br>$$<br>我们知道，$\pmb{v_{0}}$ 和 $\pmb{v_{t}}$ 之间的夹角是 $t\theta$，$\pmb{v_{0}}$ 与它自身之间的夹角为 0，$\pmb{v_{0}}$ 和 $\pmb{v_{1}}$ 之间的夹角是 $\theta$，而且所有的向量都是单位向量，所以<br>$$<br>\cos(t\theta) = \alpha + \beta\cos(\theta)<br>\tag{2}<br>$$<br>同理，我们将(1)式的两边同时点乘 $\pmb{v_{1}}$，构造第二个方程<br>$$<br>\begin{aligned}<br>\pmb{v_{1}}\cdot\pmb{v_{t}} &amp;= \pmb{v_{1}}\cdot(\alpha\pmb{v_{0}} + \beta\pmb{v_{1}})\<br>\pmb{v_{1}}\cdot\pmb{v_{t}} &amp;= \alpha(\pmb{v_{1}}\cdot\pmb{v_{0}}) + \beta(\pmb{v_{1}}\cdot\pmb{v_{1}})<br>\end{aligned}<br>$$</p><p>$$<br>\cos((1 - t)\theta) = \alpha\cos(\theta) + \beta<br>\tag{3}<br>$$</p><p>现在我们可以用(2)式和(3)式求出 $\alpha$ 和 $\beta$ 了。</p><p>由(2)式可以得到<br>$$<br>\alpha = \cos(t\theta) - \beta\cos(\theta)<br>\tag{4}<br>$$</p><p>将(4)式代入(3)式<br>$$<br>\begin{aligned}<br>\cos((1 - t)\theta) &amp;= (\cos(t\theta) - \beta\cos(\theta))\cos(\theta) + \beta\<br>\cos((1 - t)\theta) &amp;= \cos(t\theta)\cos(\theta) - \beta\cos^2(\theta) + \beta\<br>\beta(1 - \cos^2(\theta)) &amp;= \cos((1 - t)\theta) - \cos(t\theta)\cos(\theta)\<br>\beta &amp;= \frac{\cos(\theta - t\theta) - \cos(t\theta)\cos(\theta)}{\sin^2(\theta)}\<br>\beta &amp;= \frac{\cos(\theta)\cos(t\theta) + \sin(\theta)\sin(t\theta) - \cos(t\theta)\cos(\theta)}{\sin^2(\theta)}\<br>\beta &amp;= \frac{\sin(\theta)\sin(t\theta)}{\sin^2(\theta)}\<br>\beta &amp;= \frac{\sin(t\theta)}{\sin(\theta)}<br>\end{aligned}<br>$$</p><p>将 $\beta$ 代入(4)式解出 $\alpha$<br>$$<br>\begin{aligned}<br>\alpha &amp;= \cos(t\theta) - (\frac{\sin(t\theta)}{\sin(\theta)})\cos(\theta)\<br>&amp;= \frac{\cos(t\theta)\sin(\theta) - \sin(t\theta)\cos(\theta)}{\sin(\theta)}\<br>&amp;= \frac{\sin((1 - t)\theta)}{\sin(\theta)}<br>\end{aligned}<br>$$</p><p>将 $\alpha$ 和 $\beta$ 代回(1)式，我们可以得到向量的Slerp公式<br>$$<br>\pmb{v_{t}} = Slerp(\pmb{v_{0}}, \pmb{v_{1}}, t) = \frac{\sin((1 - t)\theta)}{\sin(\theta)}\pmb{v_{0}} + \frac{\sin(t\theta)}{\sin(\theta)}\pmb{v_{1}}<br>$$<br>类似地，我们有四元数的 Slerp 公式：<br>$$<br>q_{t} = Slerp(q_{0}, q_{1}, t) = \frac{\sin((1 - t)\theta)}{\sin(\theta)}q_{0} + \frac{\sin(t\theta)}{\sin(\theta)}q_{1}<br>$$<br>其中 $q_{0}$ 与 $q_{1}$ 之间的夹角 $\theta$ 可以直接使用它们点乘的结果来得出，即<br>$$<br>\theta = \arccos(q_{0} \cdot q_{1})<br>$$</p><p>这里导出的公式会比之前利用幂运算的公式要高效很多，但是它仍然涉及到三个三角函数以及一个反三角函数的运算，所以还是会比 Nlerp 要慢一点。如果要插值的角度比较小的话，Nlerp 其实相对于 Slerp 的误差并没有那么大。为了提高效率，我们经常会使用 Nlerp 来代替 Slerp。我们也能用一些数值分析的方法来近似并优化四元数的 Slerp。</p><p>除了效率问题之外，我们在实现 Slerp 时要注意，如果单位四元数之间的夹角 $\theta$ 非常小，那么 $\sin(\theta)$ 可能会由于浮点数的误差被近似为 0.0，从而导致除以 0 的错误．所以，我们在实施 Slerp 之前，需要检查两个四元数的夹角是否过小（或者完全相同）。一旦发现这种问题，我们就必须改用 Nlerp 对两个四元数进行插值，这时候 Nlerp 的误差非常小所以基本不会与真正的 Slerp 有什么区别。</p><h3 id="双倍覆盖带来的问题">双倍覆盖带来的问题</h3><p>如果你还记得，两个不同的单位四元数 $q$ 与 $-q$ 对应的其实是同一个旋转，这个特性显然会对我们的插值造成一些影响．虽然 $q$ 与 $-q$ 对向量变换的最终效果是完全相同的，但是它们作为向量相差了 $\pi$ 弧度：</p><p><img src="/posts_image/Quaternion/Quaternion_16.png" alt=""></p><p>可以看到，虽然我们能够将 $q_{0}$ 向左插值至 $q_{1}$（蓝色的弧），但这会将 3D 空间中的向量旋转接近 360 度，而实际上这两个旋转相差并没有那么多，它并不是 3D 空间中的弧面最短路径。而如果我们将 $q_{0}$ 向右插值至等价的 $-q_{1}$（红色的弧），它的旋转变化量就会比插值到 $q_{1}$ 要小很多，所以 $q_{0}$ 插值到 $-q_{1}$ 才是插值的最短路径。</p><p>这也就告诉我们，在对两个单位四元数进行插值之前，我们需要先检测 $q_{0}$ 与 $q_{1}$ 之间是否是钝角，即检测它们点积的结果 $q_{0} \cdot q_{1}$ 是否为负数。如果 $q_{0} \cdot q_{1} &lt; 0$ ，那么我们就反转其中的一个四元数，比如说将 $q_{1}$ 改为 $-q_{1}$，并使用 $q_{0}$ 与 $-q_{1}$ 之间新的夹角来进行插值，这样才能保证插值的路径是最短的。</p><h2 id="Squad">Squad</h2><p>Slerp已经是我们理想中的插值方式了：它直接对角度插值，插值角度匀速变化，运算效率尚可。但是它还有一个小问题：角度变化的速率等于夹角，即 $\frac{d\theta_{t}}{dt} = \frac{d}{dt}(t\theta) = \theta$，这就意味着，当我们在多个角速度之间插值的时候，当在不同的四元数之间插值的时候，速率会发生突变，或者说在切断点处不可导。从数学上讲，函数 $f$ 连续并不意味着函数的一阶导连续（前者称为 $C^0$ 连续，后者称为 $C^1$ 连续）。</p><p>为此，我们希望能以<strong>牺牲固定角速度</strong>为条件，让插值的曲线能够在高阶导处也连续，下面介绍的Squad（Spherical and quadrangle）就是一种解决方法。</p><h3 id="Bezier-曲线">Bézier 曲线</h3><p>假设我们有一个向量的序列 $\pmb{v_{0}}$， $\pmb{v_{1}}$，$\dots$，$\pmb{v_{n}}$，如果我们想对这个序列进行插值，那么我们可以分别对每一对向量 $\pmb{v_{i}}$ 和 $\pmb{v_{i+1}}$ 进行插值，然后将插值的曲线连接起来，也就是我们所说的样条（Spline）．如果直接使用 Lerp 的话，我们会得到这样的结果（假设我们只有五个向量需要插值 $\pmb{v_{0}}$，$\pmb{v_{1}}$，$\pmb{v_{2}}$，$\pmb{v_{3}}$，$\pmb{v_{4}}$）：</p><p><img src="/posts_image/Quaternion/Quaternion_17.png" alt=""></p><p>很明显，这个曲线虽然是连续的，但是它的一阶导数（切线）在切换插值向量时都不是连续的。为了解决这个问题，我们最常使用的就是 Bézier 曲线。我们一开始的想法可能会是将中间的 $\pmb{v_{1}}$，$\pmb{v_{2}}$，$\pmb{v_{3}}$ 作为控制点，直接使用一个四次 Bézier 曲线（因为有五个点）来生成这个近似曲线。但是 Bézier 曲线只会经过初始点与最终点（插值），一般不会经过中间的控制点（近似），所以这样求出来的曲线虽然是可导的，但是插值曲线不会经过中间的三个向量：</p><p><img src="/posts_image/Quaternion/Quaternion_18.png" alt=""></p><p>为了解决这个问题，我们可以分段对每两个向量 $\pmb{v_{i}}$ 和 $\pmb{v_{i+1}}$ 之间使用 Bézier曲线进行插值，之后将所有的曲线（样条）连接起来．因为我们需要让曲线的一阶导数（或者说曲线的趋势）连续，我们还需要知道它们的前一个向量 $\pmb{v_{i-1}}$ 和后一个向量 $\pmb{v_{i+2}}$，并且用它们生成两个控制点 $\pmb{s_{i}}$ 和 $\pmb{s_{i+1}}$ 来控制曲线的趋势．我们会使用 $\pmb{v_{i}}$ 和 $\pmb{v_{i+1}}$ 作为端点（曲线会经过这两个点），$\pmb{s_{i}}$ 和 $\pmb{s_{i+1}}$ 作为中间的控制点，使用一个三次 Bézier 曲线（Cubic Bézier Curve，四个点）来近似这个两个向量之间的插值。</p><p>在我们的例子中，因为我们一共有四对向量（$\pmb{v_{0}}\pmb{v_{1}}$、$\pmb{v_{1}}\pmb{v_{2}}$、$\pmb{v_{2}}\pmb{v_{3}}$、$\pmb{v_{3}}\pmb{v_{4}}$），我们会使用四个三次 Bézier 曲线对这五个点进行插值．我们知道，对于三次Bézier 曲线所产生的样条，如果想让最终的插值曲线达到 $C^1$ 连续，则需要让前一个样条在 $\pmb{v_{i}}$ 的控制点与当前样条在 $\pmb{v_{i}}$ 的控制点分别处于最终曲线在 $\pmb{v_{i}}$ 处切线对等的两侧：</p><p><img src="/posts_image/Quaternion/Quaternion_19.png" alt=""></p><p>在上面的曲线中，蓝色的线就是曲线在点 $\pmb{v_{i}}$ 处的切线，红色的点就是三次 Bézier 曲线的控制点，分别处于切线对等的两侧．对于两个端点 $\pmb{v_{0}}$ 和 $\pmb{v_{4}}$，我们直接将这两个向量的控制点取为它们本身（这不是唯一的做法，但这样是可行的），最终得到一个平滑的曲线。我们希望将类似的逻辑带到四元数的超球面上，得到四元数序列的插值的方法，但在此之前我们需要了解如何构造一个三次 Bézier 曲线。</p><h3 id="de-Casteljau-算法">de Casteljau 算法</h3><p>Bézier 曲线的构造有个著名的递归算法叫做 de Casteljau 算法（de Casteljau’s Algorithm），它对任意次方的 Bézier 曲线都是成立的，但是这里我们只关注三次 Bézier 曲线的情况。</p><p>这个算法最基本的思想就是线性插值的嵌套。假设我们有四个向量 $\pmb{v_{0}}$，$\pmb{v_{1}}$，$\pmb{v_{2}}$，$\pmb{v_{3}}$，那么我们可以这样子获得最终的三次 Bézier 曲线：</p><p>首先，我们对每一对向量 $\pmb{v_{0}}\pmb{v_{1}}$、$\pmb{v_{1}}\pmb{v_{2}}$、$\pmb{v_{2}}\pmb{v_{3}}$ 进行线性插值，获得 $\pmb{v_{01}}$、$\pmb{v_{12}}$、$\pmb{v_{23}}$：</p><p>$$<br>\pmb{v_{01}} = Lerp(\pmb{v_{0}}, \pmb{v_{1}}; t)\<br>\pmb{v_{12}} = Lerp(\pmb{v_{1}}, \pmb{v_{2}}; t)\<br>\pmb{v_{23}} = Lerp(\pmb{v_{2}}, \pmb{v_{3}}; t)\<br>$$</p><p>之后，我们对 $\pmb{v_{01}}\pmb{v_{12}}$ 和 $\pmb{v_{12}}\pmb{v_{23}}$ 这两对向量进行线性插值，获得 $\pmb{v_{012}}$ 和 $\pmb{v_{123}}$</p><p>$$<br>\pmb{v_{012}} = Lerp(\pmb{v_{01}}, \pmb{v_{12}}; t)\<br>\pmb{v_{123}} = Lerp(\pmb{v_{12}}, \pmb{v_{23}}; t)\<br>$$</p><p>最后，对 $\pmb{v_{012}}$ 和 $\pmb{v_{123}}$ 进行线性插值获得 $\pmb{v_{0123}}$，这个向量就是我们想要的最终结果，它就是三次 Bézier 曲线上的点：</p><p>$$<br>\pmb{v_{0123}} = Lerp(\pmb{v_{012}}, \pmb{v_{123}}; t)\<br>$$</p><p>虽然这个算法看起来很繁琐，但是我们可以通过一张图来理解它（取 $t$ = 0.4）：</p><p><img src="/posts_image/Quaternion/Quaternion_20.png" alt=""></p><p>可以看到，虽然我们一直在使用线性插值，最终获得的却是一条三次 Bézier 曲线（黑色的线）。</p><p>如果将这些式子合并起来，我们就能得到三次 Bézier 曲线的递归公式。因为这个式子太长了，我将 $Lerp(\pmb{v_{i}}, \pmb{v_{i+1}}; t)$ 简写为 $L(\pmb{v_{i}}, \pmb{v_{i+1}}; t)$：<br>$$<br>Bézier(\pmb{v_{0}}, \pmb{v_{1}}, \pmb{v_{2}}, \pmb{v_{3}}; t) = L(L(L(\pmb{v_{0}}, \pmb{v_{1}}; t), L(\pmb{v_{1}}, \pmb{v_{2}}; t); t), L(L(\pmb{v_{1}}, \pmb{v_{2}}; t), L(\pmb{v_{2}}, \pmb{v_{3}}; t); t); t)<br>$$</p><p>如果将 Lerp 的定义 $Lerp(\pmb{v_{i}}, \pmb{v_{i+1}}; t) = (1 - t)\pmb{v_{i}} + t\pmb{v_{i+1}}$ 不断代入并展开的话，我们就能获得这样一个式子：<br>$$<br>Bézier(\pmb{v_{0}}, \pmb{v_{1}}, \pmb{v_{2}}, \pmb{v_{3}}; t) = (1 - t)^3\pmb{v_{0}} + 3(1 - t)^2t\pmb{v_{1}} + 3(1 - t)t^2\pmb{v_{2}} + t^3\pmb{v_{3}}<br>$$</p><p>因为每项的次数都是 3，所以我们说它是一个三次 Bézier 曲线。</p><p>我们可以直接将递归的公式运用到四元数上，得到四元数的球面 Bézier 曲线公式，但因为球面的线性插值不是 Lerp 而是 Slerp，我们需要将公式中所有的 Lerp 全部换成 Slerp（你可以想象一下，将四个向量形成的四边形看作是一个网格（Mesh），之后将这个网格贴在球面上）。同样因为公式太长，我会将 $Slerp(q_{i}, q_{i+1}; t)$ 简写为 $S(q_{i}, q_{i+1}; t)$：<br>$$<br>SBézier(q_{0}, q_{1}, q_{2}, q_{3}; t) = S(S(S(q_{0}, q_{1}; t), S(q_{1}, q_{2}; t);t),S(S(q_{1}, q_{2}; t), S(q_{2}, q_{3}; t); t); t)<br>$$<br>很明显这个方法实在是太复杂了。仅仅是一个 Slerp 就要使用四个三角函数，而我们这里一共有 7个 Slerp，如果真的要使用它进行插值会对性能产生非常大的影响。</p><h3 id="Squad-2">Squad</h3><p>三次 Bézier 曲线实际上是嵌套了三层一次（one-order）插值，而 Squad 则使用的是一层二次插值嵌套了一层一次插值。</p><p>我们首先是分别对 $\pmb{v_{0}}\pmb{v_{3}}$ 和 $\pmb{v_{1}}\pmb{v_{2}}$ 进行插值，得到 $\pmb{v_{03}}$ 和 $\pmb{v_{12}}$：<br>$$<br>\pmb{v_{03}} = Lerp(\pmb{v_{0}}, \pmb{v_{3}}; t)\<br>\pmb{v_{12}} = Lerp(\pmb{v_{1}}, \pmb{v_{2}}; t)\<br>$$<br>之后，我们使用 $2t(1 - t)$ 为参数，对 $\pmb{v_{03}}\pmb{v_{12}}$ 进行二次插值，得到最终的 $\pmb{v_{0312}}$ ：<br>$$<br>\pmb{v_{0312}} = Lerp(\pmb{v_{03}}, \pmb{v_{12}}; 2t(1 - t))\<br>$$</p><p>上述过程可以通过下图阐明（$t = 0.4$），黑色曲线就是生成的插值曲线：</p><p><img src="/posts_image/Quaternion/Quaternion_21.png" alt=""></p><p>当然，我们也可以把它写成递归形式：<br>$$<br>Squad(\pmb{v_{0}}, \pmb{v_{1}}, \pmb{v_{2}}, \pmb{v_{3}}; t) = Lerp(Lerp(\pmb{v_{0}}, \pmb{v_{3}}; t), Lerp(\pmb{v_{1}}, \pmb{v_{2}}; t); 2t(1 - t))<br>$$</p><p>可以看到，这样的插值要比三次 Bézier 曲线简单很多，将七次 Lerp 减少到了三次．虽然最终的曲线与三次 Bézier 曲线不完全相同，但是已经很近似了。我们可以看几个对比。下图中，左边是三次 Bézier 曲线，右边是 Squad 曲线：</p><p><img src="/posts_image/Quaternion/Quaternion_22.png" alt=""></p><p>如果利用 Lerp 的定义 $Lerp(\pmb{v_{i}}, \pmb{v_{i+1}}; t) = (1 - t)\pmb{v_{i}} + t\pmb{v_{i+1}}$ 将递归式展开的话，我们能得到这样的式子<br>$$<br>Squad(\pmb{v_{0}}, \pmb{v_{1}}, \pmb{v_{2}}, \pmb{v_{3}}; t) = (2t^2 - 2t + 1)(1 - t)\pmb{v_{0}} + 2(1 - t)^2t\pmb{v_{1}} + 2(1 - t)t^2\pmb{v_{2}} + t(2t^2 - 2t + 1)\pmb{v_{3}}<br>$$</p><p>它仍是一个三次曲线，只不过系数有所不同。</p><p>如果我们将这个递归公式用于球面，就能得到四元数的 Squad 公式。<br>$$<br>Squad(q_{0}, q_{1}, q_{2}, q_{3}; t) = Slerp(Slerp(q_{0}, q_{3}; t), Slerp(q_{1}, q_{2}; t); 2t(1 - t))<br>$$</p><p>我们知道 $Slerp(q_{i}, q_{i+1}; t) = (q_{i+1}q_{i}^<em>)^tq_{i}$，所以我们可以将 Squad 写成指数形式：<br>$$<br>Squad(q_{0}, q_{1}, q_{2}, q_{3}; t) = (Slerp(q_{1}, q_{2}; t)(Slerp(q_{0}, q_{3}; t))^</em>)^{2t(1-t)}Slerp(q_{0}, q_{3}; t)<br>$$</p><h3 id="Squad-应用">Squad 应用</h3><p>接下来，我们回到本章最初的主题，对多个单位四元数进行插值。如果我们有一个四元数序列 $q_{0}$，$q_{1}$，$\dots$，$q_{n}$，我们希望对每一对四元数 $q_{i}$ 和 $q_{i+1}$ 都使用 Squad 进行插值，所以我们有<br>$$<br>Squad(q_{i}, s_{i}, s_{i+1}, q_{i+1}; t) = Slerp(Slerp(q_{i}, q_{i+1}; t), Slerp(s_{i}, s_{i+1}; t); 2t(1 - t))<br>$$<br>现在，留下来的问题就是找出中间的控制点 $s_{i}$ 和 $s_{i+1}$ 了。类似于 Bézier 曲线的样条，我们同样需要前一个四元数 $q_{i-1}$ 以及 $q_{i+2}$ 的信息。</p><p>$s_{i}$ 的推导还是比较复杂的，但是它最基本的理念非常简单：让 Squad 在切换点可导，从而达到 $C^1$ 连续。也就是说，我们希望 $q_{i-1}q_{i}$ 插值时在 $t = 1$ 处的导数，与 $q_{i}q_{i+1}$ 插值时在 $t = 0$ 处的导数相等：<br>$$<br>Squad’(q_{i-1}, s_{i-1}, s_{i}, q_{i}; 1) = Squad’(q_{i}, s_{i}, s_{i+1}, q_{i+1}; 0)<br>$$</p><p>如果我们想要从这里继续推导下去的话，就需要用到单位四元数导数的定义（它和 $q = [\cos(\theta), \sin(\theta)\pmb{u}] = e^{u\theta}$ 有关）。最终得到<br>$$<br>s_{i} = q_{i}exp(-\frac{\log(q_{i}^*q_{i-1}) + \log(q_{i}^*q_{i+1})}{4})<br>$$<br>注意，和 Bézier 曲线的样条不同的是，这里的 $s_{i}$ 在对 $q_{i-1}q_{i}$ 插值时和对 $q_{i}q_{i+1}$ 插值时都是相同的，不像之前是处于切线的两端不同的两个向量。</p><p>与两个四元数之间的插值一样，Squad 同样会受到双重覆盖的影响。我们在计算中间控制点和插值之前，需要先选中一个四元数，比如说 $q_{i}$，检测它与其它三个四元数之间的夹角，如果是钝角就翻转，将插值的路线减到最小。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四元数和三维旋转(二)</title>
    <link href="/posts/%E5%9B%9B%E5%85%83%E6%95%B0%E5%92%8C%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC(%E4%BA%8C)/"/>
    <url>/posts/%E5%9B%9B%E5%85%83%E6%95%B0%E5%92%8C%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h2 id="四元数">四元数</h2><p>所有的四元数 $q \in \mathbb{H}$ 都可以写成下面这种形式：<br>$$<br>q = a + bi + cj + dk,(a,b,c,d \in \mathbb{R})<br>$$</p><p>其中<br>$$<br>i^2 = j^2 = k^2 = ijk = -1<br>$$</p><p>如果把上式称为四元数的<strong>代数形式</strong>，那么和复数类似，它也有对应的<strong>向量形式一</strong>：<br>$$<br>q = \begin{bmatrix}<br>a\ b\ c\ d\<br>\end{bmatrix}<br>$$</p><p>如果将四元数 $q$ 的实部和虚部分开，并用一个三维的向量来表示虚部，将它表示为标量和向量的有序对形式，那么四元数还可以表示为下述的<strong>向量形式二</strong>：<br>$$<br>q = [s, \pmb{v}], (\pmb{v} = \begin{bmatrix} x\ y\ z\ \end{bmatrix},\quad s,x,y,z \in \mathbb{R})<br>$$</p><h3 id="四元数的性质">四元数的性质</h3><h4 id="四元数的模长">四元数的模长</h4><p>仿照复数模长的定义，我们可以暂时将四元数 $q = a + bi + cj + dk$ 的模长定义为<br>$$<br>\lVert q \rVert = \sqrt{a^2 + b^2 + c^2 + d^2}<br>$$<br>如果用标量向量有序对的形式进行表示的话，$q = [s, \pmb{v}]$ 的模长为：<br>$$<br>\lVert q \rVert = \sqrt{s^2 + \lVert\pmb{v}\rVert^2} = \sqrt{s^2 + \pmb{v}\cdot\pmb{v}}<br>$$</p><h4 id="四元数的加减法">四元数的加减法</h4><p>与复数类似，四元数的加法只需要将分量相加就可以了，如果我们有两个四元数 $q_{1} = a + bi + cj + dk$，$q_{2} = e + fi + gj + hk$，那么它们的和为<br>$$<br>\begin{aligned}<br>q_{1} + q_{2} &amp;= a + bi + cj + dk + e + fi + gj + hk\<br>&amp;= (a + e) + (b + f)i + (c + g)j + (d + h)k<br>\end{aligned}<br>$$</p><p>减法同理，将加号改为减号就可以了<br>$$<br>q_{1} - q_{2} = (a - e) + (b - f)i + (c - g)j + (d - h)k<br>$$</p><p>如果四元数是以标量向量有序对形式定义的，比如说 $q_{1} = [s, \pmb{v}]$，$q_{2} = [t, \pmb{u}]$，那么<br>$$<br>q_{1} \pm q_{2} = [s \pm t, \pmb{v}\pm\pmb{u}]<br>$$</p><h4 id="四元数的标量乘法">四元数的标量乘法</h4><p>如果我们有一个四元数 $q = a + bi + cj + dk$ 和一个标量 $s$，那么它们的乘积为：<br>$$<br>\begin{aligned}<br>sq &amp;= s(a + bi + cj + dk)\<br>&amp;= sa + sbi + scj + sdk<br>\end{aligned}<br>$$</p><p>四元数与标量的乘法遵守交换律，也就是说 $sq = qs$</p><h4 id="四元数乘法">四元数乘法</h4><p>四元数之间的乘法不遵守交换律，也就是说一般情况下 $q_{1}q_{2} \neq q_{2}q_{1}$。这也就有了左乘和右乘的区别，如果是 $q_{1}q_{2}$，我们就说&quot;$q_{2}$ 左乘以 $q_{1}$“，如果是 $q_{2}q_{1}$，那我们就说”$q_{2}$ 右乘以 $q_{1}$&quot;。除了交换律之外，结合律和分配律在四元数内都是成立的。</p><p>如果有两个四元数 $q_{1} = a + bi + cj + dk$ 和 $q_{2} = e + fi + gj + hk$，那么<br>$$<br>\begin{aligned}<br>q_{1}q_{2} &amp;= (a + bi + cj + dk)(e + fi + gj + hk)\<br>&amp;= ae + afi + agj + ahk +\<br>&amp;\quad bei + bfi^2 + bgij + bhik +\<br>&amp;\quad cej + cfji + cgj^2 + chjk +\<br>&amp;\quad dek + dfki + dgkj + dhk^2<br>\end{aligned}<br>$$</p><p>由 $i^2 = j^2 = k^2 = ijk = -1$ 我们可以推导出 $jk = i$，$ij = k$，$ki = j$，$kj = -i$，$ji = -k$，$ik = -j$，于是我们可以得到：</p><p><img src="/posts_image/Quaternion/Quaternion_7.png" alt=""></p><p>容易观察到交换律并不成立。利用上面的表格，我们可以对四元数之间的乘法进行归纳化简：<br>$$<br>\begin{aligned}<br>q_{1}q_{2}<br>&amp;= ae + afi + agj + ahk +\<br>&amp;\quad bei + bfi^2 + bgij + bhik +\<br>&amp;\quad cej + cfji + cgj^2 + chjk +\<br>&amp;\quad dek + dfki + dgkj + dhk^2\<br>&amp;= (a\textcolor{red}{e} - b\textcolor{blue}{f} - c\textcolor{green}{g} - d\textcolor{orange}{h})+\<br>&amp;\quad (b\textcolor{red}{e} + a\textcolor{blue}{f} - d\textcolor{green}{g} + c\textcolor{orange}{h})i+\<br>&amp;\quad (c\textcolor{red}{e} + d\textcolor{blue}{f} + a\textcolor{green}{g} - b\textcolor{orange}{h})j+\<br>&amp;\quad (d\textcolor{red}{e} - c\textcolor{blue}{f} + b\textcolor{green}{g} + a\textcolor{orange}{h})k\<br>\end{aligned}<br>$$</p><h4 id="矩阵形式">矩阵形式</h4><p>可以看到，四元数的相乘其实也是一个线性组合，我们同样可以将它写成矩阵的形式：<br>$$<br>q_{1}q_{2} =<br>\begin{bmatrix}<br>a&amp;-b&amp;-c&amp;-d\<br>b&amp;a&amp;-d&amp;c\<br>c&amp;d&amp;a&amp;-b\<br>d&amp;-c&amp;b&amp;a\<br>\end{bmatrix}<br>\begin{bmatrix}<br>\textcolor{red}{e}\<br>\textcolor{blue}{f}\<br>\textcolor{green}{g}\<br>\textcolor{orange}{h}\<br>\end{bmatrix}<br>$$</p><p>注意，这个矩阵所作出的变换等价于<strong>左乘 $q_{1}$</strong>。因为四元数不符合乘法交换律，所以<strong>右乘 $q_{1}$<strong>的变换是一个不同的矩阵，它可以使用完全相同的方法推导而得，下面这个矩阵所作出的变换等价于</strong>右乘 $q_{1}$</strong></p><p>$$<br>q_{2}q_{1} =<br>\begin{bmatrix}<br>a&amp;-b&amp;-c&amp;-d\<br>b&amp;a&amp;d&amp;-c\<br>c&amp;-d&amp;a&amp;b\<br>d&amp;c&amp;-b&amp;a\<br>\end{bmatrix}<br>\begin{bmatrix}<br>\textcolor{red}{e}\<br>\textcolor{blue}{f}\<br>\textcolor{green}{g}\<br>\textcolor{orange}{h}\<br>\end{bmatrix}<br>$$</p><h4 id="Grasmann积">Graßmann积</h4><p>重新整理之前的乘法结果：</p><p>$$<br>\begin{aligned}<br>q_{1}q_{2} &amp;= (ae -(bf + cg + dh))+\<br>&amp;\quad(b\textcolor{red}{e} + \textcolor{blue}{a}f + ch - dg)i+\<br>&amp;\quad(c\textcolor{red}{e} + \textcolor{blue}{a}g + df - bh)j+\<br>&amp;\quad(d\textcolor{red}{e} + \textcolor{blue}{a}h + bg - cf)k\<br>\end{aligned}<br>$$</p><p>如果令 $\pmb{v} = \begin{bmatrix}b\ c\ d\ \end{bmatrix}$，$\pmb{u} = \begin{bmatrix}f\ g\ h\ \end{bmatrix}$，那么</p><p>$$<br>\pmb{v}\cdot\pmb{u} = bf + cg + dh<br>$$<br>$$<br>\begin{aligned}<br>\pmb{v}\times\pmb{u} &amp;=<br>\begin{vmatrix}<br>\pmb{i}&amp;\pmb{j}&amp;\pmb{k}\<br>b&amp;c&amp;d\<br>f&amp;g&amp;h\<br>\end{vmatrix}\<br>&amp;= (ch - dg)\pmb{i} - (bh - df)\pmb{j} + (bg - cf)\pmb{k}<br>\end{aligned}<br>$$</p><p>注意 $\pmb{v}\times\pmb{u}$ 的结果是一个向量，这里的 $\pmb{i}、\pmb{j}、\pmb{k}$ 是向量的基，如果使用标量向量有序对形式来表示，$q_{1}q_{2}$ 的结果可以用向量点乘和叉乘的形式表示出来</p><p>$$<br>q_{1}q_{2} = [ae - \pmb{v}\cdot\pmb{u}, a\pmb{u} + e\pmb{v} + \pmb{v}\times\pmb{u}]<br>$$</p><p>这个结果也被叫做 <strong>Graßmann积</strong>，一般来说：</p><div class="note note-primary">            <p><strong>Theorem 7：Graßmann积</strong><br>对任意四元数 $q_{1} = [s, \pmb{v}]$，$q_{2} = [t, \pmb{u}]$，$q_{1}q_{2}$ 的结果是<br>$$<br>q_{1}q_{2} = [st - \pmb{v}\cdot\pmb{u}, s\pmb{u} + t\pmb{v} + \pmb{v}\times\pmb{u}]<br>$$</p>          </div><h4 id="纯四元数">纯四元数</h4><p>实部为零，仅有虚部的四元数为<strong>纯四元数</strong>，即：<br>$$<br>q = [0, \pmb{v}]<br>$$</p><p>对于两个纯四元数 $q_{1} = [0, \pmb{v}]$，$q_{2} = [0, \pmb{u}]$，那么它们的乘积为：<br>$$<br>q_{1}q_{2} = [-\pmb{v}\cdot\pmb{u}, \pmb{v}\times\pmb{u}]<br>$$</p><h4 id="共轭">共轭</h4><p>四元数 $q = a + bi + cj + dk$ 的<strong>共轭</strong>为 $q^* = a - bi - cj - dk$。如果用标量向量有序对的形式来定义的话，$q = [s, \pmb{v}]$ 的共轭为 $q^* = [s, -\pmb{v}]$。共轭四元数的一个非常有用的性质就是<br>$$<br>\begin{aligned}<br>qq^* &amp;= [s, \pmb{v}]\cdot[s, -\pmb{v}]\<br>&amp;= [s^2 - \pmb{v}\cdot(-\pmb{v}), s(-\pmb{v}) + s\pmb{v} + \pmb{v}\times(-\pmb{v})]\<br>&amp;= [s^2 + \pmb{v}\cdot\pmb{v}, 0]\<br>&amp;= s^2 + x^2 + y^2 + z^2\<br>&amp;= \lVert q \rVert^2<br>\end{aligned}<br>$$<br>结果是一个标量，正是四元数模长的平方。<br>$$<br>q^<em>q = (q^</em>)(q^<em>)^</em> = \lVert q^* \rVert^2 = \lVert q \rVert^2<br>$$<br>我们得到，$q^<em>q = qq^</em>$，这个特殊的乘法遵守交换律。</p><h4 id="逆">逆</h4><p>因为四元数乘法不遵守交换律，我们不会将两个四元数相除写为 $\frac{p}{q}$ 的形式，取而代之的是将乘法的逆运算定义为 $pq^{-1}$ 或者 $q^{-1}p$，注意它们的结果一般是不同的。</p><p>其中，$q^{-1}$ 是 $q$ 的<strong>逆</strong>，我们规定<br>$$<br>qq^{-1} = q^{-1}q = 1\quad(q \neq 0)<br>$$</p><p>右乘 $q$ 的逆运算为右乘 $q^{-1}$，左乘 $q$ 的逆运算为左乘 $q^{-1}$。</p><p>利用共轭，我们可以进行如下推导：<br>$$<br>\begin{aligned}<br>qq^{-1} &amp;= 1\<br>q^<em>qq^{-1} &amp;= q^</em>\<br>\lVert q \rVert^2q^{-1} &amp;= q^<em>\<br>q^{-1} &amp;= \frac{q^</em>}{\lVert q \rVert^2}\<br>\end{aligned}<br>$$</p><p>四元数的逆就是它的共轭除以它模长的平方。如果 $\lVert q \rVert = 1$，那么它的逆就是它的共轭，此时称 $q$ 为一个<strong>单位四元数</strong>。</p><h3 id="四元数与3D旋转">四元数与3D旋转</h3><p>如果我们需要将一个向量 $\pmb{v}$ 沿着一个用单位向量所定义的旋转轴 $\pmb{u}$ 旋转 $\theta$ 度，那么我们可以将这个向量 $\pmb{v}$ 拆分为正交于旋转轴的 $\pmb{v_{\perp}}$ 以及平行于旋转轴的 $\pmb{v_{\parallel}}$。我们可以对这两个分向量分别进行旋转，获得 $\pmb{v_{\perp}‘}$ 和 $\pmb{v_{\parallel}’}$。将它们相加就是 $\pmb{v}$ 旋转之后的结果 $\pmb{v’} = \pmb{v_{\perp}‘} + \pmb{v_{\parallel}’}$。</p><p>我们可以将这些向量定义为纯四元数：</p><p>$$<br>\begin{aligned}<br>v &amp;= [0, \pmb{v}]\<br>v_{\perp} &amp;= [0, \pmb{v_{\perp}}]\<br>v_{\parallel} &amp;= [0, \pmb{v_{\parallel}}]\<br>v’ &amp;= [0, \pmb{v’}]\<br>v_{\perp}’ &amp;= [0, \pmb{v_{\perp}‘}]\<br>v_{\parallel}’ &amp;= [0, \pmb{v_{\parallel}'}]\<br>u &amp;= [0, \pmb{u}]<br>\end{aligned}<br>$$</p><p>那么我们就能得到</p><p>$$<br>v = v_{\parallel} + v_{\perp} \qquad v’ = v_{\parallel}’ + v_{\perp}’<br>$$</p><p>和之前一样，我们这里也分开讨论 $v_{\perp}$ 和 $v_{\parallel}$ 的情况。</p><h4 id="v-perp-的旋转">$v_{\perp}$ 的旋转</h4><p>我们在上一篇推导过，如果一个向量 $\pmb{v_{\perp}}$ 正交于旋转轴 $\pmb{u}$，那么</p><p>$$<br>\pmb{v_{\perp}'} = \cos(\theta)\pmb{v_{\perp}} + \sin(\theta)(\pmb{u}\times\pmb{v_{\perp}})<br>$$</p><p>而且，对于两个纯四元数 $q_{1} = [0, \pmb{v}]$，$q_{2} = [0, \pmb{u}]$，那么它们的乘积为 $q_{1}q_{2} = [-\pmb{v}\cdot\pmb{u}, \pmb{v}\times\pmb{u}]$，类似地，<br>$$<br>uv_{\perp} = [-\pmb{u}\cdot\pmb{v_{\perp}}, \pmb{u}\times\pmb{v_{\perp}}]<br>$$<br>因为 $\pmb{v_{\perp}}$ 正交于 $\pmb{u}$，所以 $\pmb{u}\cdot\pmb{v_{\perp}} = 0$，也就是说，<br>$$<br>\begin{aligned}<br>uv_{\perp} &amp;= [0, \pmb{u}\times\pmb{v_{\perp}}]\<br>&amp;= \pmb{u}\times\pmb{v_{\perp}}<br>\end{aligned}<br>$$<br>将这个等式以及之前定义的纯四元数代入，而且四元数乘法遵守分配律，我们可以获得：<br>$$<br>\begin{aligned}<br>v_{\perp}’ &amp;= \cos(\theta)v_{\perp} + \sin(\theta)(uv_{\perp})\<br>&amp;= (\cos(\theta) + \sin(\theta)u)v_{\perp}<br>\end{aligned}<br>$$</p><p>可以注意到，如果我们将 $(\cos(\theta) + \sin(\theta)u)$ 看作是一个四元数，我们就能将旋转写成四元数的乘积了。到此为止，我们已经将旋转与四元数的积联系起来了。如果令 $q = \cos(\theta) + \sin(\theta)u$，我们能得到<br>$$<br>v_{\perp}’ = qv_{\perp}<br>$$</p><p>我们可以对 $q$ 继续进行变形：<br>$$<br>\begin{aligned}<br>q &amp;= \cos(\theta) + \sin(\theta)u\<br>&amp;= [\cos(\theta), \pmb{0}] + [0, \sin(\theta)\pmb{u}]\<br>&amp;= [\cos(\theta), \sin(\theta)\pmb{u}]\<br>\end{aligned}<br>$$</p><p>也就是说，如果旋转轴 $\pmb{u}$ 的坐标为 $\begin{bmatrix}u_{x}\ u_{y}\ u_{z}\end{bmatrix}$，旋转角为 $\theta$，那么完成这一旋转所需的四元数 $q$ 可以构造为<br>$$<br>q = \cos(\theta) + \sin(\theta)u_{x}i + \sin(\theta)u_{y}j + \sin(\theta)u_{z}k<br>$$<br>这样我们就完成了对 $v_{\perp}$ 的旋转，我们可以得到下面这个定理：</p><div class="note note-primary">            <p><strong>Theorem 8：3D 旋转公式（四元数型，正交情况）</strong><br>当 $\pmb{v_{\perp}}$ 正交于旋转轴 $\pmb{u}$ 时，旋转 $\theta$ 角度之后的 $\pmb{v_{\perp}‘}$ 可以使用四元数乘法来获得，令 $v_{\perp} = [0, \pmb{v_{\perp}}]$，$q = [\cos(\theta), \sin(\theta)\pmb{u}]$，那么：<br>$$<br>v_{\perp}’ = qv_{\perp}<br>$$</p>          </div><p>这个四元数 $q$ 的模长为 1，它是一个单位四元数，它所代表的变换不会对原向量进行缩放，是一个纯旋转。<br>$$<br>\begin{aligned}<br>\lVert q \rVert &amp;= \sqrt{\cos^2(\theta) + (\sin(\theta)\pmb{u}\cdot\sin(\theta)\pmb{u})}\<br>&amp;= \sqrt{\cos^2(\theta) + \sin^2(\theta)(\pmb{u}\cdot\pmb{u})}\<br>&amp;= \sqrt{\cos^2(\theta) + \sin^2(\theta)(\lVert\pmb{u}\rVert^2)}\<br>&amp;= \sqrt{\cos^2(\theta) + \sin^2(\theta)}\<br>&amp;= 1<br>\end{aligned}<br>$$</p><h4 id="v-parallel-的旋转">$v_{\parallel}$ 的旋转</h4><p>接下来是平行于旋转轴的 $v_{\parallel}$，由于它平行于旋转轴，所以旋转不会对它作出任何的变换，也就是说：</p><div class="note note-primary">            <p><strong>Theorem 9：3D 旋转公式（四元数型，平行情况）</strong><br>当 $\pmb{v_{\parallel}}$ 平行于旋转轴 $\pmb{u}$ 时，旋转 $\theta$ 角度之后的 $\pmb{v_{\parallel}‘}$ 可以用四元数写为：<br>$$<br>v_{\parallel}’ = v_{\parallel}<br>$$</p>          </div><h4 id="v-的旋转">$v$ 的旋转</h4><p>$$<br>\begin{aligned}<br>v’ &amp;= v_{\parallel}’ + v_{\perp}'\<br>&amp;= v_{\parallel} + qv_{\perp} \qquad (其中 q = [\cos(\theta), \sin(\theta)\pmb{u}])<br>\end{aligned}<br>$$</p><p>在进一步化简前，我们需要证明几个引理：</p><div class="note note-secondary">            <p><strong>Lemma 1</strong><br>如果 $q = [\cos(\theta), \sin(\theta)\pmb{u}]$，而且 $\pmb{u}$ 为单位向量，那么 $q^2 = qq = [\cos(2\theta), \sin(2\theta)\pmb{u}]$</p>          </div><p>$Proof$.</p><p>$$<br>\begin{aligned}<br>q^2 &amp;= [\cos(\theta), \sin(\theta)\pmb{u}] \cdot [\cos(\theta), \sin(\theta)\pmb{u}]\<br>&amp;= [\cos^2(\theta) - (\sin(\theta)\pmb{u}\cdot\sin(\theta)\pmb{u}), (\cos(\theta)\sin(\theta) + \sin(\theta)\cos(\theta))\pmb{u} + (\sin(\theta)\pmb{u}\times\sin(\theta)\pmb{u})]\<br>&amp;= [\cos^2(\theta) - \sin^2(\theta)\lVert\pmb{u}\rVert^2, 2\sin(\theta)\cos(\theta)\pmb{u} + \pmb{0}]\<br>&amp;= [\cos^2(\theta) - \sin^2(\theta), 2\sin(\theta)\cos(\theta)\pmb{u}]\<br>&amp;= [\cos(2\theta), \sin(2\theta)\pmb{u}]<br>\end{aligned}<br>$$</p><p>这个引理的几何意义是，如果沿着同一个轴 $\pmb{u}$ 连续旋转 $\theta$ 度两次，那么所作出的变换等同于直接沿着 $\pmb{u}$ 旋转 $2\theta$ 度</p><p>那么，我们就能够对原本的旋转公式进行变形了</p><p>$$<br>\begin{aligned}<br>v’ &amp;= v_{\parallel} + qv_{\perp} \qquad\qquad (q = [\cos(\theta), \sin(\theta)\pmb{u}])\<br>&amp;= 1 \cdot v_{\parallel} + qv_{\perp}\<br>&amp;= pp^{-1}v_{\parallel} + ppv_{\perp} \quad (令 q = p^2，则 p = [\cos(\frac{1}{2}\theta), \sin(\frac{1}{2}\theta)\pmb{u}])<br>\end{aligned}<br>$$</p><p>在这里，我们引入了一个新的四元数 $p = [\cos(\frac{1}{2}\theta), \sin(\frac{1}{2}\theta)\pmb{u}]$。根据刚刚证明的引理，我们可以验证<br>$$<br>\begin{aligned}<br>pp &amp;= p^2\<br>&amp;= [\cos(2\cdot\frac{1}{2}\theta), \sin(2\cdot\frac{1}{2}\theta)\pmb{u}]\<br>&amp;= [\cos(\theta), \sin(\theta)\pmb{u}] = q<br>\end{aligned}<br>$$</p><p>和 $q$ 一样，$\lVert p \rVert = 1$，$p$ 也是一个单位四元数，也就是说<br>$$<br>p^{-1} = p^*<br>$$</p><p>将这个结果代入之前的等式中<br>$$<br>\begin{aligned}<br>v’ &amp;= pp^{-1}v_{\parallel} + ppv_{\perp}\<br>&amp;= pp^*v_{\parallel} + ppv_{\perp}<br>\end{aligned}<br>$$</p><p>我们还需再证明两个引理：</p><div class="note note-secondary">            <p><strong>Lemma 2</strong><br>假设 $v_{\parallel} = [0, \pmb{v_{\parallel}}]$ 是一个纯四元数，而 $q = [\alpha, \beta\pmb{u}]$，其中 $\pmb{u}$ 是一个单位向量，$\alpha，\beta \in \mathbb{R}$，在这种条件下，如果 $\pmb{v_{\parallel}}$ 平行于 $\pmb{u}$，那么 $qv_{\parallel} = v_{\parallel}q$</p>          </div><p>$Proof$.</p><p>$$<br>\begin{aligned}<br>LHS &amp;= qv_{\parallel}\<br>&amp;= [\alpha, \beta\pmb{u}]\cdot[0, \pmb{v_{\parallel}}]\<br>&amp;= [0 - \beta\pmb{u}\cdot\pmb{v_{\parallel}}, \alpha\pmb{v_{\parallel}} + \pmb{0} + \beta\pmb{u}\times\pmb{v_{\parallel}}]\<br>&amp;= [-\beta\pmb{u}\cdot\pmb{v_{\parallel}}, \alpha\pmb{v_{\parallel}}] \qquad (\pmb{v_{\parallel}} 平行于 \pmb{u}，所以 \beta\pmb{u}\times\pmb{v_{\parallel}} = \pmb{0})<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>RHS &amp;= v_{\parallel}q\<br>&amp;= [0, \pmb{v_{\parallel}}]\cdot[\alpha, \beta\pmb{u}]\<br>&amp;= [0 - \pmb{v_{\parallel}}\cdot\beta\pmb{u}, \pmb{0} + \alpha\pmb{v_{\parallel}} + \pmb{v_{\parallel}}\times\beta\pmb{u}]\<br>&amp;= [-\pmb{v_{\parallel}}\cdot\beta\pmb{u}, \alpha\pmb{v_{\parallel}}] \qquad ({v_{\parallel}} 平行于 \pmb{u}，所以 \pmb{v_{\parallel}}\times\beta\pmb{u} = \pmb{0})\<br>&amp;= [-\beta\pmb{u}\cdot\pmb{v_{\parallel}}, \alpha\pmb{v_{\parallel}}] = LHS \qquad (点乘遵守交换律)<br>\end{aligned}<br>$$</p><div class="note note-secondary">            <p><strong>Lemma 3</strong><br>假设 $v_{\perp} = [0, \pmb{v_{\perp}}]$ 是一个纯四元数，而 $q = [\alpha, \beta\pmb{u}]$，其中 $\pmb{u}$ 是一个单位向量，$\alpha，\beta \in \mathbb{R}$，在这种条件下，如果 $\pmb{v_{\perp}}$ 正交于 $\pmb{u}$，那么 $qv_{\perp} = v_{\perp}q^*$</p>          </div><p>$Proof$.</p><p>$$<br>\begin{aligned}<br>LHS &amp;= qv_{\perp}\<br>&amp;= [\alpha, \beta\pmb{u}]\cdot[0, \pmb{v_{\perp}}]\<br>&amp;= [0 - \beta\pmb{u}\cdot\pmb{v_{\perp}}, \alpha\pmb{v_{\perp}} + \pmb{0} + \beta\pmb{u}\times\pmb{v_{\perp}}]\<br>&amp;= [0, \alpha\pmb{v_{\perp}} + \beta\pmb{u}\times\pmb{v_{\perp}}] \qquad (\pmb{v_{\perp}} 正交于 \pmb{u}，所以 \beta\pmb{u}\cdot\pmb{v_{\perp}} = 0)<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>RHS &amp;= v_{\perp}q^*\<br>&amp;= [0, \pmb{v_{\perp}}]\cdot[\alpha, -\beta\pmb{u}]\<br>&amp;= [0 + \pmb{v_{\perp}}\cdot\beta\pmb{u}, \pmb{0} + \alpha\pmb{v_{\perp}} + \pmb{v_{\perp}}\times(-\beta\pmb{u})]\<br>&amp;= [0, \alpha\pmb{v_{\perp}} + \pmb{v_{\perp}}\times(-\beta\pmb{u})] \qquad ({v_{\perp}} 正交于 \pmb{u}，所以 \pmb{v_{\perp}}\cdot\beta\pmb{u} = 0)\<br>&amp;= [0, \alpha\pmb{v_{\perp}} - (-\beta\pmb{u})\times\pmb{v_{\perp}}] \qquad (\pmb{a}\times\pmb{b} = -\pmb{b}\times\pmb{a})\<br>&amp;= [0, \alpha\pmb{v_{\perp}} + \beta\pmb{u}\times\pmb{v_{\perp}}] = LHS<br>\end{aligned}<br>$$</p><p>现在，我们能对之前的公式做出最后的变形了：<br>$$<br>\begin{aligned}<br>v’ &amp;= pp^<em>v_{\parallel} + ppv_{\perp}\<br>&amp;= pv_{\parallel}p^</em> + pv_{\perp}p^<em>\<br>&amp;= p(v_{\parallel} + v_{\perp})p^</em>\<br>&amp;= pvp^*<br>\end{aligned}<br>$$</p><p>我们可以将上述推导总结为一个定理：</p><div class="note note-primary">            <p><strong>Theorem 10：3D 旋转公式（四元数型，一般情况）</strong><br>任意向量 $\pmb{v}$ 沿着以单位向量定义的旋转轴 $\pmb{u}$ 旋转 $\theta$ 度之后的 $\pmb{v’}$ 可以使用四元数乘法来获得。令 $v = [0, \pmb{v}]$，$q = [\cos(\frac{1}{2}\theta), \sin(\frac{1}{2}\theta)\pmb{u}]$，那么：<br>$$<br>v’ = qvq^* = qvq^{-1}<br>$$</p>          </div><p>如果我们有 $q = [\cos(\theta), \sin(\theta)\pmb{u}]$，那么 $v’ = qvq^*$ 可以将 $\pmb{v}$ 沿着 $\pmb{u}$ 旋转 $2\theta$ 度。</p><p>虽然这个公式非常简洁，但是不够直观，想了解它的真正含义的话，还需将它还原到变形之前的式子：<br>$$<br>v’ = qvq^* = qq^*v_{\parallel} + qqv_{\perp} = v_{\parallel} + q^2v_{\perp}<br>$$</p><p>也就是说，$qvq^<em>$ 这个变换，对 $v$ 平行于旋转轴的分量 $v_{\parallel}$ 实施的变换是 $qq^</em>$，这两个变换完全抵消了，也就是没有旋转，而对于正交于旋转轴的分量 $v_{\perp}$ 则实施的是两次变换 $q^2 = qq$，将它旋转 $\frac{\theta}{2} + \frac{\theta}{2} = \theta$ 度。</p><p>实际上，这个公式和上一篇推导的向量型旋转公式完全等价，证明可能会用到 $\pmb{a}\times(\pmb{b}\times\pmb{c}) = (\pmb{a}\cdot\pmb{c})\pmb{b} - (\pmb{a}\cdot\pmb{b})\pmb{c}$ 这个公式<br>$$<br>qvq^* = [0, \cos(\theta)\pmb{v} + (1 - \cos(\theta))(\pmb{u}\cdot\pmb{v})\pmb{u} + \sin(\theta)(\pmb{u}\times\pmb{v})]<br>$$</p><p>因为所有的旋转四元数的实部都只是一个角度的余弦值，假设有一个单位四元数 $q = [a, \pmb{b}]$，那么我们可以直接得到<br>$$<br>\frac{\theta}{2} = \arccos(a) \qquad \pmb{u} = \frac{\pmb{b}}{\sin(\arccos(a))}<br>$$</p><h3 id="3D旋转的矩阵形式">3D旋转的矩阵形式</h3><p>左乘一个四元数 $q = a + bi + cj + dk$ 等同于下面这个矩阵<br>$$<br>L(q) = \begin{bmatrix}<br>a&amp;-b&amp;-c&amp;-d\<br>b&amp;a&amp;-d&amp;c\<br>c&amp;d&amp;a&amp;-b\<br>d&amp;-c&amp;b&amp;a\<br>\end{bmatrix}<br>$$<br>而右乘 $q$ 等同于这个矩阵<br>$$<br>R(q) = \begin{bmatrix}<br>a&amp;-b&amp;-c&amp;-d\<br>b&amp;a&amp;d&amp;-c\<br>c&amp;-d&amp;a&amp;b\<br>d&amp;c&amp;-b&amp;a\<br>\end{bmatrix}<br>$$</p><p>所以，我们可以利用这两个公式将 $v’ = qvq^<em>$ 写成矩阵形式。假设 $a = \cos(\frac{\theta}{2})，b = \sin(\frac{\theta}{2})u_{x}，c = \sin(\frac{\theta}{2})u_{y}，d = \sin(\frac{\theta}{2})u_{z}，q = a + bi + cj + dk$，我们就能得到：<br>$$<br>\begin{aligned}<br>qvq^</em> &amp;= L(q)R(q^<em>)v \qquad (或者 R(q^</em>)L(q)v，它们是等价的)\<br>&amp;= \begin{bmatrix}<br>a&amp;-b&amp;-c&amp;-d\<br>b&amp;a&amp;-d&amp;c\<br>c&amp;d&amp;a&amp;-b\<br>d&amp;-c&amp;b&amp;a\<br>\end{bmatrix}<br>\begin{bmatrix}<br>a&amp;b&amp;c&amp;d\<br>-b&amp;a&amp;-d&amp;c\<br>-c&amp;d&amp;a&amp;-b\<br>-d&amp;-c&amp;b&amp;a\<br>\end{bmatrix}v \qquad (注意 R(q^<em>) = R(q)^T)\<br>&amp;= \begin{bmatrix}<br>a^2 + b^2 + c^2 + d^2&amp;ab - ab - cd + cd&amp;ac + bd - ac - bd&amp;ad - bc + bc - ad\<br>ab - ab + cd - cd&amp;b^2 + a^2 - d^2 - c^2&amp;bc - ad - ad + bc&amp;bd + ac + bd + ac\<br>ac - bd - ac + bd&amp;bc + ad + ad + bc&amp;c^2 - d^2 + a^2 - b^2&amp;cd + cd - ab - ab\<br>ad + bc - bc - ad&amp;bd - ac + bd - ac&amp;cd + cd + ab + ab&amp;d^2 - c^2 - b^2 + a^2\<br>\end{bmatrix}v<br>\end{aligned}<br>$$<br>因为 $a^2 + b^2 + c^2 + d^2 = 1$，这个式子能化简为<br>$$<br>qvq^</em> =<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;0\<br>0&amp;1 - 2c^2 - 2d^2&amp;2bc - 2ad&amp;2ac + 2bd\<br>0&amp;2bc + 2ad&amp;1 - 2b^2 - 2d^2&amp;2cd - 2ab\<br>0&amp;2bd - 2ac&amp;2ab + 2cd&amp;1 - 2b^2 - 2c^2\<br>\end{bmatrix}v<br>$$</p><p>这样我们就得到了 3D 旋转的矩阵形式。因为矩阵的第一行和第一列不会对 $v$ 进行任何变换，我们可以将它压缩成 3 $\times$ 3 矩阵（用作 3D 向量的变换）：</p><div class="note note-primary">            <p><strong>Theorem 11：3D 旋转公式（矩阵型）</strong><br>任意向量 $\pmb{v}$ 沿着以单位向量定义的旋转轴 $\pmb{u}$ 旋转 $\theta$ 度之后的 $\pmb{v’}$ 可以使用矩阵乘法来获得。令 $a = \cos(\frac{\theta}{2})，b = \sin(\frac{\theta}{2})u_{x}，c = \sin(\frac{\theta}{2})u_{y}，d = \sin(\frac{\theta}{2})u_{z}$，那么：<br>$$<br>v’ =<br>\begin{bmatrix}<br>1 - 2c^2 - 2d^2&amp;2bc - 2ad&amp;2ac + 2bd\<br>2bc + 2ad&amp;1 - 2b^2 - 2d^2&amp;2cd - 2ab\<br>2bd - 2ac&amp;2ab + 2cd&amp;1 - 2b^2 - 2c^2\<br>\end{bmatrix}v<br>$$</p>          </div><p>虽然 3D 旋转的矩阵形式可能不如四元数形式简单，而且占用更多的空间，但是对于大批量的变换，使用<strong>预计算</strong>好的矩阵是比四元数乘法更有效率的。</p><h3 id="旋转的复合">旋转的复合</h3><p>假设有两个表示沿着不同轴，不同角度旋转的四元数 $q_{1}$，$q_{2}$，我们先对 $v$ 进行 $q_{1}$ 的变换，再进行 $q_{2}$ 的变换。</p><p>首先，我们实施 $q_{1}$ 的变换，变换后的 $v’$ 为<br>$$<br>v’ = q_{1}vq_{1}^*<br>$$<br>接下来，对 $v’$ 进行 $q_{2}$ 的变换，得到 $v’‘$<br>$$<br>\begin{aligned}<br>v’’ &amp;= q_{2}v’q_{2}^<em>\<br>&amp;= q_{2}q_{1}vq_{1}^<em>q_{2}^</em><br>\end{aligned}<br>$$<br>我们需要对这两个变换进行复合，写为一个等价变换的形式：<br>$$<br>v’’ = q_{net}vq_{net}^</em><br>$$</p><p>为了写成上面这种形式，我们还需要一个引理：</p><div class="note note-secondary">            <p><strong>Lemma 4</strong><br>对任意四元数 $q_{1} = [s, \pmb{v}]、q_{2} = [t, \pmb{u}]$<br>$$<br>q_{1}^<em>q_{2}^</em> = (q_{2}q_{1})^*<br>$$</p>          </div><p>$Proof$.</p><p>$$<br>\begin{aligned}<br>LHS &amp;= q_{1}^<em>q_{2}^</em>\<br>&amp;= [s, -\pmb{v}]\cdot[t, -\pmb{u}]\<br>&amp;= [st - (-\pmb{v})\cdot(-\pmb{u}), s(-\pmb{u}) + t(-\pmb{v}) + (-\pmb{v})\times(-\pmb{u})]\<br>&amp;= [st - \pmb{v}\cdot\pmb{u}, -s\pmb{u} - t\pmb{v} + \pmb{v}\times\pmb{u}]<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>RHS &amp;= (q_{2}q_{1})^<em>\<br>&amp;= ([t, \pmb{u}]\cdot[s, \pmb{v}])^</em>\<br>&amp;= [ts - \pmb{u}\cdot\pmb{v}, t\pmb{v} + s\pmb{u} + \pmb{u}\times\pmb{v}]\<br>&amp;= [st - \pmb{v}\cdot\pmb{u}, -s\pmb{u} - t\pmb{v} + \pmb{v}\times\pmb{u}] = LHS<br>\end{aligned}<br>$$</p><p>所以我们能得到<br>$$<br>\begin{aligned}<br>v’’ &amp;= q_{2}q_{1}vq_{1}^<em>q_{2}^</em>\<br>&amp;= (q_{2}q_{1})v(q_{2}q_{1})^*\<br>\end{aligned}<br>$$</p><p>这也就是说，$q_{net} = q_{2}q_{1}$。注意四元数乘法的顺序，我们先进行的是 $q_{1}$ 的变换，再进行 $q_{2}$ 的变换。这和矩阵与函数的复合非常相似，都是从右往左叠加。</p><p>要注意的是，$q_{1}$ 与 $q_{2}$ 的等价旋转 $q_{net}$ 并不是分别沿着 $q_{1}$ 和 $q_{2}$ 的两个旋转轴进行的两次旋转。它是沿着一个全新的旋转轴进行的一次等价旋转，仅仅只有旋转的结果相同。</p><p>虽然我们讨论的是两个旋转的复合，但是它可以很容易地推广到多个旋转的复合。比如说我们还需要进行第三个旋转 $q_{3}$，那么<br>$$<br>\begin{aligned}<br>v’‘’ &amp;= q_{3}(q_{2}q_{1})v(q_{2}q_{1})^<em>q_{3}^</em>\<br>&amp;= (q_{3}q_{2}q_{1})v(q_{3}q_{2}q_{1})^*<br>\end{aligned}<br>$$<br>它的等价旋转就是 $q_{net} = q_{3}q_{2}q_{1}$</p><h3 id="双倍覆盖">双倍覆盖</h3><p>四元数与 3D 旋转的关系并不是一对一的，同一个 3D 旋转可以使用两个不同的四元数来表示。对任意的四元数 $q = [\cos(\frac{\theta}{2}), \sin(\frac{\theta}{2})\pmb{u}]$，$q$ 与 $-q$ 代表的是同一个旋转。如果 $q$ 表示的是沿着旋转轴 $\pmb{u}$ 旋转 $\theta$ 度，那么 $-q$ 代表的是沿着相反的旋转轴 $-\pmb{u}$ 旋转 $(2\pi - \theta)$ 度：<br>$$<br>\begin{aligned}<br>-q &amp;= [-\cos(\frac{\theta}{2}), -\sin(\frac{\theta}{2})\pmb{u}]\<br>&amp;= [\cos(\pi - \frac{\theta}{2}), \sin(\pi - \frac{\theta}{2})(-\pmb{u})]\qquad (\cos(\pi - \theta) = -\cos(\theta), \sin(\pi - \theta) = \sin(\theta))<br>\end{aligned}<br>$$<br>所以，这个四元数旋转的角度为 $2(\pi - \frac{\theta}{2}) = 2\pi - \theta$。从下面的图中我们可以看到，这两个旋转是完全等价的：</p><p><img src="/posts_image/Quaternion/Quaternion_8.png" alt=""></p><p>其实从四元数的旋转公式中也能推导出相同的结果<br>$$<br>(-q)v(-q)^* = (-1)^2qvq^* = qvq^*<br>$$</p><p>所以，我们经常说单位四元数与 3D 旋转有一个“<strong>2对1满射同态</strong>”关系，或者说单位四元数“<strong>双倍覆盖</strong>”了 3D 旋转。</p><p>因为这个映射是满射，我们可以说所有的单位四元数都对应着一个 3D 旋转。或者说，一个四维单位超球面（也叫做 $\mathbb{S}^3$）上任意一点所对应的四元数（$\lVert q \rVert = 1$）都对应着一个 3D 旋转。</p><p>有一点需要注意的是，虽然 $q$ 与 $-q$ 是两个不同的四元数，但是由于旋转矩阵中的每一项都包含了四元数两个分量的乘积，它们的旋转矩阵是完全相同的。旋转矩阵并不会出现双倍覆盖的问题。</p><h3 id="指数形式">指数形式</h3><p>在讨论复数的时候，我们利用欧拉公式将 2D 的旋转写成了 $v’ = e^{i\theta}v$ 这样的指数形式。实际上，我们也可以利用四元数将 3D 旋转写成类似的形式。</p><p>类似于复数的欧拉公式，四元数也有一个类似的公式，如果 $\pmb{u}$ 是一个单位向量，那么对于单位四元数 $u = [0, \pmb{u}]$，有<br>$$<br>e^{u\theta} = \cos(\theta) + u\sin(\theta) = \cos(\theta) + \pmb{u}\sin(\theta)<br>$$<br>也就是说，$q = [\cos(\theta), \sin(\theta)\pmb{u}]$ 可以使用指数表示为 $e^{u\theta}$。这个公式的证明与欧拉公式的证明非常类似，直接使用级数展开就可以了。</p><p>$Proof$.</p><p>我们知道，$e^{x}$，$\sin(x)$，$\cos(x)$ 分别能用泰勒级数展开为：</p><p>$$<br>\begin{aligned}<br>e^{x} &amp;= \sum_{n=0}^{\infty}{\frac{x^{n}}{n!}} = 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \frac{x^4}{4!} + \dots\<br>\sin(x) &amp;= \sum_{n=0}^{\infty}{\frac{(-1)^n}{(2n + 1)!}x^{2n + 1}} = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} + \dots\<br>\cos(x) &amp;= \sum_{n=0}^{\infty}{\frac{(-1)^n}{(2n)!}x^{2n}} = 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \frac{x^6}{6!} + \dots\<br>\end{aligned}<br>$$</p><p>我们可以将 $x = u\theta$ 代入 $e^x$，得到<br>$$<br>\begin{aligned}<br>LHS = e^{u\theta} &amp;= \sum_{n=0}^{\infty}{\frac{(u\theta)^n}{n!}}\<br>&amp;= 1 + u\theta + \frac{(u\theta)^2}{2!} + \frac{(u\theta)^3}{3!} + \frac{(u\theta)^4}{4!} + \frac{(u\theta)^5}{5!} + \dots\<br>&amp;= 1 + u\theta + \frac{u^2\theta^2}{2!} + \frac{u^3\theta^3}{3!} + \frac{u^4\theta^4}{4!} + \frac{u^5\theta^5}{5!} + \dots\<br>\end{aligned}<br>$$</p><p>因为 $u^2 = [-\pmb{u}\cdot\pmb{u}, \pmb{0}] = -\lVert u \rVert^2 = -1$，我们可以对 $e^{u\theta}$ 进一步化简<br>$$<br>\begin{aligned}<br>LHS &amp;= 1 + u\theta + \frac{u^2\theta^2}{2!} + \frac{uu^2\theta^3}{3!} + \frac{(u^2)^2\theta^4}{4!} + \frac{u(u^2)^2\theta^5}{5!} + \dots\<br>&amp;= 1 + u\theta - \frac{\theta^2}{2!} - \frac{u\theta^3}{3!} + \frac{\theta^4}{4!} + \frac{u\theta^5}{5!} - \dots\<br>\end{aligned}<br>$$</p><p>同理，将 $\theta$ 代入 $\cos(x)$ 和 $\sin(x)$，<br>$$<br>\begin{aligned}<br>\sin(\theta) &amp;= \sum_{n=0}^{\infty}{\frac{(-1)^n}{(2n + 1)!}\theta^{2n + 1}}\<br>&amp;= \theta - \frac{\theta^3}{3!} + \frac{\theta^5}{5!} - \frac{\theta^7}{7!} + \dots\<br>\<br>\cos(\theta) &amp;= \sum_{n=0}^{\infty}{\frac{(-1)^n}{(2n)!}\theta^{2n}}\<br>&amp;= 1 - \frac{\theta^2}{2!} + \frac{\theta^4}{4!} - \frac{\theta^6}{6!} + \dots\<br>\end{aligned}<br>$$</p><p>所以，<br>$$<br>\begin{aligned}<br>RHS &amp;= \cos(\theta) + u\sin(\theta)\<br>&amp;= \sum_{n=0}^{\infty}{\frac{(-1)^n}{(2n)!}\theta^{2n}} + u\sum_{n=0}^{\infty}{\frac{(-1)^n}{(2n + 1)!}\theta^{2n + 1}}\<br>&amp;= 1 + u\theta - \frac{\theta^2}{2!} - \frac{u\theta^3}{3!} + \frac{\theta^4}{4!} + \frac{u\theta^5}{5!} - \dots = LHS<br>\end{aligned}<br>$$</p><p>因为 $\pmb{u}$ 是一个单位向量，$u^2 = [-\pmb{u}\cdot\pmb{u}, \pmb{0}] = -\lVert u \rVert^2 = -1$，这与欧拉公式中的 $i$ 是非常类似的。</p><p>有了指数型的表示方式，我们就能够将之前四元数的旋转公式改写为指数形式了：</p><div class="note note-primary">            <p><strong>Theorem 12：3D 旋转公式（指数型）</strong><br>任意向量 $\pmb{v}$ 沿着以单位向量定义的旋转轴 $\pmb{u}$ 旋转 $\theta$ 度之后的 $\pmb{v’}$ 可以使用四元数的指数表示。令 $v = [0, \pmb{v}]，u = [0, \pmb{u}]$，那么：<br>$$<br>v’ = e^{u\frac{\theta}{2}}ve^{-u\frac{\theta}{2}}<br>$$</p>          </div><p>有了四元数的指数定义，我们就能够定义四元数的更多运算了，首先是自然对数 $\log$，对任意单位四元数 $q = [\cos(\theta), \sin(\theta)\pmb{u}]$，<br>$$<br>\log(q) = \log(e^{u\theta}) = [0, \pmb{u}\theta]<br>$$<br>接下来是四元数的幂运算<br>$$<br>q^t = (e^{u\theta})^t = e^{u(t\theta)} = [\cos(t\theta), \sin(t\theta)\pmb{u}]<br>$$<br>可以看到，一个单位四元数的 $t$ 次幂等同于将它的旋转角缩放至 $t$ 倍，并且不会改变它的旋转轴（$u$ 必须是单位向量，所以一般不能与 $t$ 结合）。这些运算会在之后讨论四元数插值时非常有用。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四元数和三维旋转(一)</title>
    <link href="/posts/%E5%9B%9B%E5%85%83%E6%95%B0%E5%92%8C%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC(%E4%B8%80)/"/>
    <url>/posts/%E5%9B%9B%E5%85%83%E6%95%B0%E5%92%8C%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p>由于使用欧拉角进行旋转时会存在万向锁的问题，同时，用欧拉角进行插值也不尽方便，而基于四元数的旋转既解决了万向锁的问题，又能非常方便地进行插值。本文将对在学习过程中遇到的四元数的定义、推导、性质、插值等问题进行总结归纳。</p><h2 id="复数">复数</h2><p>我们先来简要讨论一下复数的一些性质以及它与 2D 旋转之间的关系，四元数的很多性质都与复数非常类似，所以理解复数的一些性质对理解四元数非常有帮助。</p><h3 id="定义">定义</h3><p>任意一个复数 $z \in \mathbb{C}$ 都可以表示为 $z = a + bi$ 的形式，其中 $a,b \in \mathbb{R}$ 而且 $i^2 = -1$。我们将 $a$ 称为复数 $z$ 的实部，表示为 $a = Re(z)$，$b$ 称为复数 $z$ 的虚部，表示为 $b = Im(z)$。</p><p>因为 $z = a + bi$ 其实就是对于 ${1, i}$ 这个<strong>基</strong>（Basis）的<strong>线性组合</strong>（Linear Combination），我们也可以用向量来表示一个复数：<br>$$<br>z = \begin{bmatrix}<br>a\<br>b\<br>\end{bmatrix}<br>$$</p><p>因为这个向量有两个元素，我们可以使用复平面上的一个点来表示一个复数。复平面的横坐标代表它的实部，纵坐标代表它的虚部：</p><p><img src="/posts_image/Quaternion/Quaternion_1.png" alt=""></p><h3 id="复数的加减法">复数的加减法</h3><p>如果我们有两个复数 $z_{1} = a + bi$，$z_{2} = c + di$，它们的和就是分量相加的结果：<br>$$<br>z_{1} + z_{2} = (a + c) + (b + d)i<br>$$<br>同理，如果要对它们相减，直接将分量相减就可以了。<br>$$<br>z_{1} - z_{2} = (a - c) + (b - d)i<br>$$</p><h3 id="复数的乘法">复数的乘法</h3><p>如果有两个复数 $z_{1} = a + bi$，$z_{2} = c + di$，我们可以使用分配律来计算它们的乘积<br>$$<br>\begin{aligned}<br>z_{1}z_{2} &amp;= (a + bi)(c + di)\<br>&amp;= ac + adi + bci + bdi^2\<br>&amp;= ac - bd + adi +bci\<br>&amp;= a\textcolor{red}{c} - b\textcolor{blue}{d} +\<br>&amp;\quad(b\textcolor{red}{c} + a\textcolor{blue}{d})i<br>\end{aligned}<br>$$<br>如果仔细观察可以发现，复数相乘的结果其实也是一个矩阵与向量相乘的结果，也就是说：<br>$$<br>\begin{aligned}<br>z_{1}z_{2} &amp;= a\textcolor{red}{c} - b\textcolor{blue}{d} +\<br>&amp;\quad(b\textcolor{red}{c} + a\textcolor{blue}{d})i\<br>&amp;=<br>\begin{bmatrix}<br>a&amp;-b\<br>b&amp;a\<br>\end{bmatrix}<br>\begin{bmatrix}<br>\textcolor{red}{c}\<br>\textcolor{blue}{d}\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><p>右侧的 $\begin{bmatrix}c\ d \end{bmatrix}$ 是用向量的形式来表示的 $z_{2}$，而左侧的 $\begin{bmatrix} a&amp;-b\ b&amp;a\ \end{bmatrix}$ 则是 $z_{1}$ 的矩阵形式。我们可以发现，复数相乘这个运算，其实是与 $\begin{bmatrix} a&amp;-b\ b&amp;a\ \end{bmatrix}$ 则是 $z_{1}$ 这个矩阵所代表的<strong>变换</strong>是等价的。</p><p>那么在矩阵形式下，复数与复数的相乘也可以表示为矩阵的相乘，如果我们有两个复数 $z_{1} = a + bi$，$z_{2} = c + di$，那么与 $z_{1}z_{2}$ 所代表的变换则可以表示为</p><p>$$<br>\begin{aligned}<br>z_{1}z_{2} &amp;=<br>\begin{bmatrix}<br>a&amp;-b\<br>b&amp;a\<br>\end{bmatrix}<br>\begin{bmatrix}<br>c&amp;-d\<br>d&amp;c\<br>\end{bmatrix}\<br>&amp;=<br>\begin{bmatrix}<br>ac - bd&amp;-(bc + ad)\<br>bc + ad&amp;ac - bd\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><p>复数的相乘满足交换律，即 $z_{1}z_{2}$ 与 $z_{2}z_{1}$ 是等价的</p><p>$$<br>\begin{aligned}<br>z_{2}z_{1} &amp;=<br>\begin{bmatrix}<br>c&amp;-d\<br>d&amp;c\<br>\end{bmatrix}<br>\begin{bmatrix}<br>a&amp;-b\<br>b&amp;a\<br>\end{bmatrix}\<br>&amp;=<br>\begin{bmatrix}<br>ac - bd&amp;-(bc + ad)\<br>bc + ad&amp;ac - bd\<br>\end{bmatrix} = z_{1}z_{2}<br>\end{aligned}<br>$$</p><p>除此之外，我们来看一下一些特殊的矩阵形式：<br>$$<br>1 = \begin{bmatrix}<br>1&amp;0\<br>0&amp;1\<br>\end{bmatrix}<br>= I<br>\quad(a = 1, b = 0)<br>$$<br>$$<br>i = \begin{bmatrix}<br>0&amp;-1\<br>1&amp;0\<br>\end{bmatrix}<br>\quad(a = 0, b = 1)<br>$$</p><p>实数单位 1 与矩阵单位矩阵是等价的，而虚数单位 $i$ 则等价于 $\begin{bmatrix} 0&amp;-1\ 1&amp;0\ \end{bmatrix}$，如果我们尝试对它进行平方，可以发现：</p><p>$$<br>i^2 = i \cdot i =<br>\begin{bmatrix}<br>0&amp;-1\<br>1&amp;0\<br>\end{bmatrix}<br>\begin{bmatrix}<br>0&amp;-1\<br>1&amp;0\<br>\end{bmatrix}<br>= \begin{bmatrix}<br>-1&amp;0\<br>0&amp;-1\<br>\end{bmatrix} = -I = -1<br>$$</p><p>即便实在矩阵形式下，$i^2$ 与 -1 其实也是等价的，这进一步展示了复数与这一矩阵形式的关联。</p><h3 id="复数的模长与共轭">复数的模长与共轭</h3><p>复数 $z = a + bi$ 的<strong>模长</strong>（Magnitude）定义为<br>$$<br>\lVert z \rVert = \sqrt{a^2 + b^2}<br>$$</p><p>复数 $z = a + bi$ 的<strong>共轭</strong>（Conjugate）定义为</p><p>$$<br>\bar{z} = a - bi<br>$$</p><p>如果尝试计算 $z\bar{z}$，我们就会发现</p><p>$$<br>\begin{aligned}<br>z\bar{z} &amp;= (a + bi)(a - bi)\<br>&amp;= a^2 - abi + abi + b^2\<br>&amp;= a^2 + b^2 = {\lVert z \rVert}^2<br>\end{aligned}<br>$$</p><p>所以，一个复数的模长又可以通过下面的方式计算</p><p>$$<br>\lVert z \rVert = \sqrt{z\bar{z}}<br>$$</p><h3 id="复数与二维旋转">复数与二维旋转</h3><p>注意观察复数 $z$ 的矩阵形式 $\begin{bmatrix} a&amp;-b\ b&amp;a\ \end{bmatrix}$，我们可以把它变换为下述形式：</p><p>$$<br>\begin{bmatrix} a&amp;-b\ b&amp;a\ \end{bmatrix} = \sqrt{a^2 + b^2}<br>\begin{bmatrix}<br>\frac{a}{\sqrt{a^2 + b^2}}&amp;\frac{-b}{\sqrt{a^2 + b^2}}\<br>\frac{b}{\sqrt{a^2 + b^2}}&amp;\frac{a}{\sqrt{a^2 + b^2}}\<br>\end{bmatrix}<br>$$</p><p><img src="/posts_image/Quaternion/Quaternion_2.png" alt=""></p><p>可以看到，$\lVert z \rVert$ 正是复数 $z$ 与坐标轴所形成的三角形的斜边长，而 $a$，$b$ 分别为三角形的两个直角边．如果将斜边与实数轴正方向的夹角记为 $\theta$ 的话，按照三角函数的定义可以得出 $\frac{a}{\sqrt{a^2 + b^2}} = \cos(\theta)$ 且 $\frac{b}{\sqrt{a^2 + b^2}} = \sin(\theta)$,这个角度 $\theta$ 其实就是 $atan2(b, a)$。知道了这些，原矩阵就可以变形为</p><p>$$<br>\begin{aligned}<br>\begin{bmatrix} a&amp;-b\ b&amp;a\ \end{bmatrix} &amp;= \sqrt{a^2 + b^2}<br>\begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}\<br>&amp;= \lVert z \rVert<br>\begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}\<br>&amp;= \lVert z \rVert \cdot I<br>\begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}\<br>&amp;= \begin{bmatrix}<br>\lVert z \rVert&amp;0\<br>0&amp;\lVert z \rVert\<br>\end{bmatrix}<br>\begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}\<br>\end{aligned}<br>$$</p><p>其中，左边的 $\begin{bmatrix}\lVert z \rVert&amp;0\ 0&amp;\lVert z \rVert\ \end{bmatrix}$ 是缩放矩阵，而右边的 $\begin{bmatrix}\cos(\theta)&amp;-\sin(\theta)\ \sin(\theta)&amp;\cos(\theta)\ \end{bmatrix}$ 是 2D 旋转矩阵。</p><p>让我们看看这个矩阵对两个基 $\begin{bmatrix}1\ 0 \end{bmatrix}$ 和 $\begin{bmatrix}0\ 1 \end{bmatrix}$ 的变换效果，首先是 $\begin{bmatrix}1\ 0 \end{bmatrix}$:</p><p>$$<br>\begin{aligned}<br>\begin{bmatrix}<br>a&amp;-b\<br>b&amp;a\<br>\end{bmatrix}<br>\begin{bmatrix}<br>1\<br>0\<br>\end{bmatrix}<br>&amp;= \begin{bmatrix}<br>\lVert z \rVert&amp;0\<br>0&amp;\lVert z \rVert\<br>\end{bmatrix}<br>\begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}<br>\begin{bmatrix}<br>1\<br>0\<br>\end{bmatrix}\<br>&amp;= \begin{bmatrix}<br>\lVert z \rVert&amp;0\<br>0&amp;\lVert z \rVert\<br>\end{bmatrix}<br>\begin{bmatrix}<br>\cos(\theta)\<br>\sin(\theta)\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><p>第一步首先将 $\begin{bmatrix}1\ 0 \end{bmatrix}$ 变换到了 $\begin{bmatrix}\cos(\theta)\ \sin(\theta) \end{bmatrix}$ 的位置，也就是逆时针旋转了 $\theta$ 度，接下来<br>$$<br>\begin{bmatrix}<br>\lVert z \rVert&amp;0\<br>0&amp;\lVert z \rVert\<br>\end{bmatrix}<br>\begin{bmatrix}<br>\cos(\theta)\<br>\sin(\theta)\<br>\end{bmatrix} =<br>\begin{bmatrix}<br>\lVert z \rVert\cos(\theta)\<br>\lVert z \rVert\sin(\theta)\<br>\end{bmatrix}<br>$$<br>缩放矩阵将 $\begin{bmatrix}\cos(\theta)\ \sin(\theta)\ \end{bmatrix}$ 缩放了 $\lVert z \rVert$ 倍，变为 $\begin{bmatrix}\lVert z \rVert\cos(\theta)\ \lVert z \rVert\sin(\theta)\ \end{bmatrix}$。总的来说，就是对 $\begin{bmatrix}1\ 0 \end{bmatrix}$ 旋转了 $\theta$ 度，并缩放了 $\lVert z \rVert$ 倍。</p><p>接下来是 $\begin{bmatrix}0\ 1 \end{bmatrix}$：</p><p>$$<br>\begin{aligned}<br>\begin{bmatrix}<br>a&amp;-b\<br>b&amp;a\<br>\end{bmatrix}<br>\begin{bmatrix}<br>0\<br>1\<br>\end{bmatrix}<br>&amp;= \begin{bmatrix}<br>\lVert z \rVert&amp;0\<br>0&amp;\lVert z \rVert\<br>\end{bmatrix}<br>\begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}<br>\begin{bmatrix}<br>0\<br>1\<br>\end{bmatrix}\<br>&amp;= \begin{bmatrix}<br>\lVert z \rVert&amp;0\<br>0&amp;\lVert z \rVert\<br>\end{bmatrix}<br>\begin{bmatrix}<br>-\sin(\theta)\<br>\cos(\theta)\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><p>这里，第一步将 $\begin{bmatrix}0\ 1 \end{bmatrix}$ 变换到了 $\begin{bmatrix}-\sin(\theta)\ \cos(\theta) \end{bmatrix}$ 的位置，这同样是逆时针旋转了 $\theta$ 度，见下图：</p><p><img src="/posts_image/Quaternion/Quaternion_2.png" alt=""></p><p>第二步变换同样会将 $\begin{bmatrix}-\sin(\theta)\ \cos(\theta) \end{bmatrix}$ 缩放为 $\begin{bmatrix}-\lVert z \rVert\sin(\theta)\ \lVert z \rVert\cos(\theta) \end{bmatrix}$。这样等于是将整个坐标系逆时针旋转了 $\theta$ 度，并缩放了 $\lVert z \rVert$ 倍。</p><p>换句话说，复数相乘的几何意义就是<strong>旋转与缩放变换的复合</strong>。如果有一个复数 $z = a + bi$，那么 $z$ 与任意一个复数 $c$ 相乘都会将 $c$ 逆时针旋转 $\theta = atan2(b, a)$ 度，并将其缩放 $\lVert z \rVert = \sqrt{a^2 + b^2}$ 倍。</p><p>如果复数的模长为 1，那么它的几何意义就只有旋转。</p><p>$$<br>z = \begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}<br>$$</p><p>如果我们想让 2D 空间中任意一个向量 $\vec{v}$ 旋转 $\theta$ 度，那么我们就可以使用这个矩阵对 $\vec{v}$ 进行变换：</p><div class="note note-primary">            <p><strong>Theorem 1：2D 旋转公式（矩阵型）</strong><br>$$<br>\vec{v’} = \begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}<br>\vec{v}<br>$$</p>          </div><p>其实 $\begin{bmatrix}\cos(\theta)&amp;-\sin(\theta)\ \sin(\theta)&amp;\cos(\theta)\ \end{bmatrix}$ 这个旋转矩阵如果写成复数形式的话就是 $\cos(\theta) + i\sin(\theta)$</p><p>如果我们将向量 $\vec{v} = \begin{bmatrix} x\ y\ \end{bmatrix}$ 看作是一个复数 $v = x + yi$，其中实部为 $x$，虚部为 $y$。那么我们可以构造一个复数 $z = \cos(\theta) + i\sin(\theta)$，并将它与 $v$ 相乘来进行旋转，旋转 $\theta$ 度之后的向量 $v’$ 可以用等价的复数乘法来表示：</p><div class="note note-primary">            <p><strong>Theorem 2：2D 旋转公式（复数积型）</strong><br>$$<br>\begin{aligned}<br>v’ &amp;= zv\<br>&amp;= (\cos(\theta) + i\sin(\theta)) v<br>\end{aligned}<br>$$</p>          </div><h3 id="复数的极坐标型">复数的极坐标型</h3><p>$\cos(\theta) + i\sin(\theta)$ 还可以进行下一步的变形，根据欧拉公式（Euler’s Formula），<br>$$<br>\cos(\theta) + i\sin(\theta) = e^{i\theta}<br>$$</p><div class="note note-success">            <p><strong>欧拉公式的证明：</strong></p><p>令 $f(\theta) = \frac{\cos(\theta) + i\sin(\theta)}{e^{i\theta}} = e^{-i\theta}(\cos(\theta) + i\sin(\theta))$，对实数 $\theta$，对 $f(\theta)$ 求导，得到 $f’(\theta) = e^{-i\theta}(i\cos(\theta) - \sin(\theta)) - ie^{-i\theta}(\cos(\theta) + i\sin(\theta)) = 0$，因此 $f(\theta)$ 是常数。又因为 $f(0) = 1$，所以 $f(\theta) \equiv 1$。欧拉公式得证。</p>          </div><p>有了这个等式，我们就能将复数表示为<br>$$<br>\begin{aligned}<br>z &amp;= \lVert z \rVert<br>\begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}<br>&amp;= \lVert z \rVert (\cos(\theta) + i\sin(\theta))<br>&amp;= \lVert z \rVert e^{i\theta}<br>\end{aligned}<br>$$</p><p>如果我们定义 $r = \lVert z \rVert$，我们就得到了复数的极坐标形式：<br>$$<br>z = re^{i\theta}<br>$$</p><p>现在复数的定义就与实部与虚部的两个分量 $a$，$b$ 无关了，我们可以使用一个缩放因子 $r$ 和旋转角度 $\theta$ 的形式来定义任意一个复数，而且它旋转与缩放的性质仍然存在。如果我们想对 2D 空间中的向量 $\vec{v} = \begin{bmatrix} x\ y\ \end{bmatrix}$ 进行旋转并缩放，我们可以类似地将这个向量看作是一个复数 $v = x + yi$，那么，经过旋转 $\theta$ 度，缩放 $r$ 倍之后的向量 $v’$ 就可以这样计算：<br>$$<br>v’ = re^{i\theta}v<br>$$<br>如果仅需要旋转 $\theta$ 度的话，可以令缩放因子 $r = 1$，那么变换后的结果就是</p><div class="note note-primary">            <p><strong>Theorem 3：2D 旋转公式（指数型）</strong><br>$$<br>v’ = e^{i\theta}v<br>$$</p>          </div><h3 id="复数的几种表示形式总结">复数的几种表示形式总结</h3><ul><li>代数形式一：$z = a + bi$</li><li>代数形式二：$z = r(\cos(\theta) + i\sin(\theta))$</li><li>向量形式：$z = \begin{bmatrix}a\ b\ \end{bmatrix}$</li><li>矩阵形式一：$\begin{bmatrix} a&amp;-b\ b&amp;a\ \end{bmatrix}$</li><li>矩阵形式二：$\begin{bmatrix}\lVert z \rVert&amp;0\ 0&amp;\lVert z \rVert\ \end{bmatrix} \begin{bmatrix}\cos(\theta)&amp;-\sin(\theta)\ \sin(\theta)&amp;\cos(\theta)\ \end{bmatrix}\$</li><li>极坐标形式：$z = re^{i\theta}$</li></ul><p>这几种形式完全等价</p><h3 id="旋转的复合">旋转的复合</h3><p>如果我们有两个代表 2D 旋转的单位复数 $z_{1} = \cos(\theta) + i\sin(\theta)$，$z_{2} = \cos(\phi) + i\sin(\phi)$ 以及一个向量 $v = x + yi$，我们可以先对 $v$ 进行 $z_{1}$ 的旋转<br>$$<br>v’ = z_{1}v<br>$$<br>在此基础上，我们对 $v’$ 进行 $z_{2}$ 的旋转<br>$$<br>\begin{aligned}<br>v’’ &amp;= z_{2}(z_{1}v)\<br>&amp;= (z_{2}z_{1})v<br>\end{aligned}<br>$$<br>如果我们将这两次旋转所作出的等效变换称为 $z_{net}$，那么<br>$$<br>\begin{aligned}<br>v’’ &amp;= (z_{2}z_{1})v = z_{net}v\<br>z_{net} &amp;= z_{2}z_{1}<br>\end{aligned}<br>$$</p><p>因为复数的相乘遵守交换律，所以<br>$$<br>z_{net} = z_{2}z_{1} = z_{1}z_{2}<br>$$<br>如果尝试计算一下 $z_{net}$，会发现<br>$$<br>\begin{aligned}<br>z_{net} &amp;= (\cos(\theta) + i\sin(\theta))(\cos(\phi) + i\sin(\phi))\<br>&amp;= \cos(\theta)\cos(\phi) + i(\cos(\theta)\sin(\phi)) + i(\sin(\theta)\cos(\phi)) - \sin(\theta)\sin(\phi)\<br>&amp;= (\cos(\theta)\cos(\phi) - \sin(\theta)\sin(\phi)) + (\cos(\theta)\sin(\phi) + \sin(\theta)\cos(\phi))i<br>\end{aligned}<br>$$</p><p>这个式子可以利用三角恒等式化简为：<br>$$<br>\begin{aligned}<br>z_{net} &amp;= (\cos(\theta) + i\sin(\theta))(\cos(\phi) + i\sin(\phi))\<br>&amp;= \cos(\theta + \phi) + i\sin(\theta + \phi)<br>\end{aligned}<br>$$</p><p>所以，当我们对两个 2D 旋转进行复合时，所得到的变换 $z_{net}$ 仍是一个旋转，而且与施加的次序无关。这个等效变换的旋转角是 $z_{1} 与 $z_{2} 旋转角之和。</p><h2 id="轴角式旋转">轴角式旋转</h2><p>假设我们有一个经过原点的（如果旋转轴不经过原点我们可以先将旋转轴平移到原点，进行旋转，再平移回原处）旋转轴 $\vec{u} = (x,y,z)^T$，我们希望将一个向量 $\vec{v}$，沿着这个旋转轴旋转 $\theta$ 度，变换到 $\vec{v’}$</p><p><img src="/posts_image/Quaternion/Quaternion_4.png" alt=""></p><p>我们使用右手坐标系统，并且将使用右手定则来定义旋转的正方向。你可以将右手拇指指向旋转轴 $\vec{u}$ 的正方向，这时其他四个手指弯曲的方向即为旋转的正方向。在上图中即为逆时针方向。</p><p>为了消除旋转轴 $\vec{u}$ 模长这个多余的自由度，我们可以规定 $\vec{u}$ 的模长为 1，即 $\vec{u}$ 是一个单位向量。规定 $\vec{u}$ 为单位向量后能为我们带来很多便利，这也是数学和物理中对方向定义的惯例。如果 $\vec{u}$ 不是一个单位向量，我们可以通过下面的公式将它转化为一个单位向量<br>$$<br>\hat{u} = \frac{\vec{u}}{\lVert \vec{u} \rVert}<br>$$</p><h3 id="旋转的分解">旋转的分解</h3><p>我们可以将 $\vec{v}$ 分解为<strong>平行</strong>于旋转轴 $\vec{u}$ 以及<strong>正交</strong>于 $\vec{u}$ 的两个分量，$\vec{v_{\parallel}}$ 和 $\vec{v_{\perp}}$，即<br>$$<br>\vec{v} = \vec{v_{\parallel}} + \vec{v_{\perp}}<br>$$<br>我们可以分别旋转这两个分量，再将它们旋转的结果相加获得旋转后的向量<br>$$<br>\vec{v’} = \vec{v_{\parallel}‘} + \vec{v_{\perp}’}<br>$$<br>下面是分解的示意图：</p><p><img src="/posts_image/Quaternion/Quaternion_5.png" alt=""></p><p>可以看到，$\vec{v_{\parallel}}$ 其实就是 $\vec{v}$ 在 $\vec{u}$ 上的正交投影，根据正交投影公式，我们可以得出：</p><p>$$<br>\begin{aligned}<br>\vec{v_{\parallel}} &amp;= proj_{u}(\vec{v})\<br>&amp;= \frac{\vec{u}\cdot\vec{v}}{\vec{u}\cdot\vec{u}}\vec{u}\<br>&amp;= \frac{\vec{u}\cdot\vec{v}}{\lVert \vec{u} \rVert ^2}\vec{u}\<br>&amp;= (\vec{u}\cdot\vec{v})\vec{u}<br>\end{aligned}<br>$$</p><p>因为 $\vec{v} = \vec{v_{\parallel}} + \vec{v_{\perp}}$，我们可以得到<br>$$<br>\begin{aligned}<br>\vec{v_{\perp}} &amp;= \vec{v} - \vec{v_{\parallel}}\<br>&amp;= \vec{v} - (\vec{u}\cdot\vec{v})\vec{u}<br>\end{aligned}<br>$$</p><h3 id="vec-v-parallel-的旋转">$\vec{v_{\parallel}}$ 的旋转</h3><p>从之前的图示中可以看到，$\vec{v_{\parallel}}$ 其实没有被旋转，仍然与旋转轴 $\vec{u}$ 重合，所以</p><div class="note note-primary">            <p><strong>Theorem 4：3D 旋转公式（向量型，平行情况）</strong><br>当 $\vec{v_{\parallel}}$ 平行于旋转轴 $\vec{u}$ 时，旋转 $\theta$ 角度之后的 $\vec{v_{\parallel}‘}$ 为：<br>$$<br>\vec{v_{\parallel}’} = \vec{v_{\parallel}}<br>$$</p>          </div><h3 id="vec-v-perp-的旋转">$\vec{v_{\perp}}$ 的旋转</h3><p>接下来，我们需要处理正交于 $\vec{u}$ 的 $\vec{v_{\perp}}$。因为这两个向量是正交的，这个旋转可以看作是平面内的一个旋转。因为旋转不改变 $\vec{v_{\perp}}$ 的长度，所以路径是一个园。下面是这个旋转的示意图，右侧的为俯视图：</p><p><img src="/posts_image/Quaternion/Quaternion_6.png" alt=""></p><p>现在，3D 的旋转就被我们转化为了 2D 平面上的旋转，由于在这个平面上我们只有一个向量 $\vec{v_{\perp}}$，用它来表示一个旋转是不够的，我们还需构造一个同时正交于 $\vec{u}$ 和 $\vec{v_{\perp}}$ 的向量 $\vec{w}$，这个可以通过叉乘来获得<br>$$<br>\vec{w} = \vec{u}\times\vec{v_{\perp}}<br>$$</p><p>注意叉乘的顺序，因为我们使用的是右手坐标系统，按右手定则这个新的向量 $\vec{w}$ 指向 $\vec{v_{\perp}}$ 逆时针旋转 $\pi / 2$ 后的方向，并且和 $\vec{v_{\perp}}$ 一样也处于正交于 $\vec{u}$ 的平面内，因为 $\lVert\vec{u}\rVert = 1$，我们可以发现：<br>$$<br>\begin{aligned}<br>\lVert\vec{w}\rVert &amp;= \lVert\vec{u}\times\vec{v_{\perp}}\rVert\<br>&amp;= \lVert\vec{u}\rVert\cdot\lVert\vec{v_{\perp}}\rVert\cdot\sin(\pi/2)\<br>&amp;= \lVert\vec{v_{\perp}}\rVert<br>\end{aligned}<br>$$<br>$\vec{w}$ 和 $\vec{v_{\perp}}$ 的模长相同，且 $\vec{w}$ 也位于圆上，我们可以将 $\vec{w}$ 和 $\vec{v_{\perp}}$ 作为平面内的两个坐标轴，我们现在可以把 $\vec{v_{\perp}‘}$ 投影到 $\vec{w}$ 和 $\vec{v_{\perp}}$ 上，将其分解为 $\vec{v_{v}’}$ 和 $\vec{v_{w}'}$，利用三角形的知识我们可以得到：</p><p>$$<br>\begin{aligned}<br>\vec{v_{\perp}‘} &amp;= \vec{v_{v}’} + \vec{v_{w}'}\<br>&amp;= \cos(\theta)\vec{v_{\perp}} + \sin(\theta)\vec{w}\<br>&amp;= \cos(\theta)\vec{v_{\perp}} + \sin(\theta)(\vec{u}\times\vec{v_{\perp}})<br>\end{aligned}<br>$$</p><div class="note note-primary">            <p><strong>Theorem 5：3D 旋转公式（向量型，正交情况）</strong><br>当 $\vec{v_{\perp}}$ 正交于旋转轴 $\vec{u}$ 时，旋转 $\theta$ 角度之后的 $\vec{v_{\perp}‘}$ 为：<br>$$<br>\vec{v_{\perp}’} = \cos(\theta)\vec{v_{\perp}} + \sin(\theta)(\vec{u}\times\vec{v_{\perp}})<br>$$</p>          </div><h3 id="vec-v-的旋转">$\vec{v}$ 的旋转</h3><p>将上面两个结果组合可以获得：<br>$$<br>\begin{aligned}<br>\vec{v’} &amp;= \vec{v_{\parallel}‘} + \vec{v_{\perp}’}\<br>&amp;= \vec{v_{\parallel}} + \cos(\theta)\vec{v_{\perp}} + \sin(\theta)(\vec{u}\times\vec{v_{\perp}})<br>\end{aligned}<br>$$</p><p>因为叉乘遵守分配律，<br>$$<br>\begin{aligned}<br>\vec{u}\times\vec{v_{\perp}} &amp;= \vec{u}\times(\vec{v} - \vec{v_{\parallel}})\<br>&amp;= \vec{u}\times\vec{v} - \vec{u}\times\vec{v_{\parallel}}\<br>&amp;= \vec{u}\times\vec{v}\quad (\vec{u} 平行于 \vec{v_{\parallel}}，所以 \vec{u}\times\vec{v_{\parallel}} = \vec{0})<br>\end{aligned}<br>$$</p><p>最后，将 $\vec{v_{\parallel}} = (\vec{u}\cdot\vec{v})\vec{u}$ 和 $\vec{v_{\perp}} = \vec{v} - (\vec{u}\cdot\vec{v})\vec{u}$ 代入<br>$$<br>\begin{aligned}<br>\vec{v’} &amp;= (\vec{u}\cdot\vec{v})\vec{u} + \cos(\theta)(\vec{v} - (\vec{u}\cdot\vec{v})\vec{u}) + \sin(\theta)(\vec{u}\times\vec{v})\<br>&amp;= \cos(\theta)\vec{v} + (1 - \cos(\theta))(\vec{u}\cdot\vec{v})\vec{u} + \sin(\theta)(\vec{u}\times\vec{v})<br>\end{aligned}<br>$$<br>这样我们就得到了一般形式的旋转公式：</p><div class="note note-primary">            <p><strong>Theorem 6：3D 旋转公式（向量型，一般情况）</strong><br>3D 空间中任意一个 $\vec{v}$ 沿着单位向量 $\vec{u}$ 旋转 $\theta$ 角度之后的 $\vec{v_{\perp}‘}$ 为：<br>$$<br>\vec{v’} = \cos(\theta)\vec{v} + (1 - \cos(\theta))(\vec{u}\cdot\vec{v})\vec{u} + \sin(\theta)(\vec{u}\times\vec{v})<br>$$</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学基础-介绍</title>
    <link href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80-%E4%BB%8B%E7%BB%8D/"/>
    <url>/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80-%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="图形领域（Graphics-Areas）">图形领域（Graphics Areas）</h2><ul><li>建模（Modeling）</li><li>渲染（Rendering）</li><li>动画（Animation）</li><li>用户交互（User interaction）</li><li>虚拟现实（Virtual reality）</li><li>可视化（Visualization）</li><li>图像处理（Image processing）</li><li>三维扫描（Three-dimensional scanning）</li><li>计算摄影（Computational photography）</li></ul><h2 id="主要应用（Major-Applications）">主要应用（Major Applications）</h2><ul><li>电子游戏（Video games）</li><li>动画（Cartoons）</li><li>视觉效果（Visual effects）</li><li>动画电影（Animated films）</li><li>CAD/CAM（Computer-aided design/Computer-aided manufacturing）</li><li>仿真（Simulation）</li><li>医学成像（Medical imaging）</li><li>信息可视化（Information visualization）</li></ul><h2 id="图形API（Graphics-APIs）">图形API（Graphics APIs）</h2><p>每个图形程序都需要能够使用两个相关的API：一个用于视觉输出的图形API和一个用于从用户那里获得输入的用户界面API</p><ol><li>第一种是集成的方法，以Java为例，其中图形和用户界面工具箱时集成的、可移植的软件包，是完全标准化的并作为语言的一部分得到支持。</li><li>第二种是以Direct3D和OpenGL为代表的，其中的绘图命令是与语言相联系的软件库的一部分，而用户界面软件则是一个独立的实体。</li></ol><h2 id="图形管线（Graphics-Pipeline）">图形管线（Graphics Pipeline）</h2><p>将三维顶点位置映射到二维屏幕位置，并对三角形着色，使它们看起来很真实，并以适当的前后顺序出现。现在几乎都是用 Z-buffer 来解决绘制三角形的前后顺序问题。几何操作几乎完全在4D的齐次坐标空间中完成。</p><h2 id="数值问题（Numerical-Issues）">数值问题（Numerical Issues）</h2><p>实数有三个特殊值</p><ul><li><strong>无限大（$\infty$）</strong> 有效数字，比其他所有有效数字都大</li><li><strong>负无穷大（$-\infty$）</strong> 有效数字，比其他所有有效数字都小</li><li><strong>不是一个数字（$NaN$）</strong> 无效的数字，是由具有未定义结果的操作引起的，如零除以零。</li></ul><p>对于任何正实数 a：</p><p>$+a/(+\infty) = +0$<br>$-a/(+\infty ) = -0$<br>$+a/(-\infty ) = -0$<br>$-a/(-\infty ) = +0$<br>$\infty+\infty = +\infty$<br>$\infty-\infty = NaN$<br>$\infty\times\infty = \infty$<br>$\infty/\infty = NaN$<br>$\infty/a = \infty$<br>$\infty/0 = \infty$<br>$0/0 = NaN$</p><p>涉及无限值的布尔表达式规则如下：</p><ol><li>所有有限的有效数字都小于 $\infty$</li><li>所有有限的有效数字都大于 $-\infty$</li><li>$-\infty$ 小于 $\infty$</li></ol><p>涉及有 $NaN$ 值的表达式的规则很简单：</p><ol><li>任何包括 $NaN$ 的算术表达式的结果都是 $NaN$</li><li>任何涉及 $NaN$ 的布尔表达式都是假的</li></ol><p>对于任何正实数 a，以下涉及除以零值的规则都成立：</p><p>$+a/+0 = +\infty$<br>$-a/+0 = -\infty$</p><h2 id="效率（Efficiency）">效率（Efficiency）</h2><ol><li>尽可能以最直接的方式编写代码。根据需要即时计算中间结果，而不是存储它们。</li><li>在优化模式下进行编译</li><li>使用现有的任何分析工具寻找关键的效率瓶颈问题</li><li>检查数据结构，寻找提高定位数据的方法。尽量使数据单元大小和目标架构上的缓存/页面大小相匹配。</li><li>如果分析发现了数字计算的瓶颈，检查编译器生成的汇编代码是否有遗漏的效率问题。重写源代码来解决发现的任何问题。</li></ol><h2 id="设计和编码图形程序（Designing-and-Coding-Graphics-Programs）">设计和编码图形程序（Designing and Coding Graphics Programs）</h2><h3 id="类的设计">类的设计</h3><p>应该为几何实体（如向量和矩阵）以及图形实体（如RGB颜色和图像）编写尽可能干净又高效的类或程序。</p><ul><li><strong>vector2</strong> 一个存储 x 和 y 分量的二维向量类。应该将分量存储在一个二维数组中，这样就可以支持索引操作。还应编写向量加法、向量减法、点积、叉积、标量乘法和标量除法的操作程序。</li><li><strong>vector3</strong> 类似于 vector2 的三维向量类。</li><li><strong>hvector</strong> 具有四个分量的齐次向量。</li><li><strong>rgb</strong> 一个 RGB 颜色存储三个分量。还应编写 RGB 加法、RGB 减法、RGB 乘法，标量乘法和标量除法的操作程序。</li><li><strong>transform</strong> 一个用于变换的 4 $\times$ 4 矩阵。还应编写一个矩阵乘法和成员函数，以应用于位置、方向和表面法向量的变换。</li><li><strong>image</strong> 一个具有输出操作的 RGB 像素的二维阵列。</li></ul><h3 id="Float-VS-Double">Float VS Double</h3><p>现代架构表明，减少内存的使用和保持连贯的内存访问是效率的关键。所以建议使用单精度数据，然而，为了避免数字问题（Numerical Issues），建议使用双精度算术。这种权衡取决于程序，但在你的类中有一个默认的定义。</p><h3 id="调试图形程序">调试图形程序</h3><h4 id="科学方法">科学方法</h4><p>创建一个图像并观察它的问题所在。然后，我们对导致问题的原因提出一个假设，并对其进行测试。我们有时会觉得这种方法很好用，因为不需要发现一个错误的值或者真正确定概念性错误。我们只是通过实验轻松定位到问题的位置。</p><h4 id="将图像作为调试的输出">将图像作为调试的输出</h4><p>在许多情况下，从图形程序中获得调试信息的最简单渠道是输出图像本身。如果你想知道某个变量在每个像素上的部分计算值，你可以临时修改你的程序，把这个值直接复制到输出图像上，而跳过通常要进行的其他计算。例如，如果你怀疑某个特定的值有时超出了它的有效范围，让你的程序在发生这种情况的地方写上鲜红色的像素。其他常见的技巧包括用明显的颜色画出表面的背面（当它们不应该是可见的），用物体的ID号给图像着色，或者用像素的计算量来着色。</p><h4 id="使用调试器">使用调试器</h4><p>仍然有一些情况，特别是当科学方法似乎已经导致了矛盾的时候，这时没有什么可以替代观察到底发生了什么。麻烦的是，图形程序往往涉及同一代码的许多许多执行（例如，每个像素一次，或每个三角形一次），这使得从一开始就在调试器中步步深入完全不现实。而且最困难的错误通常只发生在复杂的输入上。</p><p>一个有用的方法是为这个错误 “设置一个陷阱（trap）”。首先，确保你的程序是确定性的–在一个单线程中运行，并确保所有的随机数都是由固定的种子计算出来的。然后，找出表现出错误的像素或三角形，并在你怀疑不正确的代码前添加一条语句，只对可疑情况执行。</p><p>如果你设置一个断点，你就可以在你感兴趣的像素被计算出来之前进入调试器。有些调试器有一个 “条件断点 “的功能，可以在不修改代码的情况下达到同样的效果。</p><p>在程序崩溃的情况下，传统的调试器对于确定崩溃的地方很有用。然后，你应该在程序中开始回溯，使用断言（asserts）和重新编译，以找到程序出错的地方。这些断言（asserts）应该留在程序中，以备将来可能添加的错误。这又意味着避免了传统的一步到位的过程，因为那不会在你的程序中加入有价值的断言（asserts）。</p><h4 id="为调试进行数据可视化">为调试进行数据可视化</h4><p>通常情况下，我们很难理解程序在做什么，因为它在最后出错之前计算了很多中间结果。这种情况类似于测量大量数据的科学实验，有一个解决办法是相同的：为自己制作好的图表和插图来理解数据的含义。例如，在光线追踪器中，你可能会写代码将光线树可视化，这样你就可以看到哪些路径对一个像素的贡献，或者在一个图像重采样程序中，你可能会做一些图来显示所有从输入中提取样本的点。花费时间编写代码来可视化你的程序的内部状态，在优化它的时候，也可以通过更好地理解它的行为来得到回报。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fundamental of Computer Graphics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用噪声</title>
    <link href="/posts/%E4%BD%BF%E7%94%A8%E5%99%AA%E5%A3%B0/"/>
    <url>/posts/%E4%BD%BF%E7%94%A8%E5%99%AA%E5%A3%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="消融效果">消融效果</h2><p>**消融（dissolve）**效果常见于游戏中的角色死亡、地图烧毁等效果。在这些效果中，消融往往从不同的区域开始，并向看似随机的方向扩张，最后整个物体都将消失不见。我们将学习如何在 Unity 中实现这种效果，并得到类似下图中的效果。</p><p><img src="/posts_image/Use_Noise/Use_Noise_1.png" alt="箱子的消融效果" title="箱子的消融效果"></p><p>要实现上图中的效果，原理非常简单，概括来说就是噪声纹理+透明度测试。我们使用对噪声纹理采样的结果和某个控制消融程度的阈值比较，如果小于阈值，就使用 clip 函数把它对应的像素裁剪掉，这些部分就对应了图中被“烧毁”的区域。而镂空区域边缘的烧焦效果则是将两种颜色混合，再用 pow 函数处理后，与原纹理颜色混合后的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br>// Upgrade NOTE: replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;<br><br>Shader &quot;Custom/Chapter15/Chapter15-Dissolve&quot; &#123;<br><br>    Properties &#123;<br>        _BurnAmount (&quot;Burn Amount&quot;, Range(0.0, 1.0)) = 0.0<br>        _LineWidth (&quot;Burn Line Width&quot;, Range(0.0, 0.2)) = 0.1<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;<br>        _BurnFirstColor (&quot;Burn First Color&quot;, Color) = (1, 0, 0, 1)<br>        _BurnSecondColor (&quot;Burn Second Color&quot;, Color) = (1, 0, 0, 1)<br>        _BurnMap (&quot;Burn Map&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>    &#125;<br><br>    SubShader &#123;<br>        Pass &#123;<br>            Tags &#123;<br>                &quot;LightMode&quot; = &quot;ForwardBase&quot;<br>            &#125;<br><br>            Cull Off<br>            <br>            CGPROGRAM<br><br>            #include &quot;Lighting.cginc&quot;<br>            #include &quot;AutoLight.cginc&quot;<br><br>            #pragma multi_compile_fwdbase<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br>            <br>            fixed _BurnAmount;<br>            fixed _LineWidth;<br>            sampler2D _MainTex;<br>            sampler2D _BumpMap;<br>            fixed4 _BurnFirstColor;<br>            fixed4 _BurnSecondColor;<br>            sampler2D _BurnMap;<br>            <br>            float4 _MainTex_ST;<br>            float4 _BumpMap_ST;<br>            float4 _BurnMap_ST;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 tangent : TANGENT;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br>            <br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float2 uvMainTex : TEXCOORD0;<br>                float2 uvBumpMap : TEXCOORD1;<br>                float2 uvBurnMap : TEXCOORD2;<br>                float3 lightDir : TEXCOORD3;<br>                float3 worldPos : TEXCOORD4;<br>                SHADOW_COORDS(5)<br>            &#125;;<br><br>            v2f vert (a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br><br>                o.uvMainTex = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                o.uvBumpMap = TRANSFORM_TEX(v.texcoord, _BumpMap);<br>                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);<br><br>                TANGENT_SPACE_ROTATION;<br>                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;<br><br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br>                TRANSFER_SHADOW(o);<br>                return o;<br>            &#125;<br><br>            fixed4 frag (v2f i) : SV_TARGET &#123;<br>                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;<br>                clip(burn.r - _BurnAmount);<br>                float3 tangentLightDir = normalize(i.lightDir);<br>                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));<br><br>                fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br>                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir));<br>                fixed t = 1 - smoothstep(0.0, _LineWidth, burn.r - _BurnAmount);<br>                fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);<br>                burnColor = pow(burnColor, 5);<br><br>                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br>                fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * step(0.0001, _BurnAmount));<br><br>                return fixed4(finalColor, 1);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br><br>        // Pass to render object as a shadow caster<br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;<br>            <br>            CGPROGRAM<br>            <br>            #pragma vertex vert<br>            #pragma fragment frag<br>            <br>            #pragma multi_compile_shadowcaster<br>            <br>            #include &quot;UnityCG.cginc&quot;<br>            <br>            fixed _BurnAmount;<br>            sampler2D _BurnMap;<br>            float4 _BurnMap_ST;<br>            <br>            struct v2f &#123;<br>                V2F_SHADOW_CASTER;<br>                float2 uvBurnMap : TEXCOORD1;<br>            &#125;;<br>            <br>            v2f vert(appdata_base v) &#123;<br>                v2f o;<br>                <br>                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)<br>                <br>                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);<br>                <br>                return o;<br>            &#125;<br>            <br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;<br>                <br>                clip(burn.r - _BurnAmount);<br>                <br>                SHADOW_CASTER_FRAGMENT(i)<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    FallBack &quot;Diffuse&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>_BurnAmount 属性用于控制消融程度，当值为 0 时，物体为正常效果，当值为 1 时，物体会完全消融。_LineWidth 属性用于控制模拟烧焦效果时的线宽，它的值越大，火焰边缘的蔓延范围越广。_MainTex 和 _BumpMap 分别对应了物体原本的漫反射纹理和法线纹理。_BurnFirstColor 和 _BurnSecondColor 对应了火焰边缘的两种颜色值。_BurnMap 则是关键的噪声纹理。</p><p>为了得到正确的光照，我们设置了 Pass 的 LightMode 和 multi_compile_fwdbase 的编译指令。值得注意的是，我们还使用 Cull 命令关闭了该 Shader 的面片剔除，也就是说，模型的正面和背面都会被渲染。这是因为，消融会导致裸露模型内部的构造，如果只渲染正面会出现错误的结果。</p><p>顶点着色器的代码很常规。我们使用宏 TRANSFORM_TEX 计算了三张纹理对应的纹理坐标，再把光源方向从模型空间变换到了切线空间。最后，为了得到阴影信息，计算了世界空间下的顶点位置和阴影纹理的采样坐标（使用了 TRANSFER_SHADOW 宏）。</p><p>在片元着色器中，我们首先对噪声纹理进行采样，并将采样结果和用于控制消融程度的属性 _BurnAmount 相减，传递给 clip 函数。当结果小于 0 时，该像素将会被剔除，从而不会显示到屏幕上。如果通过了测试，则进行正常的光照计算。我们首先根据漫反射纹理得到材质的反射率 albedo，并由此计算得到环境光照，进而得到漫反射光照。然后，我们计算了烧焦颜色 burnColor。我们想要在宽度为 _LineWidth 的范围内模拟一个烧焦的颜色变化，第一步就使用了 smoothstep 函数来计算混合系数 t。当 t 值为 1 时，表明该像素位于消融的边界处，当 t 值为 0 时，表明该像素为正常的模型颜色，而中间的插值则表示需要模拟一个烧焦效果。我们首先用 t 来混合两种火焰颜色 _BurnFirstColor 和 _BurnSecondColor，为了让效果更接近烧焦的痕迹，我们还使用 pow 函数对结果进行处理。然后，我们再次使用 t 来混合正常的光照颜色（环境光+漫反射）和烧焦颜色。我们这里又使用了 step 函数来保证当 _BurnAmount 为 0 时，不显示任何消融效果。最后，返回混合后的颜色值 finalColor。</p><p>使用透明度测试的物体的阴影需要特别处理，如果仍然使用普通的阴影 Pass，那么被剔除的区域仍然会向其他物体投射阴影，造成“穿帮”。为了让物体的阴影也能配合透明度测试产生正确的效果，我们自定义了一个投射阴影的 Pass。</p><p>在 Unity 中，用于投射阴影的 Pass 的 LightMode 需要被设置为 ShadowCaster，同时，还需要使用 #pragma multi_compile_shadowcaster 指明它需要的编译指令。</p><p>阴影投射的重点在于我们需要按正常 Pass 的处理来剔除片元或进行顶点动画，以便阴影可以和物体正常渲染的结果相匹配。在自定义的阴影投射的 Pass 中，我们通常会使用 Unity 提供的内置宏 V2F_SHADOW_CASTER、TRANSFER_SHADOW_CASTER_NORMALOFFSET（旧版本中会使用 TRANSFER_SHADOW_CASTER）和 SHADOW_CASTER_FRAGMENT 来帮助我们计算阴影投射时需要的各种变量，而我们可以只关注自定义计算的部分。在上面的代码中，我们首先在 v2f 结构体中利用 V2F_SHADOW_CASTER 来定义阴影投射需要定义的变量。随后，在顶点着色器中，我们使用 TRANSFER_SHADOW_CASTER_NORMALOFFSET 来填充 V2F_SHADOW_CASTER 在背后声明的一些变量，这是由 Unity 在背后为我们完成的。我们需要在顶点着色器中关注自定义的计算部分，这里指的就是我们需要计算噪声纹理的采样坐标 uvBurnMap。在片元着色器中，我们首先按之前的处理方法使用噪声纹理的采样结果来剔除片元，最后再利用 SHADOW_CASTER_FRAGMENT 来让 Unity 为我们完成阴影投射的部分，把结果输出到深度图和阴影映射纹理中。</p><p>通过 Unity 提供的这三个内置宏（在 UnityCG.cginc 文件中被定义），我们可以方便地自定义需要的阴影投射的 Pass，但由于这些宏需要使用一些特定的输入变量，因此我们需要保证为它们提供了这些变量。例如 TRANSFER_SHADOW_CASTER_NORMALOFFSET 会使用名称 v 作为输入结构体，v 中需要包含顶点位置 v.vertex 和顶点法线 v.normal 的信息，我们可以直接使用内置的 appdata_base 结构体，它包含了这些必须的顶点变量。如果我们需要进行顶点动画，可以在顶点着色器中直接修改 v.vertex，再传递给 TRANSFER_SHADOW_CASTER_NORMALOFFSET 即可。</p><h2 id="水波效果">水波效果</h2><p>在模拟实时水面的过程中，我们往往也会使用噪声纹理，此时，噪声纹理通常会用作一个高度图，以不断修改水面的法线方向。为了模拟水不断流动的效果，我们会使用和时间相关的变量来对噪声纹理进行采样，当得到法线信息后，再进行正常的反射+折射计算，得到最后的水面波动效果。</p><p>下面，我们将会使用一个由噪声纹理得到的法线贴图，实现一个包含菲涅耳反射的水面效果，如下图所示</p><p><img src="/posts_image/Use_Noise/Use_Noise_2.png" alt="包含菲涅耳反射的水面波动效果" title="包含菲涅耳反射的水面波动效果"></p><p>我们使用一张立方体纹理（Cubemap）作为环境纹理，模拟反射。为了模拟折射效果，我们使用 GrabPass 来获取当前屏幕的渲染纹理，并使用切线空间下的法线方向对像素的屏幕坐标进行偏移，再使用该坐标对渲染纹理进行屏幕采样，从而模拟近似的折射效果。水波的法线纹理由一张噪声纹理生成而得，而且会随着时间变化不断平移，模拟波光粼粼的效果。我们没有使用一个定值来混和反射和折射颜色，而是使用之前提到的菲涅耳系数来动态决定混合系数。我们使用如下公式来计算菲涅耳系数：<br>$$<br>fresnel = pow(1 - max(0, v \cdot n), 4)<br>$$<br>其中，$v$ 和 $n$ 分别对应了视角方向和法线方向。它们之间的夹角越小，$fresnel$ 值越小，反射越弱，折射越强。菲涅耳系数还经常会用于边缘光照的计算中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter15/Chapter15-WaterWave&quot; &#123;<br><br>    Properties &#123;<br>        _Color (&quot;Main Color&quot;, Color) = (0, 0.15, 0.115, 1)<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _WaveMap (&quot;Wave Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;<br>        _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<br>        _WaveXSpeed (&quot;Wave Horizontal Speed&quot;, Range(-0.1, 0.1)) = 0.01<br>        _WaveYSpeed (&quot;Wave Vertical Speed&quot;, Range(-0.1, 0.1)) = 0.01<br>    &#125;<br><br>    SubShader &#123;<br>        // We must be transparent, so other objects are drawn before this one.<br>        Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;<br>        <br>        // This pass grabs the screen behind the object into a texture.<br>        // We can access the result in the next pass as _RefractionTex<br>        GrabPass &#123; &quot;_RefractionTex&quot; &#125;<br><br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br>            <br>            CGPROGRAM<br>            <br>            #include &quot;UnityCG.cginc&quot;<br>            #include &quot;Lighting.cginc&quot;<br>            <br>            #pragma multi_compile_fwdbase<br>            <br>            #pragma vertex vert<br>            #pragma fragment frag<br>            <br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            sampler2D _WaveMap;<br>            float4 _WaveMap_ST;<br>            samplerCUBE _Cubemap;<br>            fixed _WaveXSpeed;<br>            fixed _WaveYSpeed;<br>            float _Distortion;<br>            sampler2D _RefractionTex;<br>            float4 _RefractionTex_TexelSize;<br>            <br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 tangent : TANGENT; <br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br>            <br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float4 scrPos : TEXCOORD0;<br>                float4 uv : TEXCOORD1;<br>                float4 TtoW0 : TEXCOORD2;  <br>                float4 TtoW1 : TEXCOORD3;  <br>                float4 TtoW2 : TEXCOORD4; <br>            &#125;;<br>            <br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                <br>                o.scrPos = ComputeGrabScreenPos(o.pos);<br>                <br>                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                o.uv.zw = TRANSFORM_TEX(v.texcoord, _WaveMap);<br>                <br>                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  <br>                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  <br>                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  <br>                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; <br>                <br>                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  <br>                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  <br>                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  <br>                <br>                return o;<br>            &#125;<br>            <br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);<br>                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));<br>                float2 speed = _Time.y * float2(_WaveXSpeed, _WaveYSpeed);<br>                <br>                // Get the normal in tangent space<br>                fixed3 bump1 = UnpackNormal(tex2D(_WaveMap, i.uv.zw + speed)).rgb;<br>                fixed3 bump2 = UnpackNormal(tex2D(_WaveMap, i.uv.zw - speed)).rgb;<br>                fixed3 bump = normalize(bump1 + bump2);<br>                <br>                // Compute the offset in tangent space<br>                float2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;<br>                i.scrPos.xy = offset * i.scrPos.z + i.scrPos.xy;<br>                fixed3 refrCol = tex2D( _RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;<br>                <br>                // Convert the normal to world space<br>                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));<br>                fixed4 texColor = tex2D(_MainTex, i.uv.xy + speed);<br>                fixed3 reflDir = reflect(-viewDir, bump);<br>                fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb * _Color.rgb;<br>                <br>                fixed fresnel = pow(1 - saturate(dot(viewDir, bump)), 4);<br>                fixed3 finalColor = reflCol * fresnel + refrCol * (1 - fresnel);<br>                <br>                return fixed4(finalColor, 1);<br>            &#125;<br>            <br>            ENDCG<br>        &#125;<br>    &#125;<br><br><br>    FallBack &quot;Diffuse&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，_Color 用于控制水面颜色；_MainTex 是水面波纹材质纹理，默认为白色纹理；_WaveMap 是一个由噪声纹理生成的法线纹理；_Cubemap 是用于模拟反射的立方体纹理；_Distortion 则用于控制模拟折射时图像的扭曲程度；_WaveXSpeed 和 _WaveYSpeed 分别用于控制法线纹理在 X 和 Y 方向上的平移速度。</p><p>我们首先在 SubShader 的标签中将渲染队列设置成 Transparent，并把后面的 RenderType 设置为 Opaque。把 Queue 设置成 Transparent 可以确保该物体渲染时，其他所有不透明物体都已经被渲染到屏幕上了，否则就可能无法正确得到“透过水面看到的图像”。而设置 RenderType 则是为了在使用着色器替换（Shader Replacement）时，该物体可以在需要时被正确渲染。这通常发生在我们需要得到摄像机的深度和法线纹理时。随后，我们通过关键词 GrabPass 定义了一个抓取屏幕图像的 Pass。在这个 Pass 中我们定义了一个字符串，该字符串内部的名称决定了抓取得到的屏幕图像将会被存入哪个纹理中。</p><p>需要注意的是，我们还定义了 _RefractionTex 和 _RefractionTex_TexelSize 变量，这对应了在使用 GrabPass 时，指定的纹理名称。_RefractionTex_TexelSize 可以让我们得到该纹理的纹素大小，例如一个大小为 256 $\times$ 512 的纹理，它的纹素大小为(1/256, 1/512)。我们需要在对屏幕图像的采样坐标进行偏移时使用该变量。</p><p>在顶点着色器中，进行了必要的顶点坐标变换后，我们通过调用 ComputeGrabScreenPos 来得到对应被抓取屏幕图像的采样坐标。我们可以在 UnityCG.cginc 文件中找到它的声明，它的主要代码和 ComputeScreenPos 基本类似，最大的不同时针对平台差异造成的采样坐标问题进行了处理。接着，我们计算了 _MainTex 和 _BumpMap 的采样坐标，并把它们分别存储在一个 float4 类型变量的 xy 和 zw 分量中。由于我们需要在片元着色器中把法线方向从切线空间（由法线纹理采样得到）变换到世界空间下，以便对 Cubemap 进行采样，因此，我们需要在这里计算该顶点对应的从切线空间到世界空间的变换矩阵，并把该矩阵的每一行分别存储在 TtoW0、TtoW1 和 TtoW2 的 xyz 分量中。这里面使用的数学方法就是，得到切线空间下的 3 个坐标轴（x、y、z轴分别对应了切线、副切线和法线的方向）在世界空间下的表示，再把它们依次按列组成一个变换矩阵即可。TtoW0 等值的 w 分量同样被利用起来，用于存储世界空间下的顶点坐标。</p><p>在片元着色器中，我们首先通过 TtoW0 等变量的 w 分量得到世界坐标，并用该值得到该片元对应的视角方向。除此之外，我们还使用内置的 _Time.y 变量和 _WaveXSpeed、_WaveYSpeed 属性计算了法线纹理的当前偏移量，并利用该值对法线纹理进行两次采样（这是为了模拟两层交叉的水面波动的效果），对两次结果相加并归一化后得到切线空间下的法线方向。然后，我们使用该值和 _Distortion 属性以及 _RefractionTex_TexelSize 来对屏幕图像的采样坐标进行偏移，模拟折射效果。_Distortion 值越大，偏移量越大，水面背后的物体看起来变形程度越大。在这里，我们选择使用切线空间下的法线方向来进行偏移，是因为该空间下的法线可以反应顶点局部空间下的法线方向。需要注意的是，在计算偏移后的屏幕坐标时，我们把偏移量和屏幕坐标的 z 分量相乘，这是为了模拟深度越大、折射程度越大的效果。如果我们不希望产生这样的效果，可以直接把偏移值叠加到屏幕坐标上。随后，我们对 scrPos 进行了透视除法，再使用该坐标对抓取的屏幕图像 _RefractionTex 进行采样，得到模拟的折射颜色。</p><p>之后，我们把法线方向从切线空间变换到了世界空间下（使用变换矩阵的每一行，即 TtoW0、TtoW1 和 TtoW2，分别和法线方向点乘，构成新的法线方向），并据此得到视角方向相对于法线方向的反射方向。随后，使用反射方向对 Cubemap 进行采样，并把结果和主纹理颜色相乘后得到反射颜色。我们也对主文理进行了纹理动画，以模拟水波的效果。</p><p>为了混合折射和反射颜色，我们随后计算了菲涅耳系数。我们使用之前的公式来计算菲涅耳系数，并据此来混合折射和反射颜色，作为最终的输出颜色。</p><p>我们使用的噪声纹理如下图所示。我们需要的是一张法线纹理，因此我们可以从该噪声纹理的灰度值中生成需要的法线信息，这是通过在它的纹理面板中把纹理类型设置为 <strong>Normal map</strong>，并选中 <strong>Create from grayscale</strong> 来完成的。最后生成的法线纹理如下图的右图所示。</p><p><img src="/posts_image/Use_Noise/Use_Noise_3.png" alt="水波效果使用的噪声纹理" title="水波效果使用的噪声纹理"></p><h2 id="再谈全局雾效">再谈全局雾效</h2><p>我们在之前讲到了如何使用深度纹理来实现一种基于屏幕后处理的全局雾效。我们由深度纹理重建每个像素在世界空间下的位置，再使用一个基于高度的公式来计算雾效的混合系数，最后使用该系数来混合雾的颜色和原屏幕颜色。上次实现的效果是一个基于高度的均匀雾效，即在同一个高度上，雾的浓度是相同的，如下图的左图所示，然而，一些时候我们希望可以模拟一种不均匀的雾效，同时让雾不断飘动，使雾看起来更加飘渺，如下图的右图所示。而这就可以通过使用一张噪声纹理来实现。</p><p><img src="/posts_image/Use_Noise/Use_Noise_4.png" alt="雾效" title="雾效"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FogWithNoise</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader fogShader;<br><span class="hljs-keyword">private</span> Material fogMaterial = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);<br><span class="hljs-keyword">return</span> fogMaterial;<br>&#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> Camera myCamera;<br><span class="hljs-keyword">public</span> Camera camera &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">if</span> (myCamera == <span class="hljs-literal">null</span>) &#123;<br>myCamera = GetComponent&lt;Camera&gt;();<br>&#125;<br><span class="hljs-keyword">return</span> myCamera;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Transform myCameraTransform;<br><span class="hljs-keyword">public</span> Transform cameraTransform &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">if</span> (myCameraTransform == <span class="hljs-literal">null</span>) &#123;<br>myCameraTransform = camera.transform;<br>&#125;<br><br><span class="hljs-keyword">return</span> myCameraTransform;<br>&#125;<br>&#125;<br><br>[<span class="hljs-meta">Range(0.1f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fogDensity = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-keyword">public</span> Color fogColor = Color.white;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fogStart = <span class="hljs-number">0.0f</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fogEnd = <span class="hljs-number">2.0f</span>;<br><br><span class="hljs-keyword">public</span> Texture noiseTexture;<br><br>[<span class="hljs-meta">Range(-0.5f, 0.5f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fogXSpeed = <span class="hljs-number">0.1f</span>;<br><br>[<span class="hljs-meta">Range(-0.5f, 0.5f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fogYSpeed = <span class="hljs-number">0.1f</span>;<br><br>[<span class="hljs-meta">Range(0.0f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> noiseAmount = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span> &#123;<br>GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.Depth;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>Matrix4x4 frustumCorners = Matrix4x4.identity;<br><br><span class="hljs-built_in">float</span> fov = camera.fieldOfView;<br><span class="hljs-built_in">float</span> near = camera.nearClipPlane;<br><span class="hljs-built_in">float</span> aspect = camera.aspect;<br><br><span class="hljs-built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="hljs-number">0.5f</span> * Mathf.Deg2Rad);<br>Vector3 toRight = cameraTransform.right * halfHeight * aspect;<br>Vector3 toTop = cameraTransform.up * halfHeight;<br><br>Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;<br><span class="hljs-built_in">float</span> scale = topLeft.magnitude / near;<br><br>topLeft.Normalize();<br>topLeft *= scale;<br><br>Vector3 topRight = cameraTransform.forward * near + toRight + toTop;<br>topRight.Normalize();<br>topRight *= scale;<br><br>Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;<br>bottomLeft.Normalize();<br>bottomLeft *= scale;<br><br>Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;<br>bottomRight.Normalize();<br>bottomRight *= scale;<br><br>frustumCorners.SetRow(<span class="hljs-number">0</span>, bottomLeft);<br>frustumCorners.SetRow(<span class="hljs-number">1</span>, bottomRight);<br>frustumCorners.SetRow(<span class="hljs-number">2</span>, topRight);<br>frustumCorners.SetRow(<span class="hljs-number">3</span>, topLeft);<br><br>material.SetMatrix(<span class="hljs-string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);<br><br>material.SetFloat(<span class="hljs-string">&quot;_FogDensity&quot;</span>, fogDensity);<br>material.SetColor(<span class="hljs-string">&quot;_FogColor&quot;</span>, fogColor);<br>material.SetFloat(<span class="hljs-string">&quot;_FogStart&quot;</span>, fogStart);<br>material.SetFloat(<span class="hljs-string">&quot;_FogEnd&quot;</span>, fogEnd);<br><br>material.SetTexture(<span class="hljs-string">&quot;_NoiseTex&quot;</span>, noiseTexture);<br>material.SetFloat(<span class="hljs-string">&quot;_FogXSpeed&quot;</span>, fogXSpeed);<br>material.SetFloat(<span class="hljs-string">&quot;_FogYSpeed&quot;</span>, fogYSpeed);<br>material.SetFloat(<span class="hljs-string">&quot;_NoiseAmount&quot;</span>, noiseAmount);<br><br>Graphics.Blit (src, dest, material);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>fogDensity 用于控制雾的浓度，fogColor 用于控制雾的颜色。我们使用的雾效模拟函数是基于高度的，因此参数 fogStart 用于控制雾效的起始高度，fogEnd 用于控制雾效的终止高度。noiseTexture 是我们使用的噪声纹理，fogXSpeed 和 fogYSpeed 分别对应了噪声纹理在 X 和 Y 方向上的移动速度，以此来模拟雾的飘动效果。最后，noiseAmount 用于控制噪声程度，当 noiseAmount 为 0 时，表示不应用任何噪声，即得到一个均匀的基于高度的全局雾效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter15/Chapter15-FogWithNoise&quot; &#123;<br><br>    Properties &#123;<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _FogDensity (&quot;Fog Density&quot;, Float) = 1.0<br>        _FogColor (&quot;Fog Color&quot;, Color) = (1, 1, 1, 1)<br>        _FogStart (&quot;Fog Start&quot;, Float) = 0.0<br>        _FogEnd (&quot;Fog End&quot;, Float) = 1.0<br>        _NoiseTex (&quot;Noise Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _FogXSpeed (&quot;Fog Horizontal Speed&quot;, Float) = 0.1<br>        _FogYSpeed (&quot;Fog Vertical Speed&quot;, Float) = 0.1<br>        _NoiseAmount (&quot;Noise Amount&quot;, Float) = 1<br>    &#125;<br>    SubShader &#123;<br>        CGINCLUDE<br>        <br>        #include &quot;UnityCG.cginc&quot;<br>        <br>        float4x4 _FrustumCornersRay;<br>        <br>        sampler2D _MainTex;<br>        half4 _MainTex_TexelSize;<br>        sampler2D _CameraDepthTexture;<br>        half _FogDensity;<br>        fixed4 _FogColor;<br>        float _FogStart;<br>        float _FogEnd;<br>        sampler2D _NoiseTex;<br>        half _FogXSpeed;<br>        half _FogYSpeed;<br>        half _NoiseAmount;<br>        <br>        struct v2f &#123;<br>            float4 pos : SV_POSITION;<br>            float2 uv : TEXCOORD0;<br>            float2 uv_depth : TEXCOORD1;<br>            float4 interpolatedRay : TEXCOORD2;<br>        &#125;;<br>        <br>        v2f vert(appdata_img v) &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br>            <br>            o.uv = v.texcoord;<br>            o.uv_depth = v.texcoord;<br>            <br>            #if UNITY_UV_STARTS_AT_TOP<br>            if (_MainTex_TexelSize.y &lt; 0)<br>            o.uv_depth.y = 1 - o.uv_depth.y;<br>            #endif<br>            <br>            int index = 0;<br>            if (v.texcoord.x &lt; 0.5 &amp;&amp; v.texcoord.y &lt; 0.5) &#123;<br>                index = 0;<br>                &#125; else if (v.texcoord.x &gt; 0.5 &amp;&amp; v.texcoord.y &lt; 0.5) &#123;<br>                index = 1;<br>                &#125; else if (v.texcoord.x &gt; 0.5 &amp;&amp; v.texcoord.y &gt; 0.5) &#123;<br>                index = 2;<br>                &#125; else &#123;<br>                index = 3;<br>            &#125;<br>            #if UNITY_UV_STARTS_AT_TOP<br>            if (_MainTex_TexelSize.y &lt; 0)<br>            index = 3 - index;<br>            #endif<br>            <br>            o.interpolatedRay = _FrustumCornersRay[index];<br>            <br>            return o;<br>        &#125;<br>        <br>        fixed4 frag(v2f i) : SV_Target &#123;<br>            float linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));<br>            float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;<br>            <br>            float2 speed = _Time.y * float2(_FogXSpeed, _FogYSpeed);<br>            float noise = (tex2D(_NoiseTex, i.uv + speed).r - 0.5) * _NoiseAmount;<br>            <br>            float fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); <br>            fogDensity = saturate(fogDensity * _FogDensity * (1 + noise));<br>            <br>            fixed4 finalColor = tex2D(_MainTex, i.uv);<br>            finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);<br>            <br>            return finalColor;<br>        &#125;<br>        <br>        ENDCG<br>        <br>        Pass &#123;          <br>            CGPROGRAM  <br>            <br>            #pragma vertex vert  <br>            #pragma fragment frag  <br>            <br>            ENDCG<br>        &#125;<br>    &#125; <br>    FallBack Off<br>&#125;<br></code></pre></td></tr></table></figure><p>在片元着色器中，我们首先根据深度纹理来重建该像素在世界空间中的位置。然后，我们利用内置的 _Time.y 变量和 _FogXSpeed、_FogYSpeed 属性计算出当前噪声纹理的偏移量，并据此对噪声纹理进行采样，得到噪声值。随后，我们把该噪声值添加到雾效浓度的计算中，得到应用噪声后的雾效混合系数 fogDensity。最后，我们使用该系数将雾的颜色和原始颜色进行混合后返回。</p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Texture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>非真实感渲染</title>
    <link href="/posts/%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/"/>
    <url>/posts/%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<p>尽管游戏渲染一般都是以**照相写实主义（photorealism）<strong>作为主要目标，但也有许多游戏使用了</strong>非真实感渲染（Non-Photorealistic Rendering，NPR）**的方法来渲染游戏画面。非真实感渲染的一个主要目标是，使用一些渲染方法使得画面达到和某些特殊的绘画风格相似的效果，例如卡通、水彩风格等。</p><h2 id="卡通风格的渲染">卡通风格的渲染</h2><p>卡通风格是游戏中常见的一种渲染风格。使用这种风格的游戏画面通常有一些共有的特点，例如物体都被黑色的线条描边，以及分明的明暗变化等。</p><p>要实现卡通渲染有很多方法，其中之一就是使用**基于色调的着色技术（tone-based shading）。在实现中，我们往往会使用漫反射系数对一张一维纹理进行采样，以控制漫反射的色调，高光效果也和之前学习的光照不同。在卡通风格中，模型的高光往往是一块块分界明显的纯色区域。</p><p>除了光照模型不同外，卡通风格通常还需要在物体边缘部分绘制轮廓。之前我们使用屏幕后处理技术对屏幕图像进行描边，这次我们将介绍基于模型的描边方法，这种方法的实现更加简单，而且在很多情况下也能得到不错的效果。</p><h3 id="渲染轮廓线">渲染轮廓线</h3><p>在实时渲染中，轮廓线的渲染是应用非常广泛的一种效果。近 20 年来，有许多绘制模型轮廓线的方法被先后提出来。在《Real Time Rendering，third edition》一书中，作者把这些方法分成了 5 种类型。</p><ul><li>基于观察角度和表面法线的轮廓线渲染。这种方法使用视角方向和表面法线的点乘结果来得到轮廓线的信息。这种方法简单快速，可以在一个 Pass 中就得到渲染结果，但局限性很大，很多模型渲染出来的描边效果都不尽如人意。</li><li>过程式几何轮廓线渲染。这种方法的核心是使用两个 Pass 渲染。第一个 Pass 渲染背面的面片，并使用某些技术让它的轮廓可见；第二个 Pass 再正常渲染正面的面片。这种方法的优点在于快速有效，并且适用于绝大多数表面平滑的模型，但它的缺点是不适合类似于立方体这样平整的模型。</li><li>基于图像处理的轮廓线渲染。这种方法的优点在于，可以适用于任何种类的模型。但它也有自身的局限所在，一些深度和法线变化很小的轮廓无法被检测出来，例如桌子上的纸张。</li><li>基于轮廓边检测的轮廓线渲染。上面提到的各种方法，一个最大的问题是，无法控制轮廓线的风格渲染。对与一些情况，我们希望可以渲染出独特风格的轮廓线，例如水墨风格等。为此，我们希望可以检测出精确的轮廓边，然后直接渲染它们。检测一条边是否是轮廓边的公式很简单，我们只需要检查和这条边相邻的两个三角面片是否满足以下条件：<br>$$<br>(n_0 \cdot v &gt; 0) \neq (n_1 \cdot v &gt; 0)<br>$$<br>其中，$n_0$ 和 $n_1$ 分别表示两个相邻三角面片的法向，$v$ 是从视角到该边上任意顶点的方向。上述公式的本质在于检查两个相邻的三角面片是否一个朝正面、一个朝背面。我们可以在几何着色器（Geometry Shader）的帮助下实现上面的检测过程。当然，这种方法也有缺点，除了实现相对复杂外，它还会有动画连贯性的问题。也就是说，由于是逐帧单独提取轮廓，所以在帧与帧之间会出现跳跃性。</li><li>最后一个种类就是混合了上述的几种渲染方法，例如，首先找到精确的轮廓边，把模型和轮廓边渲染到纹理中，再使用图像处理的方法识别出轮廓线，并在图像空间下进行风格化渲染。</li></ul><p>下面，我们将使用过程式几何轮廓线渲染的方法来对模型进行轮廓描边。我们将使用两个 Pass 渲染模型：在第一个 Pass 中，我们会使用轮廓线颜色渲染整个背面的面片，并在视角空间下把模型顶点沿着法线方向向外扩张一段距离，以此来让背部轮廓线可见。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">viewPos = viewPos + viewNormal * _Outline;<br></code></pre></td></tr></table></figure><p>但是，如果直接使用顶点法线进行扩展，对于一些内凹的模型，就可能发生背面面片遮挡正面面片的情况。为了尽可能防止出现这样的情况，在扩张背面顶点之前，我们首先对顶点法线的 z 分量进行处理，使它们等于一个定值，然后把法线归一化后再对顶点进行扩张。这样的好处在于，扩展后的背面更加扁平化，从而降低了遮挡正面面片的可能性。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">viewNormal.z = -0.5;<br>viewNormal = normalize(viewNormal);<br>viewPos = viewPos + viewNormal * _Outline;<br></code></pre></td></tr></table></figure><h3 id="添加高光">添加高光</h3><p>前面提到过，卡通风格中的高光往往是模型上一块块分界明显的纯色区域。为了实现这种效果，我们就不能再使用之前学习的光照模型。回顾一下，在之前实现 Blinn-Phong 模型的过程中，我们使用法线点乘光照方向以及视角方向和的一半，再和另一个参数进行指数操作得到高光反射系数。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float spec = pow(max(0, dot(normal, halfDir)), _Gloss)<br></code></pre></td></tr></table></figure><p>对于卡通渲染需要的高光反射光照模型，我们同样需要计算 normal 和 halfDir 的点乘结果，但不同的是，我们把该值和一个阈值进行比较，如果小于该阈值，则高光反射系数为 0，否则返回 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float spec = dot(worldNormal, worldHalfDir);<br>spec = step(threshold, spec);<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用 CG 的 <strong>step 函数</strong>来实现和阈值比较的目的。step 函数接受两个参数，第一个参数是参考值，第二个参数是待比较的数值。如果第二个参数大于等于第一个参数，则返回 1，否则返回 0。</p><p>但是，这种粗暴的判断方法会在高光区域的边界造成锯齿，如下图所示。出现这种问题的原因是，高光区域的边缘不是平滑渐变的，而是由 0 突变到 1。要想对其进行抗锯齿处理，我们可以在边界处很小的一块区域内，进行平滑处理。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float spec = dot(worldNormal, worldHalfDir);<br>spec = lerp(0, 1, smoothstep(-w, w, spec - threshold));<br></code></pre></td></tr></table></figure><p><img src="/posts_image/Non-Photorealistic_Rendering/Non-Photorealistic_Rendering_1.png" alt="抗锯齿" title="抗锯齿"></p><p>在上面的代码中，我们没有像之前一样直接使用 step 函数返回 0 或 1，而是首先使用了 CG 的 <strong>smoothstep 函数</strong>。其中，w 是一个很小的值，当 spec - threshold 小于 -w 时，返回 0，大于 w 时，返回 1，否则在 0 到 1 之间进行插值。这样的效果是，我们可以在 [-w, w] 区间内，即高光区域的边界处，得到一个从 0 到 1 平滑变化的 spec 值，从而实现抗锯齿的目的。尽管我们可以把 w 设为一个很小的定值，但在本例中，我们选择使用邻域像素之间的近似导数值，这可以通过 CG 的 <strong>fwidth 函数</strong> 来得到。</p><h3 id="实现">实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br>// Upgrade NOTE: replaced &#x27;_World2Object&#x27; with &#x27;unity_WorldToObject&#x27;<br>// Upgrade NOTE: replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;<br><br>Shader &quot;Custom/Chapter14/Chapter14-ToonShading&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (1,1,1,1)<br>        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Ramp (&quot;Ramp Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Outline (&quot;Outline&quot;, Range(0, 1)) = 0.1<br>        _OutlineColor (&quot;Outline Color&quot;, Color) = (0, 0, 0, 1)<br>        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)<br>        _SpecularScale (&quot;Specular Scale&quot;, Range(0, 0.1)) = 0.01<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot; &#125;<br>        Pass &#123;<br>            NAME &quot;OUTLINE&quot;<br><br>            Cull Front<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br>            <br>            #include &quot;UnityCG.cginc&quot;<br><br>            float _Outline;<br>            fixed4 _OutlineColor;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>            &#125;;<br><br>            v2f vert (a2v v) &#123;<br>                v2f o;<br>                float4 pos = mul(UNITY_MATRIX_MV, v.vertex);<br>                float3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);<br>                normal.z = -0.5;<br>                pos = pos + float4(normalize(normal), 0) * _Outline;<br>                o.pos = mul(UNITY_MATRIX_P, pos);<br>                return o;<br>            &#125;<br><br>            float4 frag(v2f i) : SV_TARGET &#123;<br>                return float4(_OutlineColor.rgb, 1);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br><br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>            Cull Back<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #pragma multi_compile_fwdbase<br><br>            #include &quot;UnityCG.cginc&quot;<br>            #include &quot;Lighting.cginc&quot;<br>            #include &quot;AutoLight.cginc&quot;<br>            #include &quot;UnityShaderVariables.cginc&quot;<br><br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            sampler2D _Ramp;<br>            fixed4 _Specular;<br>            fixed _SpecularScale;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>                float4 tangent : TANGENT;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : POSITION;<br>                float2 uv : TEXCOORD0;<br>                float3 worldNormal : TEXCOORD1;<br>                float3 worldPos : TEXCOORD2;<br>                SHADOW_COORDS(3)<br>            &#125;;<br><br>            v2f vert (a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                TRANSFER_SHADOW(o);<br>                return o;<br>            &#125;<br><br>            float4 frag(v2f i) : SV_TARGET &#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));<br>                fixed3 worldHalfDir = normalize(worldLightDir + worldViewDir);<br><br>                fixed4 c = tex2D(_MainTex, i.uv);<br>                fixed3 albedo = c.rgb * _Color.rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br>                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br>                fixed diff = dot(worldNormal, worldLightDir);<br>                diff = (diff * 0.5 + 0.5) * atten;<br><br>                fixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb;<br><br>                fixed spec = dot(worldNormal, worldHalfDir);<br>                fixed w = fwidth(spec) * 2.0;<br>                fixed3 specular = _Specular.rgb * lerp(0, 1, smoothstep(-w, w, spec + _SpecularScale -1)) * step(0.0001, _SpecularScale);<br><br>                return fixed4(ambient + diffuse + specular, 1.0);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Diffuse&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>_Ramp 是用于控制漫反射色调的渐变纹理，_Outline 用于控制轮廓线宽度，_OutlineColor 对应了轮廓线颜色，_Specular 是高光反射颜色，_SpecularScale 用于控制计算高光反射时使用的阈值。</p><p>在第一个 Pass 中渲染轮廓线。这个 Pass 只渲染背面的三角面片，因此我们使用 Cull 指令把正面的三角面片剔除。我们还使用 NAME 命令为该 Pass 定义了名称。这是因为，描边在非真实感渲染中是非常常见的效果，为该 Pass 定义名称可以让我们在后面的使用中不需要再重复编写此 Pass，而只需要调用它的名字即可。在顶点着色器中我们首先把顶点和法线变换到视角空间下，这是为了让描边可以在观察空间达到最好的效果。随后，我们设置法线的 z 分量，对其归一化后再将顶点沿其方向扩张，得到扩张后的顶点坐标。对法线的处理是为了尽可能避免背面扩张后的顶点挡住正面的面片。最后，我们把顶点从视角空间变换到裁剪空间。片元着色器代码非常简单，我们只需要用轮廓线颜色渲染整个背面即可。</p><p>在第二个 Pass 中定义光照模型，以渲染模型的正面。首先，我们计算了光照模型中需要的各个方向矢量，并对它们进行了归一化处理。然后，我们计算了材质的反射率 albedo 和环境光照 ambient。接着，我们使用内置的 UNITY_LIGHT_ATTENUATION 宏来计算当前世界坐标下的阴影值。随后，我们计算了半兰伯特漫反射系数，并和阴影值相乘得到最终的漫反射系数。我们使用这个漫反射系数对渐变纹理 _Ramp 进行采样，并将结果和材质的反射率、光照颜色相乘，作为最后的漫反射光照。高光反射的计算和上面介绍的方法一致，我们使用 fwidth 对高光区域的边界进行抗锯齿处理，并将计算而得的高光反射系数和高光反射颜色相乘，得到高光反射的光照部分。值得注意的是，我们在最后还使用了step(0.0001, _SpecularScale)，这是为了在 _SpecularScale 为 0 时，可以完全消除高光反射的光照。最后，返回环境光照、漫反射光照和高光反射光照叠加的结果。</p><p><img src="/posts_image/Non-Photorealistic_Rendering/Non-Photorealistic_Rendering_2.png" alt="卡通风格的渲染效果" title="卡通风格的渲染效果"></p><h2 id="素描风格的渲染">素描风格的渲染</h2><p>另一个非常流行的非真实感渲染是素描风格的渲染。我们可以使用提前生成的素描纹理来实现实时的素描风格渲染，这些纹理组成了一个**色调艺术映射（Tonal Art Map，TAM），如下图所示。在图中，从左到右纹理中的笔触逐渐增多，用于模拟不同光照下的漫反射效果，从上到下则对应了每张纹理的多级渐远纹理（mipmaps）。这些多级渐远纹理的生成并不是简单的对上一层纹理进行降采样，而是需要保持笔触之间的间隔，以便更真实地模拟素描效果。</p><p><img src="/posts_image/Non-Photorealistic_Rendering/Non-Photorealistic_Rendering_3.png" alt="一个TAM的例子" title="一个TAM的例子"></p><p>本节将会实现简化版的算法，不考虑多级渐远纹理的生成，而是直接使用 6 张素描纹理进行渲染。在渲染阶段，我们首先在顶点着色阶段计算逐顶点的光照，根据光照结果来决定 6 张纹理的混合权重，并传递给片元着色器。然后，在片元着色器中根据这些权重来混合 6 张纹理的采样结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br>// Upgrade NOTE: replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;<br><br>Shader &quot;Custom/Chapter14/Chapter14-Hatching&quot; &#123;<br><br>    Properties &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (1,1,1,1)<br>        _TileFactor (&quot;Tile Factor&quot;, Float) = 1<br>        _Outline (&quot;Outline&quot;, Range(0, 1)) = 0.1<br>        _Hatch0 (&quot;Hatch 0&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Hatch1 (&quot;Hatch 1&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Hatch2 (&quot;Hatch 2&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Hatch3 (&quot;Hatch 3&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Hatch4 (&quot;Hatch 4&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Hatch5 (&quot;Hatch 5&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>    &#125;<br><br>    SubShader &#123;<br>        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;<br><br>        UsePass &quot;Custom/Chapter14/Chapter14-ToonShading/OUTLINE&quot;<br><br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br>            <br>            CGPROGRAM<br>            <br>            #pragma vertex vert<br>            #pragma fragment frag <br>            <br>            #pragma multi_compile_fwdbase<br>            <br>            #include &quot;UnityCG.cginc&quot;<br>            #include &quot;Lighting.cginc&quot;<br>            #include &quot;AutoLight.cginc&quot;<br>            #include &quot;UnityShaderVariables.cginc&quot;<br><br>            fixed4 _Color;<br>            float _TileFactor;<br>            sampler2D _Hatch0;<br>            sampler2D _Hatch1;<br>            sampler2D _Hatch2;<br>            sampler2D _Hatch3;<br>            sampler2D _Hatch4;<br>            sampler2D _Hatch5;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float4 tangent : TANGENT;<br>                float3 normal : NORMAL;<br>                float2 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float2 uv : TEXCOORD0;<br>                fixed3 hatchWeights0 : TEXCOORD1;<br>                fixed3 hatchWeights1 : TEXCOORD2;<br>                float3 worldPos : TEXCOORD3;<br>                SHADOW_COORDS(4)<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.uv = v.texcoord.xy * _TileFactor;<br>                fixed3 worldLightDir = normalize(WorldSpaceLightDir(v.vertex));<br>                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);<br>                fixed diff = max(0, dot(worldLightDir, worldNormal));<br><br>                o.hatchWeights0 = fixed3(0, 0, 0);<br>                o.hatchWeights1 = fixed3(0, 0, 0);<br><br>                float hatchFactor = diff * 7.0;<br><br>                if (hatchFactor &gt; 6.0) &#123;<br>                    //Pure white, do nothing<br>                    &#125; else if (hatchFactor &gt; 5.0) &#123;<br>                    o.hatchWeights0.x = hatchFactor - 5.0;<br>                    &#125; else if (hatchFactor &gt; 4.0) &#123;<br>                    o.hatchWeights0.x = hatchFactor - 4.0;<br>                    o.hatchWeights0.y = 1.0 - o.hatchWeights0.x;<br>                    &#125; else if (hatchFactor &gt; 3.0) &#123;<br>                    o.hatchWeights0.y = hatchFactor - 3.0;<br>                    o.hatchWeights0.z = 1.0 - o.hatchWeights0.y;<br>                    &#125; else if (hatchFactor &gt; 2.0) &#123;<br>                    o.hatchWeights0.z = hatchFactor - 2.0;<br>                    o.hatchWeights1.x = 1.0 - o.hatchWeights0.z;<br>                    &#125; else if (hatchFactor &gt; 1.0) &#123;<br>                    o.hatchWeights1.x = hatchFactor - 1.0;<br>                    o.hatchWeights1.y = 1.0 - o.hatchWeights1.x;<br>                    &#125; else &#123;<br>                    o.hatchWeights1.y = hatchFactor;<br>                    o.hatchWeights1.z = 1.0 - o.hatchWeights1.y;<br>                &#125;<br><br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br>                TRANSFER_SHADOW(o);<br><br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET &#123;<br>                fixed4 hatchTex0 = tex2D(_Hatch0, i.uv) * i.hatchWeights0.x;<br>                fixed4 hatchTex1 = tex2D(_Hatch1, i.uv) * i.hatchWeights0.y;<br>                fixed4 hatchTex2 = tex2D(_Hatch2, i.uv) * i.hatchWeights0.z;<br>                fixed4 hatchTex3 = tex2D(_Hatch3, i.uv) * i.hatchWeights1.x;<br>                fixed4 hatchTex4 = tex2D(_Hatch4, i.uv) * i.hatchWeights1.y;<br>                fixed4 hatchTex5 = tex2D(_Hatch5, i.uv) * i.hatchWeights1.z;<br><br>                fixed4 whiteColor = fixed4(1,1,1,1) * (1 - i.hatchWeights0.x - i.hatchWeights0.y - i.hatchWeights0.z - i.hatchWeights1.x - i.hatchWeights1.y - i.hatchWeights1.z);<br>                fixed4 hatchColor = hatchTex0 + hatchTex1 + hatchTex2 + hatchTex3 + hatchTex4 + hatchTex5 + whiteColor;<br><br>                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br>                return fixed4(hatchColor.rgb * _Color.rgb * atten, 1.0);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    FallBack &quot;Diffuse&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中，_Color 是用于控制模型颜色的属性。_TileFactor 是纹理的平铺系数，_TileFactor 越大，模型上的素描线条越密。_Hatch0 至 _Hatch5 对应了渲染时使用的 6 张素描纹理，它们的线条密度依次增大。由于一共声明了 6 张纹理，这意味着需要 6 个混合权重，我们把它们存储在两个 fixed3 类型的变量（hatchWeights0 和 hatchWeights1）中。为了添加阴影效果，我们还声明了 worldPos 变量，并使用 SHADOW_COORDS 宏声明了阴影纹理的采样坐标。</p><p>在顶点着色器中，我们首先对顶点进行了基本的坐标变换。然后，使用 _TileFactor 得到了纹理采样坐标。在计算 6 张纹理的混合权重之前，我们首先需要计算逐顶点光照。因此，我们使用世界空间下的光照方向和法线方向得到漫反射系数 diff。之后，我们把权重值初始化为 0，并把 diff 缩放到[0, 7]范围，得到 hatchFactor。我们把[0, 7]的区间均匀划分为 7 个子区间，通过判断 hatchFactor 所处的子区间来计算对应的纹理混合权重。最后，我们计算了顶点的世界坐标，并使用 TRANSFER_SHADOW 宏来计算阴影纹理的采样坐标。</p><p>在片元着色器中，当得到了 6 张纹理的混合权重后，我们对每张纹理进行采样并和它们对应的权重值相乘得到每张纹理的采样颜色。我们还计算了纯白在渲染中的贡献度，这是通过从 1 中减去所有 6 张纹理的权重来得到的。这是因为素描中往往有留白的部分，因此我们希望在最后的渲染中光照最亮的部分是纯白色的。最后，我们混合了各个颜色值，并和阴影值 atten、模型颜色 _Color 相乘后返回最终的渲染结果。</p><p><img src="/posts_image/Non-Photorealistic_Rendering/Non-Photorealistic_Rendering_4.png" alt="素描风格的渲染效果" title="素描风格的渲染效果"></p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rendering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度和法线纹理</title>
    <link href="/posts/%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86/"/>
    <url>/posts/%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="获取深度和法线纹理">获取深度和法线纹理</h2><h3 id="背后的原理">背后的原理</h3><p>深度纹理实际上就是一张渲染纹理，只不过它里面存储的像素值不是颜色值，而是一个高精度的深度值。由于被存储在一张纹理中，深度纹理里的深度值范围是[0, 1]，而且通常是非线性分布的。这些深度值来自于顶点变换后得到的归一化的设备坐标（Normalized Device Coordinates，NDC）。想要在屏幕上绘制一个模型，需要把模型顶点在顶点着色器中乘以 MVP 变换矩阵，将顶点从模型空间变换到齐次裁剪坐标系下。在变换的最后一步，我们使用一个投影矩阵来变换顶点，如果我们使用的是透视投影类型的摄像机，那这个投影矩阵就是非线性的。</p><p>下图显示了 Unity 中透视投影对顶点的变换过程。最左侧的图显示了投影变换前，即观察空间下视锥体的结构及相应的顶点位置，中间的图显示了应用透视裁剪矩阵后的变换结果，即顶点着色器阶段输出的顶点变换结果，最右侧的图则是底层硬件进行了透视除法后得到的归一化的设备坐标。需要注意的是，这里的投影过程是建立在 Unity 对坐标系的假定上的，也就是说，我们针对的是观察空间为右手坐标系，使用列矩阵在矩阵右侧进行相乘，且变换到 NDC 后 z 分量范围将在[-1, 1]之间的情况。而在类似 DirectX 这样的图形接口中，变换后 z 分量范围将在[0, 1]之间。如果需要在其他图形接口下实现本章的类似效果，需要对一些计算参数做出相应变化。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_1.png" alt="透视投影" title="透视投影"></p><p>下图显示了在使用正交摄像机时投影变换的过程。同样，变换后会得到一个范围为[-1, 1]的立方体。正交投影使用的变换矩阵是线性的。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_2.png" alt="正交投影" title="正交投影"></p><p>在得到 NDC 后，深度纹理中的像素值就可以很方便地计算得到了，这些深度值就对应了 NDC 中顶点坐标的 z 分量的值。由于 NDC 中 z 分量的范围在[-1, 1]，为了让这些值能够存储在一张图像中，我们需要使用下面的公式对其进行映射：<br>$$<br>d = 0.5 \cdot z_{ndc} + 0.5<br>$$<br>其中，$d$ 对应了深度纹理中的像素值，$z_{ndc}$ 对应了 NDC 坐标中的 z 分量的值。</p><p>那么 Unity 如何得到这样一张深度纹理呢？在 Unity 中，深度纹理可以直接来自于真正的深度缓存，也可以由一个单独的 Pass 渲染而得，这取决于使用的渲染路径和硬件。通常来讲，当使用延迟渲染路径（包括遗留的渲染路径）时，深度纹理理所当然的可以访问到，因为延迟渲染会把这些信息渲染到 G-buffer 中。而当无法直接获取深度缓存时，深度和法线纹理是通过一个单独的 Pass 渲染而得的。具体实现是，Unity 会使用着色器替换（Shader Replacement）技术选择那些渲染类型（即 SubShader 的 RenderType 标签）为 Opaque 的物体，判断它们使用的渲染队列是否小于等于 2500（内置的 Background、Geometry 和 AlphaTest 渲染队列均在此范围内），如果满足条件，就把它渲染到深度和法线纹理中。因此，想要让物体能够出现在深度和法线纹理中，就必须在 Shader 中<strong>设置正确的 RenderType 标签</strong>。</p><p>在 Unity 中，我们可以选择让一个摄像机生成一张深度纹理或是一张深度+法线纹理。当只需要一张单独的深度纹理时，Unity 会直接获取深度缓存或是按之前讲到的着色器替换技术，选取需要的不透明物体，并使用它投射阴影时使用的 Pass（即 LightMode 被设置为 ShadowCaster 的 Pass）来得到深度纹理。如果 Shader 中不包含这样一个 Pass，那么这个物体就不会出现在深度纹理中（当然，它也不能向其他物体投射阴影）。深度纹理的精度通常是 24 位或 16 位，这取决于使用的深度缓存的精度。如果选择生成一张深度+法线纹理，Unity 会创建一张和屏幕分辨率相同、精度为 32 位（每个通道为 8 位）的纹理，其中观察空间下的法线信息会被编码进纹理的 R 和 G 通道，而深度信息会被编码进 B 和 A 通道。法线信息的获取在延迟渲染中是可以非常容易就得到的，Unity 只需要合并深度和法线缓存即可。而在前向渲染中，默认情况下是不会创建法线缓存的，因此 Unity 底层使用了一个单独的 Pass 把整个场景再次渲染一遍来完成。</p><h3 id="如何获取">如何获取</h3><p>在 Unity 中，获取深度纹理是非常简单的，我们在脚本中设置摄像机的 depthTextureMode 后，就可以在 Shader 中直接访问特定的纹理属性。例如我们可以通过下面的代码来获取深度纹理：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">camera.depthTextureMode = DepthTextureMode.Depth;<br></code></pre></td></tr></table></figure><p>一旦设置好了上面的摄像机模式后，我们就可以在 Shader 中通过声明 _CameraDepthTexture 变量来访问它。</p><p>同理，如果想要获取深度+法线纹理，我们只需要在代码中这样设置：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">camera.depthTextureMode = DepthTextureMode.DepthNormals;<br></code></pre></td></tr></table></figure><p>然后在 Shader 中通过声明 _CameraDepthNormalsTexture 变量来访问它。</p><p>我们还可以组合这些模式，让一个摄像机同时产生一张深度和深度+法线纹理：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">camera.depthTextureMode |= DepthTextureMode.Depth;<br>camera.depthTextureMode |= DepthTextureMode.DepthNormals;<br></code></pre></td></tr></table></figure><p>我们还可以在摄像机的 Camera 组件上看到当前摄像机是否需要渲染深度或深度+法线纹理。当在 Shader 中访问到深度纹理 _CameraDepthTexture 后，我们就可以使用当前像素的纹理坐标对它进行采样。绝大多数情况下，我们直接使用 tex2D 函数采样即可，但在某些平台（例如 PS3 和 PSP2 ）上，我们需要一些特殊处理。Unity 为我们提供了一个统一的宏 SAMPLE_DEPTH_TEXTURE，用来处理这些由于平台差异造成的问题。而我们只需要在 Shader 中使用 SAMPLE_DEPTH_TEXTURE 宏对深度纹理进行采样，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv);<br></code></pre></td></tr></table></figure><p>其中，i.uv 是一个 float2 类型的变量，对应了当前像素的纹理坐标。类似的宏还有 SAMPLE_DEPTH_TEXTURE_PROJ 和 SAMPLE_DEPTH_TEXTURE_LOD。SAMPLE_DEPTH_TEXTURE_PROJ 宏同样接受两个参数——深度纹理和一个 float3 或 float4 类型的纹理坐标，它的内部使用了 tex2Dproj 这样的函数进行投影纹理采样，纹理坐标的前两个分量首先会除以最后一个分量，再进行纹理采样。如果提供了第四个分量，还会进行一次比较，通常用于阴影的实现中。SAMPLE_DEPTH_TEXTURE_PROJ 的第二个参数通常是由顶点着色器输出插值而得的屏幕坐标，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float d = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.scrPos));<br></code></pre></td></tr></table></figure><p>其中，i.scrPos 是在顶点着色器中通过调用 ComputeScreenPos(o.pos) 得到的屏幕坐标。上述这些宏的定义我们可以在 Unity 内置的 HLSLSupport.cginc 文件中找到。</p><p>当通过纹理采样得到深度值后，这些深度值往往是非线性的，这种非线性来自于透视投影使用的裁剪矩阵。然而，在我们的计算过程中通常需要线性的深度值，因此我们需要把投影后的深度值变换到线性空间下，例如视角空间下的深度值。那么，我们应该如何进行这个转换呢？实际上，我们只需要倒推顶点变换的过程即可。下面我们以透视投影为例，推导如何由深度纹理中的深度信息计算得到视角空间下的深度值。</p><p>当我们使用透视投影的裁剪矩阵 $P_{clip}$ 对视角空间下的一个顶点进行变换后，裁剪空间下的顶点的 z 和 w 分量为：</p><p>$$<br>z_{clip} = -z_{view}\frac{Far + Near}{Far - Near} - \frac{2 \cdot Near \cdot Far}{Far - Near}<br>$$<br>$$<br>w_{clip} = -z_{view}<br>$$</p><p>其中，$Far$ 和 $Near$ 分别是远近裁剪平面的距离。然后，我们通过齐次除法就可以得到 NDC 下的 z 分量：</p><p>$$<br>z_{ndc} = \frac{z_{clip}}{w_{clip}} = \frac{Far + Near}{Far - Near} + \frac{2 \cdot Near \cdot Far}{(Far - Near) \cdot z_{view}}<br>$$</p><p>深度纹理中的深度值是通过下面的公式由 NDC 计算而得的：<br>$$<br>d = 0.5 \cdot z_{ndc} + 0.5<br>$$<br>由上面的这些式子，我们可以推导出用 $d$ 表示而得的 $z_{view}$ 的表达式：<br>$$<br>z_{view} = \frac{1}{\frac{Far - Near}{Near \cdot Far}d - \frac{1}{Near}}<br>$$<br>由于在 Unity 使用的视角空间中，摄像机正向对应的 z 值均为负值，因此为了得到深度值的正数表示，我们需要对上面的结果取反，最后得到的结果如下：<br>$$<br>z_{view}^{'} = \frac{1}{\frac{Near - Far}{Near \cdot Far}d + \frac{1}{Near}}<br>$$<br>它的取值范围就是视锥体深度范围，即[Near, Far]。如果我们想得到范围在[0, 1]之间的深度值，只需要把上面得到的结果除以 Far 即可。这样，0 就表示该点与摄像机位于同一位置，1 表示该点位于视锥体的远裁剪平面上。结果如下：<br>$$<br>z_{01} = \frac{1}{\frac{Near - Far}{Near}d + \frac{Far}{Near}}<br>$$</p><p>Unity 提供了两个辅助函数来为我们进行上述的计算过程——LinearEyeDepth 和 Linear01Depth。LinearEyeDepth 负责把深度纹理采样结果转换到视角空间下的深度值，也就是我们上面得到的 $z_{view}^{'}$。而 Linear01Depth 则会返回一个范围在[0, 1]的线性深度值，也就是我们上面得到的 $z_{01}$。这两个函数内部使用了内置的 _ZBufferParams 变量来得到远近裁剪平面的距离。</p><p>如果我们需要获取深度+法线纹理，可以直接使用 tex2D 函数对 _CameraDepthNormalsTexture 进行采样，得到里面存储的深度和法线信息。Unity 提供了辅助函数来为我们对这个采样结果进行解码，从而得到深度值和法线方向。这个函数是 DecodeDepthNormal，它在 UnityCG.cginc 里被定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">inline void DecodeDepthNormal(float4 enc, out float depth, out float3 normal)&#123;<br>    depth = DecodeFloatRG(enc.zw);<br>    normal = DecodeViewNormalStereo(enc);<br>&#125;<br></code></pre></td></tr></table></figure><p>DecodeDepthNormal 的第一个参数是对深度+法线纹理的采样结果，这个采样结果是 Unity 对深度和法线信息编码后的结果，它的 xy 分量存储的是视角空间下的法线信息，而深度信息被编码进了 zw 分量。通过调用 DecodeDepthNormal 函数对采样结果解码后，我们就可以得到解码后的深度值和法线。这个深度值是范围在[0, 1]的线性深度值（这与单独的深度纹理中存储的深度值不同），而得到的法线则是视角空间下的法线方向。同样，我们也可以通过调用 DecodeFloatRG 和 DecodeViewNormalStereo 来解码深度+法线纹理中的深度和法线信息。</p><h3 id="查看深度和法线纹理">查看深度和法线纹理</h3><p>下图显示了使用帧调试器查看到的深度纹理和深度+法线纹理。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_3.png" alt="帧调试器查看深度和法线纹理" title="帧调试器查看深度和法线纹理"></p><p>使用帧调试器查看到的深度纹理是非线性空间的深度值，而深度+法线纹理都是由 Unity 编码后的结果。有时，显示出线性空间下的深度信息或解码后的法线方向会更加有用。此时，我们可以自行在片元着色器中输出转换或解码后的深度和法线值，如下图示。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_4.png" alt="线性空间下的深度纹理和解码后并被映射到[0, 1]范围内的视角空间下的法线纹理" title="线性空间下的深度纹理和解码后并被映射到[0, 1]范围内的视角空间下的法线纹理"></p><p>我们可以使用类似下面的代码来输出线性深度值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv);<br>float linearDepth = Linear01Depth(depth);<br>return fixed4(linearDepth, linearDepth, linearDepth, 1.0);<br></code></pre></td></tr></table></figure><p>或是输出法线方向：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">fixed3 normal = DecodeViewNormalStereo(tex2D(_CameraDepthNormalsTexture, i.uv).xy);<br>return fixed4(normal * 0.5 + 0.5, 1.0);<br></code></pre></td></tr></table></figure><p>在查看深度纹理时，得到的画面有可能几乎是全黑或全白的。这时候可以把摄像机的远裁剪平面的距离（Unity 默认为 1000）调小，使视锥体的范围刚好覆盖场景的所在区域。这是因为，由于投影变换时需要覆盖从近裁剪平面到远裁剪平面的所有深度区域，当远裁剪平面的距离过大时，就会导致离摄像机较近的距离被映射到非常小的深度值，如果场景是一个封闭的区域（如上图所示），那么这就会导致画面看起来几乎是全黑的。相反，如果场景是一个开放区域，且物体离摄像机的距离较远，就会导致画面几乎是全白的。</p><h2 id="再谈运动模糊">再谈运动模糊</h2><p>我们以前学习了如何通过混合多张屏幕图像来模拟运动模糊的效果。但是，另一种应用更加广泛的技术则是使用速度映射图。速度映射图中存储了每个像素的速度，然后使用这个速度来决定模糊的方向和大小。速度缓冲的生成有多种方法，一种方法是把场景中所有物体的速度渲染到一张纹理中。但这种方法的缺点在于需要修改场景中所有物体的 Shader 代码，使其添加计算速度的代码并输出到一个渲染纹理中。</p><p>《GPU Gems3》在第27章中介绍了一种生成速度映射图的方法。这种方法利用深度纹理在片元着色器中为每个像素计算其在世界空间下的位置，这是通过使用当前的视角 * 投影矩阵的逆矩阵对 NDC 下的顶点坐标进行变换得到的。当得到世界空间中的顶点坐标后，我们使用前一帧的视角 * 投影矩阵对其进行变换，得到该位置在前一帧中的 NDC 坐标。然后，我们计算前一帧和当前帧的位置差，生成该像素的速度。这种方法的优点是可以在一个屏幕后处理步骤中完成整个效果的模拟，但缺点是需要在片元着色器中进行两次矩阵乘法的操作，对性能有所影响。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MotionBlurWithDepthTexture</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader motionBlurShader;<br><span class="hljs-keyword">private</span> Material motionBlurMaterial = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);<br><span class="hljs-keyword">return</span> motionBlurMaterial;<br>&#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> Camera myCamera;<br><span class="hljs-keyword">public</span> Camera camera &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">if</span> (myCamera == <span class="hljs-literal">null</span>) &#123;<br>myCamera = GetComponent&lt;Camera&gt;();<br>&#125;<br><span class="hljs-keyword">return</span> myCamera;<br>&#125;<br>&#125;<br><br>[<span class="hljs-meta">Range(0.0f, 1.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> blurSize = <span class="hljs-number">0.5f</span>;<br><br><span class="hljs-keyword">private</span> Matrix4x4 previousViewProjectionMatrix;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span> &#123;<br>camera.depthTextureMode |= DepthTextureMode.Depth;<br><br>previousViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_BlurSize&quot;</span>, blurSize);<br><br>material.SetMatrix(<span class="hljs-string">&quot;_PreviousViewProjectionMatrix&quot;</span>, previousViewProjectionMatrix);<br>Matrix4x4 currentViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;<br>Matrix4x4 currentViewProjectionInverseMatrix = currentViewProjectionMatrix.inverse;<br>material.SetMatrix(<span class="hljs-string">&quot;_CurrentViewProjectionInverseMatrix&quot;</span>, currentViewProjectionInverseMatrix);<br>previousViewProjectionMatrix = currentViewProjectionMatrix;<br><br>Graphics.Blit (src, dest, material);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面的 OnRenderImage 函数很简单，我们首先需要计算和传递运动模糊使用的各个属性。本例需要使用两个变换矩阵——前一帧的视角 * 投影矩阵以及当前帧的视角 * 投影矩阵的逆矩阵。因此，我们通过调用 camera.worldToCameraMatrix 和 camera.projectionMatrix 来分别得到当前摄像机的视角矩阵和投影矩阵。对它们相乘后取逆，得到当前帧的视角 * 投影矩阵的逆矩阵，并传递给材质。然后，我们把取逆前的结果存储在 previousViewProjectionMatrix 变量中，以便在下一帧时传递给材质的 _PreviousViewProjectionMatrix 属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter13/Chapter13-MotionBlurWithDepthTexture&quot; &#123;<br><br>    Properties &#123;<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _BlurSize (&quot;Blur Size&quot;, Float) = 1.0<br>    &#125;<br><br>    SubShader &#123;<br>        CGINCLUDE<br>        #include &quot;UnityCG.cginc&quot;<br><br>        sampler2D _MainTex;<br>        half4 _MainTex_TexelSize;<br>        sampler2D _CameraDepthTexture;<br>        float4x4 _CurrentViewProjectionInverseMatrix;<br>        float4x4 _PreviousViewProjectionMatrix;<br>        half _BlurSize;<br><br><br>        struct v2f &#123;<br>            float4 pos : SV_POSITION;<br>            half2 uv : TEXCOORD0;<br>            half2 uv_depth : TEXCOORD1;<br>        &#125;;<br><br>        v2f vert(appdata_img v) &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br><br>            o.uv = v.texcoord;<br>            o.uv_depth = v.texcoord;<br><br>            #if UNITY_UV_STARTS_AT_TOP<br>            if (_MainTex_TexelSize.y &lt; 0)<br>                o.uv_depth.y = 1 - o.uv_depth.y;<br>            #endif<br><br>            return o;<br>        &#125;<br><br>        fixed4 frag(v2f i) : SV_Target &#123;<br>            //Get the depth buffer value at this pixel.<br>            float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth);<br>            //H is the viewport position at this pixel in the range -1 to 1.<br>            float4 H = float4(i.uv.x * 2 - 1, i.uv.y * 2 - 1, d * 2 - 1, 1);<br>            //Transform by the view-projection inverse<br>            float4 D = mul(_CurrentViewProjectionInverseMatrix, H);<br>            //Divide by w to get the world position.<br>            float4 worldPos = D / D.w;<br><br>            //current viewport position<br>            float4 currentPos = H;<br>            //Use the world position, and transform by the previous view-projection matrix.<br>            float4 previousPos = mul(_PreviousViewProjectionMatrix, worldPos);<br>            //Convert to nonhomogeneous points [-1, 1] by dividing by w.<br>            previousPos /= previousPos.w;<br><br>            //Use this frame&#x27;s position and last frame&#x27;s to compute the pixel velocity.<br>            float2 velocity = (currentPos.xy - previousPos.xy) / 2.0f;<br><br>            float2 uv = i.uv;<br>            float4 c = tex2D(_MainTex, uv);<br>            uv += velocity * _BlurSize;<br>            for (int it = 1; it &lt; 3; it++, uv += velocity * _BlurSize) &#123;<br>                float4 currentColor = tex2D(_MainTex, uv);<br>                c += currentColor;<br>            &#125;<br>            c /= 3;<br><br>            return fixed4(c.rgb, 1.0);<br>        &#125;<br>        ENDCG<br><br>        Pass &#123;<br>            ZTest Always Cull Off ZWrite Off<br>            CGPROGRAM<br>            #pragma vertex vert<br>            #pragma fragment frag<br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    FallBack Off<br>&#125;<br></code></pre></td></tr></table></figure><p>_MainTex 对应了输入的渲染纹理，_BlurSize 是模糊图像时使用的参数。虽然在脚本里设置了材质的 _PreviousViewprojectionMatrix 和 _CurrentViewProjectionInverseMatrix 属性，但并没有在 Properties 块中声明它们。这是因为 Unity 没有提供矩阵类型的属性，但我们仍然可以在 CG 代码块中定义这些矩阵，并从脚本中设置它们。</p><p>除了定义在 Properties 声明的 _MainTex 和 _BlurSize 属性，我们还声明了其他三个变量。_CameraDepthTexture 是 Unity 传递给我们的深度纹理，而 _CurrentViewProjectionInverseMatrix 和 _PreviousViewProjectionMatrix 是由脚本传递而来的矩阵。除此之外，我们还声明了 _MainTex_TexelSize 变量，它对应了主纹理的纹素大小，我们需要使用该变量来对深度纹理的采样坐标进行平台差异化处理。</p><p>由于在本例中，我们需要同时处理多张渲染纹理，因此在 DirectX 这样的平台上，我们需要处理平台差异导致的图像翻转问题。在上面的代码中，我们对深度纹理的采样坐标进行了平台差异化处理，以便在类似 DirectX 的平台上，在开启了抗锯齿的情况下仍然可以得到正确的结果。</p><p>我们首先需要利用深度纹理和当前帧的视角 * 投影矩阵的逆矩阵来求得该像素在世界空间下的坐标。过程开始于对深度纹理的采样，我们使用内置的 SAMPLE_DEPTH_TEXTURE 宏和纹理坐标对深度纹理进行采样，得到了深度值 $d$。$d$ 是由 NDC 下的坐标映射而来的。我们想要构建像素的 NDC 坐标 $H$，就需要把这个深度值重新映射回 NDC。这个映射很简单，只需要使用原映射的反函数即可，即 $d$ * 2 - 1。同样，NDC 的 xy 分量可以由像素的纹理坐标映射而来（NDC 下的 xyz 分量范围均为[-1, 1]）。当得到 NDC 下的坐标 $H$ 后，我们就可以使用当前帧的视角 * 投影矩阵的逆矩阵对其进行变换，并把结果值除以它的 w 分量来得到世界空间下的坐标表示 worldPos。</p><p>一旦得到了世界空间下的坐标，我们就可以使用前一帧的视角 * 投影矩阵对它进行变换，得到前一帧在 NDC 下的坐标 previousPos。然后，我们计算前一帧和当前帧在屏幕空间下的位置差，得到该像素的速度 velocity。当得到该像素的速度后，我们就可以使用该速度值对它的邻域像素进行采样，相加后取平均值得到一个模糊的效果。采样时我们还使用了 _BlurSize 来控制采样距离。</p><p>本次实现的运动模糊适用于场景静止、摄像机快速运动的情况，这是因为我们在计算时只考虑了摄像机的运动。因此，如果把这些代码应用到一个物体快速运动而摄像机静止的场景，会发现不会产生任何运动模糊效果。如果我们想要对快速移动的物体产生运动模糊的效果，就需要生成更加精确的速度映射图。我们可以在 Unity 自带的 ImageEffect 包中找到更多的运动模糊的实现方法。</p><p>本次选择在片元着色器中使用逆矩阵来重建每个像素在世界空间下的位置。但是，这种做法往往会影响性能，下面我们会介绍一种更快速的由深度纹理重建世界坐标的方法。</p><h2 id="全局雾效">全局雾效</h2><p>**雾效（Fog）**是游戏里经常使用的一种效果。Unity 内置的雾效可以产生基于距离的线性或指数雾效。然而，要想在自己编写的顶点/片元着色器中实现这些雾效，我们需要在 Shader 中添加 #pragma multi_compile_fog 指令，同时还需要使用相关的内置宏，例如 UNITY_FOG_COORDS、UNITY_TRANSFER_FOG 和 UNTIY_APPLY_FOG 等。这种方法的缺点在于，我们不仅需要为场景中所有物体添加相关的渲染代码，而且能够实现的效果也非常有限。当我们需要对雾效进行一些个性化操作时，例如使用基于高度的雾效等，仅仅使用 Unity 内置的雾效就变得不再可行。</p><p>我们将学习一种基于屏幕后处理的全局雾效的实现。使用这种方法，我们不需要更改场景内渲染的物体所使用的 Shader 代码，而仅仅依靠一次屏幕后处理的步骤即可。这种方法的自由性很高，我们可以方便地模拟各种雾效，例如均匀的雾效、基于距离的线性/指数雾效等。在学习完本节后，我们可以得到类似下图中的效果。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_5.png" alt="全局雾效" title="全局雾效"></p><p>基于屏幕后处理的全局雾效的关键是，根据深度纹理来重建每个像素在世界空间下的位置。尽管我们在模拟运动模糊时已经实现了这个要求，即构建出当前像素的 NDC 坐标，再通过当前摄像机的视角 * 投影矩阵的逆矩阵来得到世界空间下的像素坐标，但是，这样的实现需要在片元着色器中进行矩阵乘法的操作，而这通常会影响游戏性能。我们将学习一个快速从深度纹理中重建世界坐标的方法。这种方法首先对图像空间下的视锥体射线（从摄像机出发，指向图像上的某点的射线）进行插值，这条射线存储了该像素在世界空间下到摄像机的方向信息。然后我们把该射线和线性化后的视角空间下的深度值相乘，再加上摄像机的世界位置，就可以得到该像素在世界空间下的位置。当我们得到世界坐标后，就可以轻松地使用各个公式来模拟全局雾效了。</p><h3 id="重建世界坐标">重建世界坐标</h3><p>在开始动手写代码之前，我们首先来了解如何从深度纹理中重建世界坐标。我们知道，坐标系中的一个顶点坐标可以通过它相对于另一个顶点坐标的偏移量来求得。重建像素的世界坐标也是基于这样的思想。我们只需要知道摄像机在世界空间下的位置，以及世界空间下该像素相对于摄像机的偏移量，把它们相加就可以得到该像素的世界坐标。整个过程可以使用下面的代码来表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float4 worldPos = _WorldSpaceCameraPos + linearDepth * interpolatedRay;<br></code></pre></td></tr></table></figure><p>其中，_WorldSpaceCameraPos 是摄像机在世界空间下的位置，这可以由 Unity 的内置变量直接访问得到。而 linearDepth * interpolatedRay 则可以计算得到该像素相对于摄像机的偏移量，linearDepth 是由深度纹理得到的线性深度值，interpolatedRay 是由顶点着色器输出并插值后得到的射线，它不仅包含了该像素到摄像机的方向，也包含了距离信息。linearDepth 的获取我们已经详细解释过了，因此我们下面着重解释 interpolatedRay 的求法。</p><p>interpolatedRay 来源于对近裁剪平面的 4 个角的某个特定向量的插值，这 4 个向量包含了它们到摄像机的方向和距离信息，我们可以利用摄像机的近裁剪平面距离、FOV、纵横比计算而得。下图显示了计算时使用的一些辅助向量。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_6.png" alt="计算 interpolatedRay" title="计算 interpolatedRay"></p><p>为了方便计算，我们可以先计算两个向量——toTop 和 toRight，它们是起点位于近裁剪平面中心、分别指向摄像机正上方和正右方的向量。它们的计算公式如下：<br>$$<br>halfHeight = Near \times \tan{\frac{FOV}{2}}<br>$$<br>$$<br>toTop = camera.up \times halfHeight<br>$$<br>$$<br>toRight = camera.right \times halfHeight \cdot aspect<br>$$<br>其中，Near 是近裁剪平面的距离，FOV 是竖直方向的视角范围，camera.up、camera.right 分别对应了摄像机的正上方和正右方。</p><p>当得到这两个辅助向量后，我们就可以计算 4 个角相对于摄像机的方向了。我们以左上角为例（见上图中的 TL 点），它的计算公式如下：</p><p>$$<br>TL = camera.forward \cdot Near + toTop - toRight<br>$$</p><p>同理，其他 3 个角的计算也是类似的：<br>$$<br>TR = camera.forward \cdot Near + toTop + toRight<br>$$<br>$$<br>BL = camera.forward \cdot Near - toTop - toRight<br>$$<br>$$<br>BR = camera.forward \cdot Near - toTop + toRight<br>$$</p><p>注意，上面求得的 4 个向量不仅包含了方向信息，它们的模对应了 4 个点打扫摄像机的空间距离。由于我们得到的线性深度值并非是点到摄像机的欧式距离，而是在 z 方向上的距离，因此，我们不能直接使用深度值和 4 个角的单位方向的乘积来计算它们到摄像机的偏移量，如下图所示。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_7.png" alt="采样得到的深度值并非是点到摄像机的欧式距离" title="采样得到的深度值并非是点到摄像机的欧式距离"></p><p>想要把深度值转换成到摄像机的欧式距离也很简单，我们以 TL 点为例，根据相似三角形原理，TL 所在的射线上，像素的深度值和它到摄像机的实际距离的比等于近裁剪平面的距离和 TL 向量的模的比，即<br>$$<br>\frac{depth}{dist} = \frac{Near}{|TL|}<br>$$<br>由此可得，我们需要的 TL 距离摄像机的欧式距离 dist：<br>$$<br>dist = \frac{|TL|}{Near} \times depth<br>$$<br>由于 4 个点相互对称，因此其他 3 个向量的模和 TL 相等，即我们可以使用同一个因子和单位向量相乘，得到它们对应的向量值：<br>$$<br>scale = \frac{|TL|}{|Near|}<br>$$<br>$$<br>Ray_{TL} = \frac{TL}{|TL|} \times scale, Ray_{TR} = \frac{TR}{|TR|} \times scale<br>$$<br>$$<br>Ray_{BL} = \frac{BL}{|BL|} \times scale, Ray_{BR} = \frac{BR}{|BR|} \times scale<br>$$</p><p>屏幕后处理的原理是使用特定的材质去渲染一个刚好填充整个屏幕的四边形面片。这个四边形面片的 4 个顶点就对应了近裁剪平面的 4 个角。因此，我们可以把上面的计算结果传递给顶点着色器，顶点着色器根据当前的位置选择它所对应的向量，然后再将其输出，经插值后传递给片元着色器得到 interpolatedRay，我们就可以直接利用一开始提到的公式重建该像素在世界空间下的位置了。</p><h3 id="雾的计算">雾的计算</h3><p>在简单的雾效实现中，我们需要计算一个雾效系数 f，作为混合原始颜色和雾的颜色的混合系数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float3 afterFog = f * fogColor + (1 - f) * origColor;<br></code></pre></td></tr></table></figure><p>这个雾效系数 f 有很多计算方法。在 Unity 内置的雾效实现中，支持三种雾的计算方式——线性（Linear）、指数（Exponential）以及指数的平方（Exponential Squared）。当给定距离 z 后，f 的计算公式分别如下：</p><p>Linear：</p><p>$f = \frac{d_{max} - |z|}{d_{max} - d_{min}}$，$d_{min}$ 和 $d_{max}$ 分别表示受雾影响的最小距离和最大距离。</p><p>Exponential：</p><p>$f = e^{-d \cdot |z|}$，$d$ 是控制雾的浓度的参数。</p><p>Exponential Squared：</p><p>$f = e^{-(d - |z|)^2}$，$d$ 是控制雾的浓度的参数。</p><p>本次我们将使用类似线性雾的计算方式，计算基于高度的雾效。具体方法是，当给定一点在世界空间下的高度 y 后，f 的计算公式为：</p><p>$f = \frac{H_{end} - y}{H_{end} - H_{start}}$，$H_{start}$ 和 $H_{end}$ 分别表示受雾影响的起始高度和终止高度。</p><h3 id="实现">实现</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FogWithDepthTexture</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader fogShader;<br><span class="hljs-keyword">private</span> Material fogMaterial = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);<br><span class="hljs-keyword">return</span> fogMaterial;<br>&#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> Camera myCamera;<br><span class="hljs-keyword">public</span> Camera camera &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">if</span> (myCamera == <span class="hljs-literal">null</span>) &#123;<br>myCamera = GetComponent&lt;Camera&gt;();<br>&#125;<br><span class="hljs-keyword">return</span> myCamera;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Transform myCameraTransform;<br><span class="hljs-keyword">public</span> Transform cameraTransform &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">if</span> (myCameraTransform == <span class="hljs-literal">null</span>) &#123;<br>myCameraTransform = camera.transform;<br>&#125;<br><br><span class="hljs-keyword">return</span> myCameraTransform;<br>&#125;<br>&#125;<br><br>[<span class="hljs-meta">Range(0.0f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fogDensity = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-keyword">public</span> Color fogColor = Color.white;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fogStart = <span class="hljs-number">0.0f</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fogEnd = <span class="hljs-number">2.0f</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span> &#123;<br>camera.depthTextureMode |= DepthTextureMode.Depth;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>Matrix4x4 frustumCorners = Matrix4x4.identity;<br><br><span class="hljs-built_in">float</span> fov = camera.fieldOfView;<br><span class="hljs-built_in">float</span> near = camera.nearClipPlane;<br><span class="hljs-built_in">float</span> aspect = camera.aspect;<br><br><span class="hljs-built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="hljs-number">0.5f</span> * Mathf.Deg2Rad);<br>Vector3 toRight = cameraTransform.right * halfHeight * aspect;<br>Vector3 toTop = cameraTransform.up * halfHeight;<br><br>Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;<br><span class="hljs-built_in">float</span> scale = topLeft.magnitude / near;<br><br>topLeft.Normalize();<br>topLeft *= scale;<br><br>Vector3 topRight = cameraTransform.forward * near + toRight + toTop;<br>topRight.Normalize();<br>topRight *= scale;<br><br>Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;<br>bottomLeft.Normalize();<br>bottomLeft *= scale;<br><br>Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;<br>bottomRight.Normalize();<br>bottomRight *= scale;<br><br>frustumCorners.SetRow(<span class="hljs-number">0</span>, bottomLeft);<br>frustumCorners.SetRow(<span class="hljs-number">1</span>, bottomRight);<br>frustumCorners.SetRow(<span class="hljs-number">2</span>, topRight);<br>frustumCorners.SetRow(<span class="hljs-number">3</span>, topLeft);<br><br>material.SetMatrix(<span class="hljs-string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);<br><br>material.SetFloat(<span class="hljs-string">&quot;_FogDensity&quot;</span>, fogDensity);<br>material.SetColor(<span class="hljs-string">&quot;_FogColor&quot;</span>, fogColor);<br>material.SetFloat(<span class="hljs-string">&quot;_FogStart&quot;</span>, fogStart);<br>material.SetFloat(<span class="hljs-string">&quot;_FogEnd&quot;</span>, fogEnd);<br><br>Graphics.Blit (src, dest, material);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>fogDensity 用于控制雾的浓度，fogColor 用于控制雾的颜色。我们使用的雾效模拟函数是基于高度的，因此参数 fogStart 用于控制雾效的起始高度，fogEnd 用于控制雾效的终止高度。</p><p>OnRenderImage 首先计算了近裁剪平面的四个角对应的向量，并把它们存储在一个矩阵类型的变量（frustumCorners）中。计算过程我们已经详细解释过了，代码只是套用了之前讲过的公式而已。我们按一定顺序把这四个方向存储到了 frustumCorners 不同的行中，这个顺序是非常重要的，因为这决定了我们在顶点着色器中使用哪一行作为该点的待插值向量。随后，我们把结果和其他参数传递给材质，并调用 Graphics.Blit(src, dest, material) 把渲染结果显示在屏幕上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter13/Chapter13-FogWithDepthTexture&quot; &#123;<br><br>    Properties &#123;<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _FogDensity (&quot;Fog Density&quot;, Float) = 1.0<br>        _FogColor (&quot;Fog Color&quot;, Color) = (1, 1, 1, 1)<br>        _FogStart (&quot;Fog Start&quot;, Float) = 0.0<br>        _FogEnd (&quot;Fog End&quot;, Float) = 1.0<br>    &#125;<br><br>    SubShader &#123;<br>        CGINCLUDE<br>        #include &quot;UnityCG.cginc&quot;<br><br>        float4x4 _FrustumCornersRay;<br><br>        sampler2D _MainTex;<br>        half4 _MainTex_TexelSize;<br>        sampler2D _CameraDepthTexture;<br>        half _FogDensity;<br>        fixed4 _FogColor;<br>        float _FogStart;<br>        float _FogEnd;<br><br>       <br><br>        struct v2f &#123;<br>            float4 pos : SV_POSITION;<br>            half2 uv : TEXCOORD0;<br>            half2 uv_depth : TEXCOORD1;<br>            float4 interpolatedRay : TEXCOORD2;<br>        &#125;;<br><br>        v2f vert(appdata_img v) &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br>            o.uv = v.texcoord;<br>            o.uv_depth = v.texcoord;<br><br>            #if UNITY_UV_STARTS_AT_TOP<br>            if(_MainTex_TexelSize.y &lt; 0)<br>                o.uv_depth.y = 1 - o.uv_depth.y;<br>            #endif<br><br>            int index = 0;<br>            if (v.texcoord.x &lt; 0.5 &amp;&amp; v.texcoord.y &lt; 0.5) &#123;<br>                index = 0;<br>            &#125; else if (v.texcoord.x &gt; 0.5 &amp;&amp; v.texcoord.y &lt; 0.5) &#123;<br>                index = 1;<br>            &#125; else if (v.texcoord.x &gt; 0.5 &amp;&amp; v.texcoord.y &gt; 0.5) &#123;<br>                index = 2;<br>            &#125; else &#123;<br>                index = 3;<br>            &#125;<br><br>            #if UNITY_UV_STARTS_AT_TOP<br>            if(_MainTex_TexelSize.y &lt; 0)<br>                index = 3 - index;<br>            #endif<br><br>            o.interpolatedRay = _FrustumCornersRay[index];<br>            return o;<br>        &#125;<br><br>        fixed4 frag(v2f i) : SV_Target &#123;<br>            float linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));<br>            float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;<br><br>            float fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart);<br>            fogDensity = saturate(fogDensity * _FogDensity);<br><br>            fixed4 finalColor = tex2D(_MainTex, i.uv);<br>            finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);<br><br>            return finalColor;<br>        &#125;<br>        ENDCG<br><br>        Pass &#123;<br>            ZTest Always Cull Off ZWrite Off<br>            CGPROGRAM<br>            #pragma vertex vert<br>            #pragma fragment frag<br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    FallBack Off<br>&#125;<br></code></pre></td></tr></table></figure><p>在 v2f 结构体中，我们除了定义顶点位置、屏幕图像和深度纹理的纹理坐标外，还定义了 interpolatedRay 变量存储插值后的像素向量。在顶点着色器中，我们对深度纹理的采样坐标进行了平台差异化除了。更重要的是，我们要决定该点对应了 4 个角中的哪个角。我们采用的方法是判断它的纹理坐标。我们知道，在 Unity 中，纹理坐标的(0, 0)点对应了左下角，而(1, 1)点对应了右上角。我们据此来判断该顶点对应的索引，这个对应关系和我们在脚本中对 frustumCorners 的赋值顺序是一致的。实际上，不同平台的纹理坐标不一定是满足上面的条件的，例如 DirectX 和 Metal 这样的平台，左上角对应了(0, 0)点，但大多数情况下 Unity 会把这些平台下的屏幕图像进行翻转，因此我们仍然可以利用这个条件。但如果在类似 DirectX 的平台上开启了抗锯齿，Unity 就不会进行这个翻转。为了此时仍然可以得到相应顶点位置的索引值，我们对索引值也进行了平台差异化处理，以便在必要时也对索引值进行翻转。最后，我们使用索引值来获取 _FrustumCornersRay 中对应的行作为该顶点的 interpolatedRay 值。</p><p>首先我们需要重建该像素在世界空间中的位置。为此，我们首先使用 SAMPLE_DEPTH_TEXTURE 对深度纹理进行采样，再使用 LinearEyeDepth 得到视角空间下的线性深度值。之后，与 interpolatedRay 相乘后再和世界空间下的摄像机位置相加，即可得到世界空间下的位置。</p><p>得到世界坐标后，模拟雾效就变得非常容易。在本例中，我们选择实现基于高度的雾效模拟，我们根据材质属性 _FogEnd 和 _FogStart 计算当前的像素高度 worldPos.y 对应的雾效系数 fogDensity，再和参数 _FogDensity 相乘后，利用 saturate 函数截取到[0, 1]范围内，作为最后的雾效系数。然后，我们使用该系数将雾的颜色和原始颜色进行混合后返回。</p><h2 id="再谈边缘检测">再谈边缘检测</h2><p>我们曾介绍如何使用 Sobel 算子对屏幕图像进行边缘检测，实现描边的效果。但是，这种直接利用颜色信息进行边缘检测的方法会产生很多我们不希望得到的边缘线，如下图所示；</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_8.png" alt="直接对颜色图像进行边缘检测的结果" title="直接对颜色图像进行边缘检测的结果"></p><p>可以看出，物体的纹理、阴影等位置也被描上黑边，而这往往不是我们希望看到的。我们将学习如何在深度和法线纹理上进行边缘检测，这些图像不会受纹理和光照的影响，而仅仅保存了当前渲染物体的模型信息，通过这样的方式检测出来的边缘更加可靠。我们将实现类似下图中的效果。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_9.png" alt="在深度和法线纹理上进行更健壮的边缘检测" title="在深度和法线纹理上进行更健壮的边缘检测"></p><p>与使用 Sobel 算子不同，我们将使用 Roberts 算子来进行边缘检测。它使用的卷积核如下图所示。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_10.png" alt="Roberts算子" title="Roberts算子"></p><p>Roberts 算子的本质就是计算左上角和右下角的差值，乘以右上角和左下角的差值，作为评估边缘的依据。在下面的实现中，我们也会按这样的方式，取对角方向的深度或法线值，比较它们之间的插值，如果超过某个阈值（可由参数控制），就认为它们之间存在一条边。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EdgeDetectNormalsAndDepth</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader edgeDetectShader;<br><span class="hljs-keyword">private</span> Material edgeDetectMaterial = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);<br><span class="hljs-keyword">return</span> edgeDetectMaterial;<br>&#125;  <br>&#125;<br><br>[<span class="hljs-meta">Range(0.0f, 1.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> edgesOnly = <span class="hljs-number">0.0f</span>;<br><br><span class="hljs-keyword">public</span> Color edgeColor = Color.black;<br><br><span class="hljs-keyword">public</span> Color backgroundColor = Color.white;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> sampleDistance = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> sensitivityDepth = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> sensitivityNormals = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span> &#123;<br>GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.DepthNormals;<br>&#125;<br><br>[<span class="hljs-meta">ImageEffectOpaque</span>]<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_EdgeOnly&quot;</span>, edgesOnly);<br>material.SetColor(<span class="hljs-string">&quot;_EdgeColor&quot;</span>, edgeColor);<br>material.SetColor(<span class="hljs-string">&quot;_BackgroundColor&quot;</span>, backgroundColor);<br>material.SetFloat(<span class="hljs-string">&quot;_SampleDistance&quot;</span>, sampleDistance);<br>material.SetVector(<span class="hljs-string">&quot;_Sensitivity&quot;</span>, <span class="hljs-keyword">new</span> Vector4(sensitivityNormals, sensitivityDepth, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>));<br><br>Graphics.Blit(src, dest, material);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>sampleDistance 用于控制对深度+法线纹理采样时，使用的采样距离。从视觉上看，sampleDistance 值越大，描边越宽。sensitivityDepth 和 sensitivityNormals 将会影响当邻域的深度值或法线值相差多少时，会被认为存在一条边界。如果把灵敏度调得很大，那么可能即使是深度或法线上很小的变化也会形成一条边。</p><p>需要注意的是，这里我们为 OnRenderImage 函数添加了[ImageEffectOpaque]属性。在默认情况下，OnRenderImage 函数会在所有的不透明和透明的 Pass 执行完毕后被调用，以便对场景中所有游戏对象都产生影响。但有时，我们希望在不透明的 Pass（即渲染队列小于等于 2500 的 Pass，内置的 Background、Geometry 和 AlphaTest 渲染队列均在此范围内）执行完毕后立即调用该函数，而不对透明物体（渲染队列为 Transparent 的 Pass）产生影响，此时，我们可以在 OnRenderImage 函数前添加 ImageEffectOpaque 属性来实现这样的目的。在本例中，我们只希望对不透明物体进行描边，而不希望透明物体也被描边，因此需要添加该属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter13/Chapter13-EdgeDetectNormalAndDepth&quot; &#123;<br><br>    Properties &#123;<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _EdgeOnly (&quot;Edge Only&quot;, Float) = 1.0<br>        _EdgeColor (&quot;Edge Color&quot;, Color) = (0, 0, 0, 1)<br>        _BackgroundColor (&quot;Background Color&quot;, Color) = (1, 1, 1, 1)<br>        _SampleDistance (&quot;Sample Distance&quot;, Float) = 1.0<br>        _Sensitivity (&quot;Sensitivity&quot;, Vector) = (1, 1, 1, 1)<br>    &#125;<br><br>    SubShader &#123;<br>        CGINCLUDE<br>        #include &quot;UnityCG.cginc&quot;<br><br>        sampler2D _MainTex;<br>        half4 _MainTex_TexelSize;<br>        fixed _EdgeOnly;<br>        fixed4 _EdgeColor;<br>        fixed4 _BackgroundColor;<br>        float _SampleDistance;<br>        half4 _Sensitivity;<br>        sampler2D _CameraDepthNormalsTexture;<br><br>        struct v2f &#123;<br>            float4 pos : SV_POSITION;<br>            half2 uv[5] : TEXCOORD0;<br>        &#125;;<br><br>        v2f vert(appdata_img v) &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br><br>            half2 uv = v.texcoord;<br>            o.uv[0] = uv;<br><br>            #if UNITY_UV_STARTS_AT_TOP<br>            if (_MainTex_TexelSize.y &lt; 0)<br>            uv.y = 1 - uv.y;<br>            #endif<br><br>            o.uv[1] = uv + _MainTex_TexelSize.xy * half2(1, 1) * _SampleDistance;<br>            o.uv[2] = uv + _MainTex_TexelSize.xy * half2(-1, -1) * _SampleDistance;<br>            o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 1) * _SampleDistance;<br>            o.uv[4] = uv + _MainTex_TexelSize.xy * half2(1, -1) * _SampleDistance;<br>            return o;<br>        &#125;<br><br><br>        half CheckSame(half4 center, half4 sample) &#123;<br>            half2 centerNormal = center.xy;<br>            float centerDepth = DecodeFloatRG(center.zw);<br>            half2 sampleNormal = sample.xy;<br>            float sampleDepth = DecodeFloatRG(sample.zw);<br><br>            //difference in normals<br>            //do not bother decoding normal - there&#x27;s no need here<br>            half2 diffNormal = abs(centerNormal - sampleNormal) * _Sensitivity.x;<br>            int isSameNormal = (diffNormal.x + diffNormal.y) &lt; 0.1;<br>            //difference in depth<br>            float diffDepth  = abs(centerDepth - sampleDepth) * _Sensitivity.y;<br>            //scale the required threshold by the distance<br>            int isSameDepth = diffDepth &lt; 0.1 * centerDepth;<br><br>            //return:<br>            //1 - if normals and depth are similar enough<br>            //0 - otherwise<br>            return isSameNormal * isSameDepth ? 1.0 : 0.0;<br>        &#125;<br><br>        fixed4 fragRobertsCrossDepthAndNormal(v2f i) : SV_Target &#123;<br>            half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[1]);<br>            half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[2]);<br>            half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[3]);<br>            half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[4]);<br><br>            half edge = 1.0;<br>            edge *= CheckSame(sample1, sample2);<br>            edge *= CheckSame(sample3, sample4);<br><br>            fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[0]), edge);<br>            fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);<br><br>            return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly); <br>        &#125;<br>        ENDCG<br><br>        Pass &#123;<br>            ZTest Always Cull Off ZWrite Off<br>            CGPROGRAM<br>            #pragma vertex vert<br>            #pragma fragment fragRobertsCrossDepthAndNormal<br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    FallBack Off<br>&#125;<br></code></pre></td></tr></table></figure><p>_Sensitivity 的 xy 分量分别对应了法线和深度的检测灵敏度，zw分量则没有实际用途。我们在 v2f 结构体中定义了一个维数为 5 的纹理坐标数组。这个数组的第一个坐标存储了屏幕颜色图像的采样纹理。我们对深度纹理的采样坐标进行了平台差异化处理，在必要情况下对它的竖直方向进行了翻转。数组中剩余的 4 个坐标则存储了使用 Roberts 算子时需要采样的纹理坐标，我们还使用了 _SampleDistance 来控制采样距离。通过把计算采样纹理坐标的代码从片元着色器中转移到顶点着色器中，可以减少运算，提高性能。由于从顶点着色器到片元着色器的插值是线性的，因此这样的转移并不会影响纹理坐标的计算结果。</p><p>在片元着色器中我们首先使用 4 个纹理坐标对深度+法线纹理进行采样，再调用 CheckSame 函数来分别计算对角线上两个纹理值的插值。CheckSame 函数的返回值要么是 0，要么是 1，返回 0 时表明这两点之间存在一条边界，反之则返回 1。</p><p>CheckSame 首先对输入参数进行处理，得到两个采样点的法线和深度值。值得注意的是，这里我们并没有解码得到真正的法线值，而是直接使用了 xy 分量。这是因为我们只需要比较两个采样值之间的差异度，而并不需要知道它们真正的法线值。然后，我们把两个采样点的对应值相减并取绝对值，再乘以灵敏度参数，把差异值的每个分量相加再和一个阈值比较，如果它们的和小于阈值，则返回 1，说明差异不明显，不存在一条边界；否则返回 0。最后，我们把法线和深度的检查结果相乘，作为组合后的返回值。当通过 CheckSame 函数得到边缘信息后，片元着色器就利用该值进行颜色混合。</p><p>本次实现的描边效果是基于整个屏幕空间进行的，也就是说，场景内的所有物体都会被添加描边效果。但有时，我们希望只对特定的物体进行描边，例如当玩家选中场景中的某个物体后，我们想要在该物体周围添加一层描边效果。这时，我们可以使用 Unity 提供的 Graphics.DrawMesh 或 Graphics.DrawMeshNow 函数把需要描边的物体再次渲染一遍（在所有不透明物体渲染完毕之后），然后再使用本节提到的边缘检测算法计算深度或法线纹理中每个像素的梯度值，判断它们是否小于某个阈值，如果是，就在 Shader 中使用 clip() 函数将该像素剔除掉，从而显示出原来的物体颜色。</p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Texture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>屏幕后处理</title>
    <link href="/posts/%E5%B1%8F%E5%B9%95%E5%90%8E%E5%A4%84%E7%90%86/"/>
    <url>/posts/%E5%B1%8F%E5%B9%95%E5%90%8E%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="建立一个基本的屏幕后处理脚本系统">建立一个基本的屏幕后处理脚本系统</h2><p>屏幕后处理，通常指的是在渲染完整个场景得到屏幕图像后，再对这个图像进行一系列操作，实现各种屏幕特效。使用这种技术，可以为游戏画面添加更多的艺术效果，例如景深（Depth of Field）、运动模糊（Motion Blur）等。</p><p>因此，想要实现屏幕后处理的基础在于得到渲染后的屏幕图像，即抓取屏幕，而 Unity 为我们提供了这样一个方便的接口——<strong>OnRenderImage 函数</strong>。它的函数声明如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)<br></code></pre></td></tr></table></figure><p>当我们在脚本中声明此函数后，Unity 会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中，通过函数中的一系列操作后，再把目标渲染纹理，即第二个参数对应的渲染纹理显示到屏幕上。在 OnRenderImage 函数中，我们通常是利用 <strong>Graphics.Blit 函数</strong>来完成对渲染纹理的处理。它有 3 种函数声明：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Blit</span>(<span class="hljs-params">Texture src, RenderTexture dest</span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Blit</span>(<span class="hljs-params">Texture src, RenderTexture dest, Material mat, <span class="hljs-built_in">int</span> pass = <span class="hljs-number">-1</span></span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Blit</span>(<span class="hljs-params">Texture src, Material mat, <span class="hljs-built_in">int</span> pass = <span class="hljs-number">-1</span></span>)</span>;<br></code></pre></td></tr></table></figure><p>其中，参数 src 对应了源纹理，在屏幕后处理技术中，这个参数通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理。参数 dest 是目标渲染纹理，如果它的值为 null 就会直接将结果显示在屏幕上。参数 mat 是我们使用的材质，这个材质使用的 Unity Shader 将会进行各种屏幕后处理操作，而 src 纹理将会被传递给 Shader 中名为 _MainTex 的纹理属性。参数 pass 的默认值为 -1，表示将会依次调用 Shader 内的所有 Pass。否则，只会调用给定索引的 Pass。</p><p>在默认情况下，OnRenderImage 函数会在所有的不透明和透明的 Pass 执行完毕后被调用，以便对场景中所有游戏对象都产生影响。但有时，我们希望在不透明的 Pass（即渲染队列小于等于 2500 的 Pass，内置的 Background、Geometry 和 AlphaTest 渲染队列均在此范围内）执行完毕后立即调动 OnRenderImage 函数，从而不对透明物体产生任何影响。此时，我们可以在 OnRenderImage 函数前添加 ImageEffectOpaque 属性来实现这样的目的。</p><p>要在 Unity 中实现屏幕后处理效果，过程通常如下：我们首先需要在摄像机中添加一个用于屏幕后处理的脚本。在这个脚本中，我们会实现 OnRenderImage 函数来获取当前屏幕的渲染纹理。然后，再调用 Graphics.Blit 函数使用特定的 Unity Shader 来对当前图像进行处理，再把返回的渲染纹理显示到屏幕上。对于一些复杂的屏幕特效，我们可能需要多次调用 Graphics.Blit 函数来对上一步的输出结果进行下一步处理。</p><p>但是，在进行屏幕后处理之前，我们需要检查一系列条件是否满足，例如当前平台是否支持渲染纹理和屏幕特效，是否支持当前使用的 Unity Shader 等。为此，我们创建了一个用于屏幕后处理效果的基类，在实现各种屏幕特效时，我们只需要继承自该基类，再实现派生类中不同的操作即可。PostEffectsBase.cs 的主要代码如下。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br>[<span class="hljs-meta">ExecuteInEditMode</span>]<br>[<span class="hljs-meta">RequireComponent (typeof(Camera))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PostEffectsBase</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br><span class="hljs-comment">// Called when start</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CheckResources</span>()</span> &#123;<br><span class="hljs-built_in">bool</span> isSupported = CheckSupport();<br><br><span class="hljs-keyword">if</span> (isSupported == <span class="hljs-literal">false</span>) &#123;<br>NotSupported();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Called in CheckResources to check support on this platform</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CheckSupport</span>()</span> &#123;<br><span class="hljs-keyword">if</span> (SystemInfo.supportsImageEffects == <span class="hljs-literal">false</span> || SystemInfo.supportsRenderTextures == <span class="hljs-literal">false</span>) &#123;<br>Debug.LogWarning(<span class="hljs-string">&quot;This platform does not support image effects or render textures.&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// Called when the platform doesn&#x27;t support this effect</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NotSupported</span>()</span> &#123;<br>enabled = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>CheckResources();<br>&#125;<br><br><span class="hljs-comment">// Called when need to create the material used by this effect</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Material <span class="hljs-title">CheckShaderAndCreateMaterial</span>(<span class="hljs-params">Shader shader, Material material</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (shader == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)<br><span class="hljs-keyword">return</span> material;<br><br><span class="hljs-keyword">if</span> (!shader.isSupported) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>material = <span class="hljs-keyword">new</span> Material(shader);<br>material.hideFlags = HideFlags.DontSave;<br><span class="hljs-keyword">if</span> (material)<br><span class="hljs-keyword">return</span> material;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>CheckShaderAndCreateMaterial 函数接受两个参数，第一个参数指定了该特效需要使用的 Shader，第二个参数则是用于后期处理的材质。该函数首先检查 Shader 的可用性，检查通过后就返回一个使用了该 Shader 的材质，否则返回 null。</p><h2 id="调整屏幕的亮度、饱和度和对比度">调整屏幕的亮度、饱和度和对比度</h2><p>首先编写 BrightnessSaturationAndContrast.cs 脚本。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BrightnessSaturationAndContrast</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader briSatConShader;<br><span class="hljs-keyword">private</span> Material briSatConMaterial;<br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);<br><span class="hljs-keyword">return</span> briSatConMaterial;<br>&#125;  <br>&#125;<br><br>[<span class="hljs-meta">Range(0.0f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> brightness = <span class="hljs-number">1.0f</span>;<br><br>[<span class="hljs-meta">Range(0.0f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> saturation = <span class="hljs-number">1.0f</span>;<br><br>[<span class="hljs-meta">Range(0.0f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> contrast = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span>(<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_Brightness&quot;</span>, brightness);<br>material.SetFloat(<span class="hljs-string">&quot;_Saturation&quot;</span>, saturation);<br>material.SetFloat(<span class="hljs-string">&quot;_Contrast&quot;</span>, contrast);<br><br>Graphics.Blit(src, dest, material);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每当 OnRenderImage 函数被调用时，它会检查材质是否可用。如果可用，就把参数传递给材质，再调用 Graphics.Blit 进行处理；否则，直接把原图像显示到屏幕上，不做任何处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter12/Chapter12-BrightnessSaturationAndContrast&quot;<br>&#123;<br>    <br>    Properties &#123;<br>_MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>// _Brightness (&quot;Brightness&quot;, Float) = 1<br>// _Saturation(&quot;Saturation&quot;, Float) = 1<br>// _Contrast(&quot;Contrast&quot;, Float) = 1<br>&#125;<br>SubShader &#123;<br>Pass &#123;  <br>ZTest Always Cull Off ZWrite Off<br><br>CGPROGRAM  <br>#pragma vertex vert  <br>#pragma fragment frag  <br>  <br>#include &quot;UnityCG.cginc&quot;  <br>  <br>sampler2D _MainTex;  <br>half _Brightness;<br>half _Saturation;<br>half _Contrast;<br>  <br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>half2 uv: TEXCOORD0;<br>&#125;;<br>  <br>v2f vert(appdata_img v) &#123;<br>v2f o;<br><br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.uv = v.texcoord;<br> <br>return o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>fixed4 renderTex = tex2D(_MainTex, i.uv);  <br>  <br>// Apply brightness<br>fixed3 finalColor = renderTex.rgb * _Brightness;<br><br>// Apply saturation<br>fixed luminance = 0.2125 * renderTex.r + 0.7154 * renderTex.g + 0.0721 * renderTex.b;<br>fixed3 luminanceColor = fixed3(luminance, luminance, luminance);<br>finalColor = lerp(luminanceColor, finalColor, _Saturation);<br><br>// Apply contrast<br>fixed3 avgColor = fixed3(0.5, 0.5, 0.5);<br>finalColor = lerp(avgColor, finalColor, _Contrast);<br><br>return fixed4(finalColor, renderTex.a);  <br>&#125;  <br>  <br>ENDCG<br>&#125;  <br>&#125;<br><br>Fallback Off<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们提到 Graphics.Blit(src, dest, material) 将把第一个参数传递给 Shader 中名为 _MainTex 的属性，因此我们必须声明一个名为 _MainTex 的纹理属性。除此之外，我们还声明了用于调整亮度、饱和度和对比度的属性。这些值将会由脚本传递而得。事实上，我们可以省略 Properties 中的属性声明，Properties 中声明的属性仅仅是为了显示在材质面板中，但对于屏幕特效来说，它们使用的材质都是临时创建的，我们也不需要在材质面板上调整参数，而是直接从脚本传递给 Unity Shader。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">ZTest Always Cull Off ZWrite Off<br></code></pre></td></tr></table></figure><p>屏幕后处理实际上是在场景中绘制了一个与屏幕同宽同高的四边形面片，为了防止它对其他物体产生影响，我们需要设置相关的渲染状态，在这里我们关闭了深度写入，是为了防止它“挡住”在其后面被渲染的物体。例如，如果当前的 OnRenderImage 函数在所有不透明的 Pass 执行完毕后立即被调用，不关闭深度写入就会影响后面透明的 Pass 的渲染。这些状态设置可以认为是用于屏幕后处理的 Shader 的“标配”。</p><p>首先，我们得到对原屏幕图像（存储在 _MainTex 中)的采样结果 renderTex。然后利用 _Brightness 属性来调整亮度。亮度的调整非常简单，我们只需要把原颜色乘以亮度系数 _Brightness 即可。然后，我们计算该像素对应的亮度值（luminance），这是通过对每个颜色乘以一个特定的系数再相加得到的。我们使用该亮度值创建了一个饱和度为 0 的颜色值，并使用 _Saturation 属性在其和上一步得到的颜色之间进行插值，从而得到希望的饱和度颜色。对比度的处理类似，我们首先创建一个对比度为 0 的颜色值（各分量均为 0.5），再使用 _Contrast 属性在其和上一步得到的颜色之间进行插值，从而得到最终的处理结果。</p><p><img src="/posts_image/Post_Processing/Post_Processing_1.png" alt="调整屏幕的亮度、饱和度和对比度" title="调整屏幕的亮度、饱和度和对比度"></p><h2 id="边缘检测">边缘检测</h2><p>边缘检测的原理是利用一些边缘检测算子对图像进行**卷积（convolution）**操作，我们首先来了解什么是卷积。</p><h3 id="什么是卷积">什么是卷积</h3><p>在图像处理中，卷积操作指的就是使用一个**卷积核（kernel）**对一张图像中的每个像素进行一系列操作。卷积核通常是一个四方形网格结构（例如 2 $\times$ 2、3 $\times$ 3 的方形区域），该区域内每个方格都有一个权重值。当对图像中的某个像素进行卷积时，我们会把卷积核的中心放置于该像素上，如下图所示，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到的结果就是该位置的新像素值。</p><p><img src="/posts_image/Post_Processing/Post_Processing_2.png" alt="卷积核与卷积" title="卷积核与卷积"></p><p>这样的计算过程虽然简单，但可以实现很多常见的图像处理效果，例如图像模糊、边缘检测等。例如，如果我们想要对图像进行均值模糊，可以使用一个 3 $\times$ 3 的卷积核，核内每个元素的值均为 1/9。</p><h3 id="常见的边缘检测算子">常见的边缘检测算子</h3><p>卷积操作的神奇之处在于选择的卷积核。那么，用于边缘检测的卷积核（也被称为边缘检测算子）应该是什么样子的？在回答这个问题之前，我们可以首先回想一下边到底是如何形成的。如果相邻像素之间存在差别明显的颜色、亮度、纹理等属性，我们就会认为它们之间应该有一条边界。这种相邻像素之间的差值可以用**梯度（gradient）**来表示，可以想像得到，边缘处的梯度绝对值会比较大。基于这样的理解，有几种不同的边缘检测算子被先后提出来。</p><p><img src="/posts_image/Post_Processing/Post_Processing_3.png" alt="3 种常见的边缘检测算子" title="3 种常见的边缘检测算子"></p><p>3 种常见的边缘检测算子如上图所示，它们都包含了两个方向的卷积核，分别用于检测水平方向和竖直方向上的边缘信息。在进行边缘检测时，我们需要对每个像素分别进行一次卷积计算，得到两个方向上的梯度值 $G_x$ 和 $G_y$，而整体的梯度可按下面的公式计算而得：</p><p>$$<br>G = \sqrt{G_x^2 + G_y^2}<br>$$</p><p>由于上述计算包含了开根号操作，出于性能的考虑，我们有时会使用绝对值操作来代替开根号操作：</p><p>$$<br>G = |G_x| + |G_y|<br>$$</p><p>当得到梯度 $G$ 后，我们就可以据此来判断哪些像素对应了边缘（梯度值越大，越有可能是边缘点）。</p><h3 id="实现">实现</h3><p>我们首先来编写 EdgeDetection 脚本。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EdgeDetection</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader edgeDetectShader;<br><span class="hljs-keyword">private</span> Material edgeDetectMaterial = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);<br><span class="hljs-keyword">return</span> edgeDetectMaterial;<br>&#125;  <br>&#125;<br><br>[<span class="hljs-meta">Range(0.0f, 1.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> edgesOnly = <span class="hljs-number">0.0f</span>;<br><br><span class="hljs-keyword">public</span> Color edgeColor = Color.black;<br><br><span class="hljs-keyword">public</span> Color backgroundColor = Color.white;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_EdgeOnly&quot;</span>, edgesOnly);<br>material.SetColor(<span class="hljs-string">&quot;_EdgeColor&quot;</span>, edgeColor);<br>material.SetColor(<span class="hljs-string">&quot;_BackgroundColor&quot;</span>, backgroundColor);<br><br>Graphics.Blit(src, dest, material);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当 edgesOnly 值为 0 时，边缘将会叠加在原渲染图像上；当 edgesOnly 值为 1 时，则会只显示边缘，不显示原渲染图像。其中，背景颜色由 backgroundColor 指定，边缘颜色由 edgeColor 指定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter12/Chapter12-EdgeDetection&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _EdgeOnly (&quot;Edge Only&quot;, Float) = 1.0<br>        _EdgeColor (&quot;Edge Color&quot;, Color) = (0, 0, 0, 1)<br>        _BackgroundColor (&quot;Background Color&quot;, Color) = (1, 1, 1, 1)<br>    &#125;<br>    SubShader<br>    &#123;<br>        Pass &#123;<br>            ZTest Always Cull Off ZWrite Off<br><br>            CGPROGRAM<br>            #pragma vertex vert<br>            #pragma fragment fragSobel<br>            #include &quot;UnityCG.cginc&quot;<br><br>            sampler2D _MainTex;<br>            half4 _MainTex_TexelSize;<br>            fixed _EdgeOnly;<br>            fixed4 _EdgeColor;<br>            fixed4 _BackgroundColor;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                half2 uv[9] : TEXCOORD0; <br>            &#125;;<br><br>            fixed luminance(fixed4 color) &#123;<br>                return 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b;<br>            &#125;<br><br>            half Sobel(v2f i) &#123;<br>                const half Gx[9] = &#123;-1, -2, -1 ,0, 0, 0, 1, 2, 1&#125;;<br>                const half Gy[9] = &#123;-1, 0, 1, -2, 0, 2, -1, 0, 1&#125;;<br>                half texColor;<br>                half edgeX = 0;<br>                half edgeY = 0;<br>                for(int it = 0; it &lt; 9; it++)&#123;<br>                    texColor = luminance(tex2D(_MainTex, i.uv[it]));<br>                    edgeX += texColor * Gx[it];<br>                    edgeY += texColor * Gy[it];<br>                &#125;<br>                half edge = 1 - abs(edgeX) - abs(edgeY);<br>                return edge;<br>            &#125;<br><br>            v2f vert(appdata_img v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                half2 uv = v.texcoord;<br><br>                o.uv[0] = uv + _MainTex_TexelSize.xy * half2(-1, -1);<br>                o.uv[1] = uv + _MainTex_TexelSize.xy * half2(0, -1);<br>                o.uv[2] = uv + _MainTex_TexelSize.xy * half2(1, -1);<br>                o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 0);<br>                o.uv[4] = uv + _MainTex_TexelSize.xy * half2(0, 0);<br>                o.uv[5] = uv + _MainTex_TexelSize.xy * half2(1, 0);<br>                o.uv[6] = uv + _MainTex_TexelSize.xy * half2(-1, 1);<br>                o.uv[7] = uv + _MainTex_TexelSize.xy * half2(0, 1);<br>                o.uv[8] = uv + _MainTex_TexelSize.xy * half2(1, 1);<br><br>                return o;<br>            &#125;<br><br>            fixed4 fragSobel(v2f i) : SV_TARGET &#123;<br>                half edge = Sobel(i);<br>                fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4]), edge);<br>                fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);<br>                return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);<br>            &#125;<br>            <br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack Off<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们声明了一个变量 _MainTex_TexelSize，xxx_TexelSize 是 Unity 为我们提供的访问 xxx 纹理对应的每个纹素的大小。由于卷积需要对相邻区域内的纹理进行采样，因此我们需要利用 _MainTex_TexelSize 来计算各个相邻区域的纹理坐标。</p><p>我们在 v2f 结构体中定义了一个维数为 9 的纹理数组，对应了使用 Sobel 算子采样时需要的 9 个邻域纹理坐标。通过把计算采样纹理坐标的代码从片元着色器中转移到顶点着色器中，可以减少运算，提高性能。由于从顶点着色器到片元着色器到插值是线性的，因此这样的转移并不会影响纹理坐标的计算结果。</p><p>我们调用 Sobel 函数计算当前像素的梯度值 edge，并利用该值分别计算了背景为原图和纯色下的颜色值，然后利用 _EdgeOnly 在两者之间插值得到最终的像素值。Sobel 函数利用 Sobel 算子对原图进行边缘检测。在 Sobel 函数中，我们定义了水平方向和竖直方向使用的卷积核 $G_x$ 和 $G_y$。接着，我们依次对 9 个像素进行采样，计算它们的亮度值，再与卷积核 $G_x$ 和 $G_y$ 中对应的权重相乘后，叠加到各自的梯度值上。最后，我们从 1 中减去水平方向和竖直方向的梯度值的绝对值，得到 edge。edge 值越小，表明该位置越可能是一个边缘点。至此，边缘检测过程结束。</p><p>需要注意的是，本次实现的边缘检测仅仅利用了屏幕的颜色信息，而在实际应用中，物体的纹理、阴影等信息均会影响边缘检测的结果，使得结果包含许多非预期的描边。为了得到更加准确的边缘信息，我们往往会在屏幕的深度纹理和法线纹理上进行边缘检测。</p><p><img src="/posts_image/Post_Processing/Post_Processing_4.png" alt="边缘检测结果" title="边缘检测结果"></p><p><img src="/posts_image/Post_Processing/Post_Processing_5.png" alt="只显示边缘的效果" title="只显示边缘的效果"></p><h2 id="高斯模糊">高斯模糊</h2><p>模糊的实现有很多方法，例如均值模糊和中值模糊。均值模糊同样使用了卷积操作，它使用的卷积核中的各个元素值都相等，且相加等于 1，也就是说，卷积后得到的像素值是其邻域内各个像素值的平均值。而中值模糊则是选择邻域内对所有像素排序后的中值替换掉原颜色。一个更高级的模糊方法是高斯模糊。</p><h3 id="高斯滤波">高斯滤波</h3><p>高斯模糊同样利用了卷积计算，它使用的卷积核名为高斯核。高斯核是一个正方形大小的滤波核，其中每个元素的计算都是基于下面的高斯方程：<br>$$<br>G(x, y) = \frac{1}{2\pi\sigma^2}e^{-\frac{x^2 + y^2}{2\sigma^2}}<br>$$</p><p>其中，$\sigma$ 是标准方差（一般取值为 1），$x$ 和 $y$ 分别对应了当前位置到卷积核中心的整数距离。要构建一个高斯核，我们只需要计算高斯核中各个位置对应的高斯值。为了保证滤波后的图像不会变暗，我们需要对高斯核中的权重进行归一化，即让每个权重除以所有权重的和，这样可以保证所有权重的和为 1。因此，高斯函数中 $e$ 前面的系数实际不会对结果有任何影响。下图显示了一个标准方差为 1 的 5 $\times$ 5 大小的高斯核。</p><p><img src="/posts_image/Post_Processing/Post_Processing_6.png" alt="标准方差为 1 的高斯核" title="标准方差为 1 的高斯核"></p><p>高斯方程很好地模拟了邻域每个像素对当前处理像素的影响程度——距离越近，影响越大。高斯核的维数越高，模糊程度越大。使用一个 N $\times$ N 的高斯核对图像进行卷积滤波，就需要 N $\times$ N $\times$ W $\times$ H（W 和 H 分别是图像的宽和高）次纹理采样。当 N 的大小不断增加时，采样次数会变得非常巨大。幸运的是，我们可以把这个二维高斯函数拆分为两个一维函数。也就是说，我们可以使用两个一维的高斯核先后对图像进行滤波，它们得到的结果和直接使用二维高斯核是一样的，但采样次数只需要 2 $\times$ N $\times$ W $\times$ H。我们可以进一步观察到，两个一维高斯核中包含了很多重复的权重。对于一个大小为 5 的一维高斯核，我们实际只需要记录 3 个权重值即可。</p><p>我们将使用上述 5 $\times$ 5 的高斯核对原图像进行高斯模糊。我们将先后调用两个 Pass，第一个 Pass 将会使用竖直方向的一维高斯核对图像进行滤波，第二个 Pass 再使用水平方向的一维高斯核对图像进行滤波，得到最终的目标图像。在实现中，我们还将利用图像缩放来进一步提高性能，并通过调整高斯滤波的应用次数来控制模糊程度（次数越多，图像越模糊）。</p><h3 id="实现-2">实现</h3><p>我们首先来编写 GaussianBlur.cs 脚本。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GaussianBlur</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader gaussianBlurShader;<br><span class="hljs-keyword">private</span> Material gaussianBlurMaterial = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial);<br><span class="hljs-keyword">return</span> gaussianBlurMaterial;<br>&#125;  <br>&#125;<br><br><span class="hljs-comment">// Blur iterations - larger number means more blur.</span><br>[<span class="hljs-meta">Range(0, 4)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> iterations = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// Blur spread for each iteration - larger value means more blur</span><br>[<span class="hljs-meta">Range(0.2f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> blurSpread = <span class="hljs-number">0.6f</span>;<br><br>[<span class="hljs-meta">Range(1, 8)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> downSample = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 1st edition: just apply blur</span><br><span class="hljs-comment">//void OnRenderImage(RenderTexture src, RenderTexture dest) &#123;</span><br><span class="hljs-comment">//if (material != null) &#123;</span><br><span class="hljs-comment">//int rtW = src.width;</span><br><span class="hljs-comment">//int rtH = src.height;</span><br><span class="hljs-comment">//RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//// Render the vertical pass</span><br><span class="hljs-comment">//Graphics.Blit(src, buffer, material, 0);</span><br><span class="hljs-comment">//// Render the horizontal pass</span><br><span class="hljs-comment">//Graphics.Blit(buffer, dest, material, 1);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//RenderTexture.ReleaseTemporary(buffer);</span><br><span class="hljs-comment">//&#125; else &#123;</span><br><span class="hljs-comment">//Graphics.Blit(src, dest);</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//&#125; </span><br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 2nd edition: scale the render texture</span><br><span class="hljs-comment">//void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;</span><br><span class="hljs-comment">//if (material != null) &#123;</span><br><span class="hljs-comment">//int rtW = src.width/downSample;</span><br><span class="hljs-comment">//int rtH = src.height/downSample;</span><br><span class="hljs-comment">//RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="hljs-comment">//buffer.filterMode = FilterMode.Bilinear;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//// Render the vertical pass</span><br><span class="hljs-comment">//Graphics.Blit(src, buffer, material, 0);</span><br><span class="hljs-comment">//// Render the horizontal pass</span><br><span class="hljs-comment">//Graphics.Blit(buffer, dest, material, 1);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//RenderTexture.ReleaseTemporary(buffer);</span><br><span class="hljs-comment">//&#125; else &#123;</span><br><span class="hljs-comment">//Graphics.Blit(src, dest);</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 3rd edition: use iterations for larger blur</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">int</span> rtW = src.width/downSample;<br><span class="hljs-built_in">int</span> rtH = src.height/downSample;<br><br>RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br>buffer0.filterMode = FilterMode.Bilinear;<br><br>Graphics.Blit(src, buffer0);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; iterations; i++) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_BlurSize&quot;</span>, <span class="hljs-number">1.0f</span> + i * blurSpread);<br><br>RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// Render the vertical pass</span><br>Graphics.Blit(buffer0, buffer1, material, <span class="hljs-number">0</span>);<br><br>RenderTexture.ReleaseTemporary(buffer0);<br>buffer0 = buffer1;<br>buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// Render the horizontal pass</span><br>Graphics.Blit(buffer0, buffer1, material, <span class="hljs-number">1</span>);<br><br>RenderTexture.ReleaseTemporary(buffer0);<br>buffer0 = buffer1;<br>&#125;<br><br>Graphics.Blit(buffer0, dest);<br>RenderTexture.ReleaseTemporary(buffer0);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>blurSpread 和 downSample 都是出于性能的考虑。在高斯核维数不变的情况下，_BlurSize 越大，模糊程度越高，但采样数却不会收到影响，但过大的 _BlurSize 值会造成虚影。而 downSample 越大，需要处理的像素数越少，同时也能进一步提高模糊程度，但过大的 downSample 可能会使图像像素化。</p><p>第一版中，我们利用 RenderTexture.GetTemporary 函数分配了一块与屏幕图像大小相同的缓冲区。这是因为，高斯模糊需要调用两个 Pass，我们需要使用一块中间缓存来存储第一个 Pass 执行完毕后得到的模糊结果。如代码所示，我们首先调用 Graphics.Blit(src, buffer, material, 0)，使用 Shader 中的第一个 Pass（即使用竖直方向的一维高斯核进行滤波）对 src 进行处理，并将结果存储在了 buffer 中。然后，再调用 Graphics.Blit(buffer, dest, material, 1)，使用 Shader 中的第二个 Pass（即使用水平方向的一维高斯核进行滤波）对 buffer 进行处理，返回最终的屏幕图像。最后，我们还需要调用 RenderTexture.ReleaseTemporary 来释放之前分配的缓存。</p><p>第二版中，我们在声明缓冲区的大小时，使用了小于原屏幕分辨率的尺寸，并将该临时渲染纹理的滤波模式设置为双线性。这样，在调用第一个 Pass 时，我们需要处理的像素个数就是原来的几分之一。对图像进行降采样不仅可以减少需要处理的像素的个数，提高性能，而且适当的降采样往往还可以得到更好的模糊效果。尽管 downSample 值越大，性能越好，但过大的 downSample 可能会造成图像像素化。</p><p>最后一个版本中，我们考虑了高斯模糊的迭代次数。上面的代码显示了如何利用两个临时缓存在迭代之间进行交替的过程。在迭代开始前，我们首先定义了第一个缓存 buffer0，并把 src 中的图像缩放后存储到 buffer0 中。在迭代过程中，我们又定义了第二个缓存 buffer1。在执行第一个 Pass 时，输入是 buffer0，输出是 buffer1，完毕后首先把 buffer0 释放，再把结果值 buffer1 存储到 buffer0 中，重新分配 buffer1，然后再调用第二个 Pass，重复上述过程。迭代完成后，buffer0 将存储最终的图像，我们再利用 Graphics.Blit(buffer0, dest) 把上述结果显示到屏幕上，并释放缓存。</p><p>下面，我们来实现 Shader 部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter12/Chapter12-GaussianBlur&quot; &#123;<br><br>    Properties &#123;<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _BlurSize (&quot;Blur Size&quot;, Float) = 1.0<br>    &#125;<br><br>    SubShader &#123;<br>        CGINCLUDE<br>        #include &quot;UnityCG.cginc&quot;<br><br>        sampler2D _MainTex;<br>        half4 _MainTex_TexelSize;<br>        float _BlurSize;<br><br>        struct v2f &#123;<br>            float4 pos : SV_POSITION;<br>            half2 uv[5] : TEXCOORD0;<br>        &#125;;<br><br>        v2f vertBlurVertical(appdata_img v) &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br>            half2 uv = v.texcoord;<br><br>            o.uv[0] = uv;<br>            o.uv[1] = uv + float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize;<br>            o.uv[2] = uv - float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize;<br>            o.uv[3] = uv + float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize;<br>            o.uv[4] = uv - float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize;<br>            return o;<br>        &#125;<br><br>        v2f vertBlurHorizontal(appdata_img v) &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br>            half2 uv = v.texcoord;<br><br>            o.uv[0] = uv;<br>            o.uv[1] = uv + float2(0.0, _MainTex_TexelSize.x * 1.0) * _BlurSize;<br>            o.uv[2] = uv - float2(0.0, _MainTex_TexelSize.x * 1.0) * _BlurSize;<br>            o.uv[3] = uv + float2(0.0, _MainTex_TexelSize.x * 2.0) * _BlurSize;<br>            o.uv[4] = uv - float2(0.0, _MainTex_TexelSize.x * 2.0) * _BlurSize;<br>            return o;<br>        &#125;<br><br>        fixed4 fragBlur(v2f i) : SV_Target &#123;<br>            float weight[3] = &#123;0.4026, 0.2442, 0.0545&#125;;<br>            fixed3 sum = tex2D(_MainTex, i.uv[0]).rgb * weight[0];<br><br>            for(int it = 1; it &lt; 3; it++) &#123;<br>                sum += tex2D(_MainTex, i.uv[it]).rgb * weight[it];<br>                sum += tex2D(_MainTex, i.uv[2 * it]).rgb * weight[it];<br>            &#125;<br>            return fixed4(sum, 1.0);<br>        &#125;<br><br><br>        ENDCG<br><br>        ZTest Always Cull Off ZWrite Off<br><br>        Pass &#123;<br>            Name &quot;GAUSSIAN_BLUR_VERTICAL&quot;<br><br>            CGPROGRAM<br><br>            #pragma vertex vertBlurVertical<br>            #pragma fragment fragBlur<br><br>            ENDCG<br>        &#125;<br><br>        Pass &#123;<br>            Name &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;<br><br>            CGPROGRAM<br><br>            #pragma vertex vertBlurHorizontal<br>            #pragma fragment fragBlur<br><br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    FallBack Off<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在 SubShader 块中用 CGINCLUDE 和 ENDCG 语义来定义一系列代码，这些代码不需要包含在任何 Pass 语义块中，在使用时，我们只需要在 Pass 中直接指定需要使用的顶点着色器和片元着色器函数名即可。CGINCLUDE 类似于 C++ 中头文件的功能。由于高斯模糊需要定义两个 Pass，但它们使用的片元着色器代码是完全相同的，使用 CGINCLUDE 可以避免我们编写两个完全一样的 frag 函数。</p><p>我们利用了 5 $\times$ 5 大小的高斯核对原图像进行高斯模糊，而一个 5 $\times$ 5 的二维高斯核可以拆分成两个大小为 5 的一维高斯核，因此我们只需要计算 5 个纹理坐标即可。为此，我们在 v2f 结构体中定义了一个 5 维的纹理坐标数组。数组的第一个坐标存储了当前的采样纹理，而剩余的四个坐标则是高斯模糊中对邻域采样时使用的纹理坐标。我们还和属性 _BlurSize 相乘来控制采样距离。在高斯核维数不变的情况下，_BlurSize 越大，模糊程度越高，但采样数却不会受到影响。但过大的 _BlurSize 值会造成虚影，这可能并不是我们希望的。通过把计算采样纹理坐标的代码从片元着色器中转移到顶点着色器中，可以减少运算，提高性能。由于从顶点着色器到片元着色器的插值是线性的，因此这样的转移并不会影响纹理坐标的计算结果。</p><p>一个 5 $\times$ 5 的二维高斯核可以拆分成两个大小为 5 的一维高斯核，并且由于它的对称性，我们只需要记录 3 个高斯权重，也就是代码中的 weight 变量。我们首先声明了各个邻域像素对应的权重 weight，然后将结果值 sum 初始化为当前的像素值乘以它的权重值。根据对称性，我们进行了两次迭代，每次迭代包含了两次纹理采样，并把像素值和权重相乘后的结果叠加到 sum 中。最后，函数返回滤波结果 sum。</p><p>我们为两个 Pass 使用了 NAME 语义定义了它们的名字。这是因为，高斯模糊是非常常见的图像处理操作，很多屏幕特效都是建立在它的基础上的，例如 Bloom 效果。为 Pass 定义名字，可以在其他 Shader 中直接通过它们的名字来使用该 Pass，而不需要再重复编写代码。</p><p><img src="/posts_image/Post_Processing/Post_Processing_7.png" alt="高斯模糊后的效果" title="高斯模糊后的效果"></p><h2 id="Bloom-效果">Bloom 效果</h2><p>Bloom 特效是游戏中常见的一种屏幕效果。这种特效可以模拟真实摄像机的一种图像效果，它让画面中较亮的区域“扩散”到周围的区域中，造成一种朦胧的效果。Bloom 的实现原理非常简单：我们首先根据与一个阈值提取出图像中的较亮区域，把它存储在一张渲染纹理中，再利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线扩散的效果，最后再将其和原图像进行混合，得到最终的效果。</p><p>我们首先来编写 Bloom.cs 脚本。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bloom</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader bloomShader;<br><span class="hljs-keyword">private</span> Material bloomMaterial = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>bloomMaterial = CheckShaderAndCreateMaterial(bloomShader, bloomMaterial);<br><span class="hljs-keyword">return</span> bloomMaterial;<br>&#125;  <br>&#125;<br><br><span class="hljs-comment">// Blur iterations - larger number means more blur.</span><br>[<span class="hljs-meta">Range(0, 4)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> iterations = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// Blur spread for each iteration - larger value means more blur</span><br>[<span class="hljs-meta">Range(0.2f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> blurSpread = <span class="hljs-number">0.6f</span>;<br><br>[<span class="hljs-meta">Range(1, 8)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> downSample = <span class="hljs-number">2</span>;<br><br>[<span class="hljs-meta">Range(0.0f, 4.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> luminanceThreshold = <span class="hljs-number">0.6f</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_LuminanceThreshold&quot;</span>, luminanceThreshold);<br><br><span class="hljs-built_in">int</span> rtW = src.width/downSample;<br><span class="hljs-built_in">int</span> rtH = src.height/downSample;<br><br>RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br>buffer0.filterMode = FilterMode.Bilinear;<br><br>Graphics.Blit(src, buffer0, material, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; iterations; i++) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_BlurSize&quot;</span>, <span class="hljs-number">1.0f</span> + i * blurSpread);<br><br>RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// Render the vertical pass</span><br>Graphics.Blit(buffer0, buffer1, material, <span class="hljs-number">1</span>);<br><br>RenderTexture.ReleaseTemporary(buffer0);<br>buffer0 = buffer1;<br>buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// Render the horizontal pass</span><br>Graphics.Blit(buffer0, buffer1, material, <span class="hljs-number">2</span>);<br><br>RenderTexture.ReleaseTemporary(buffer0);<br>buffer0 = buffer1;<br>&#125;<br><br>material.SetTexture (<span class="hljs-string">&quot;_Bloom&quot;</span>, buffer0);  <br>Graphics.Blit (src, dest, material, <span class="hljs-number">3</span>);  <br><br>RenderTexture.ReleaseTemporary(buffer0);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>由于 Bloom 效果是建立在高斯模糊的基础上的，因此脚本中提供的参数和高斯模糊中的几乎完全一样，我们只增加了一个新的参数 luminanceThreshold 来控制提取较亮区域时使用的阈值大小；尽管在绝大多数情况下，图像的亮度不会超过 1，但如果我们开启了 HDR，硬件会允许我们把颜色值存储在一个更高精度范围的缓冲中，此时像素的亮度值可能会超过 1。因此，在这里我们把 luminanceThreshold 的值规定在 [0, 4] 范围内。</p><p>Bloom 效果需要 3 个步骤：首先，提取图像中较亮的区域，因此，我们没有直接对 src 进行降采样，而是通过调用 Graphics.Blit(src, buffer0, material, 0) 来使用 Shader 中的第一个 Pass 提取图像中较亮区域，提取到的较亮区域将存储在 buffer0 中。然后，我们进行高斯模糊迭代处理，这些 Pass 对应了 Shader 的第二个和第三个 Pass。模糊后的较亮区域将会存储在 buffer0 中，此时，我们再把 buffer0 传递给材质中的 _Bloom 纹理属性，并调用 Graphics.Blit(src, dest, material, 3) 使用 Shader 中的第四个 Pass 来进行最后的混合，将结果存储在目标渲染纹理 dest 中。最后，释放临时缓存。</p><p>下面我们来实现 Shader 的部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter12/Chapter12-Bloom&quot; &#123;<br><br>    Properties &#123;<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Bloom (&quot;Bloom (RGB)&quot;, 2D) = &quot;black&quot; &#123;&#125;<br>        _LuminanceThreshold (&quot;Luminance Threshold&quot;, Float) = 0.5<br>        _BlurSize (&quot;Blur Size&quot;, Float) = 1.0<br>    &#125;<br><br>    SubShader &#123;<br>        CGINCLUDE<br>        #include &quot;UnityCG.cginc&quot;<br><br>        sampler2D _MainTex;<br>        half4 _MainTex_TexelSize;<br>        sampler2D _Bloom;<br>        float _LuminanceThreshold;<br>        float _BlurSize;<br><br>        struct v2f &#123;<br>            float4 pos : SV_POSITION;<br>            half2 uv : TEXCOORD0;<br>        &#125;;<br><br>        v2f vertExtractBright (appdata_img v) &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br>            o.uv = v.texcoord;<br>            return o;<br>        &#125;<br><br>        fixed luminance (fixed4 color) &#123;<br>            return 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b;<br>        &#125;<br><br>        fixed4 fragExtractBright (v2f i) : SV_Target &#123;<br>            fixed4 c = tex2D(_MainTex, i.uv);<br>            fixed val = clamp(luminance(c) - _LuminanceThreshold, 0.0, 1.0);<br>            return c * val;<br>        &#125;<br><br>        struct v2fBloom &#123;<br>            float4 pos : SV_POSITION;<br>            half4 uv : TEXCOORD0;<br>        &#125;;<br><br>        v2fBloom vertBloom (appdata_img v) &#123;<br>            v2fBloom o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br>            o.uv.xy = v.texcoord;<br>            o.uv.zw = v.texcoord;<br><br>            #if UNITY_UV_STARTS_AT_TOP<br>            if(_MainTex_TexelSize.y &lt; 0.0)<br>                o.uv.w = 1.0 - o.uv.w;<br>            #endif<br><br>            return o;<br>        &#125;<br><br>        fixed4 fragBloom (v2fBloom i) : SV_TARGET &#123;<br>            return tex2D(_MainTex, i.uv.xy) + tex2D(_Bloom, i.uv.zw);<br>        &#125;<br><br>        ENDCG<br><br>        ZTest Always Cull Off ZWrite Off<br><br>        Pass &#123;<br><br>            CGPROGRAM<br>            #pragma vertex vertExtractBright<br>            #pragma fragment fragExtractBright<br>            ENDCG<br>        &#125;<br><br>        UsePass &quot;Custom/Chapter12/Chapter12-GaussianBlur/GAUSSIAN_BLUR_VERTICAL&quot;<br>        UsePass &quot;Custom/Chapter12/Chapter12-GaussianBlur/GAUSSIAN_BLUR_HORIZONTAL&quot;<br><br>        Pass &#123;<br>            CGPROGRAM<br>            #pragma vertex vertBloom<br>            #pragma fragment fragBloom<br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    FallBack Off<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用的顶点着色器与之前的有所不同，我们定义了两个纹理坐标，并存储在同一个类型为 half4 的变量 uv 中。它的 xy 分量对应了 _MainTex，即原图像的纹理坐标。而它的 zw 分量是 _Bloom，即模糊后的较亮区域的纹理坐标。我们需要对这个纹理坐标进行平台差异化处理。第二个和第三个 Pass 我们直接使用了上面高斯模糊中定义的两个 Pass，这是通过 UsePass 语义指明它们的 Pass 名来实现的。需要注意的是，由于 Unity 内部会把所有 Pass 的 Name 转换成大写字母表示，因此在使用 UsePass 命令时我们必须使用大写形式的名字。</p><p><img src="/posts_image/Post_Processing/Post_Processing_8.png" alt="Bloom 效果" title="Bloom 效果"></p><h2 id="运动模糊">运动模糊</h2><p>运动模糊是真实世界中的摄像机的一种效果。如果在摄像机曝光时，拍摄场景发生了变化，就会产生模糊的画面。运动模糊在我们的日常生活中是非常常见的，只要留心观察，就可以发现无论是体育报道还是各个电影里，都有运动模糊的身影。运动模糊效果可以让物体运动看起来更加真实平滑，但在计算机产生的图像中，由于不存在曝光这一物理现象，渲染出来的图像往往都是棱角分明，缺少运动模糊。在一些诸如赛车类型的游戏中，为画面添加运动模糊是一种常见的处理方法。</p><p>运动模糊的实现有多种方法。一种实现方法是利用一块<strong>积累缓存（accumulation buffer）<strong>来混合多张连续的图像。当物体快速移动产生多张图像后，我们取它们之间的平均值作为最后的运动模糊图像。然而，这种暴力的方法对性能的消耗很大，因为想要获取多张帧图像往往意味着我们需要在同一帧里渲染多次场景。另一种应用广泛的方法是创建和使用</strong>速度缓存（velocity buffer）</strong>，这个缓存中存储了各个像素当前的运动速度，然后利用该值来决定模糊的方向和大小。</p><p>在本次实现中，我们将使用类似上述第一种方法来模拟运动模糊的效果。我们不需要在一帧中把场景渲染多次，但需要保存之前的渲染结果，不断把当前的渲染图像叠加到之前的渲染图像中，从而产生一种运动轨迹的视觉效果。这种方法与原始的利用累计缓存的方法相比性能更好，但模糊效果可能会略有影响。</p><p>我们首先来编写 MotionBlur.cs 脚本。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MotionBlur</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader motionBlurShader;<br><span class="hljs-keyword">private</span> Material motionBlurMaterial = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);<br><span class="hljs-keyword">return</span> motionBlurMaterial;<br>&#125;  <br>&#125;<br><br>[<span class="hljs-meta">Range(0.0f, 0.9f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> blurAmount = <span class="hljs-number">0.5f</span>;<br><br><span class="hljs-keyword">private</span> RenderTexture accumulationTexture;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span> &#123;<br>DestroyImmediate(accumulationTexture);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// Create the accumulation texture</span><br><span class="hljs-keyword">if</span> (accumulationTexture == <span class="hljs-literal">null</span> || accumulationTexture.width != src.width || accumulationTexture.height != src.height) &#123;<br>DestroyImmediate(accumulationTexture);<br>accumulationTexture = <span class="hljs-keyword">new</span> RenderTexture(src.width, src.height, <span class="hljs-number">0</span>);<br>accumulationTexture.hideFlags = HideFlags.HideAndDontSave;<br>Graphics.Blit(src, accumulationTexture);<br>&#125;<br><br><span class="hljs-comment">// We are accumulating motion over frames without clear/discard</span><br><span class="hljs-comment">// by design, so silence any performance warnings from Unity</span><br>accumulationTexture.MarkRestoreExpected();<br><br>material.SetFloat(<span class="hljs-string">&quot;_BlurAmount&quot;</span>, <span class="hljs-number">1.0f</span> - blurAmount);<br><br>Graphics.Blit (src, accumulationTexture, material);<br>Graphics.Blit (accumulationTexture, dest);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>blurAmount 的值越大，运动拖尾的效果就越明显，为了防止拖尾效果完全替代当前帧的渲染结果，我们把它的值截取在 0.0~0.9 范围内。我们在脚本不运行时，即调用 OnDisable 函数时，立即销毁 accumulationTexture。这是因为，我们希望在下一次开始应用运动模糊时重新叠加图像。在确认材质可用后，我们首先判断用于混合图像的 accumulationTexture 是否满足条件。我们不仅判断它是否为空，还判断它是否与当前的屏幕分辨率相等，如果不满足，就说明我们需要重新创建一个适合于当前分辨率的 accumulationTexture 变量。创建完毕后，由于我们会自己控制该变量的销毁，因此可以把它的 hideFlags 设置为 HideFlags.HideAndDontSave，这意味着这个变量不会显示在 Hierarchy 中，也不会保存到场景中。然后，我们使用当前的帧图像初始化 accumulationTexture（使用 Graphics.Blit(src, accumulationTexture) 代码）。</p><p>当得到了有效的 accumulationTexture 变量后，我们调用了 accumulationTexture.MarkRestoreExpected 函数来表明我们需要进行一个渲染纹理的恢复操作。**恢复操作（restore operation）**发生在渲染到纹理而该纹理又没有被提前清空或销毁的情况下。在本例中，我们每次调用 OnRenderImage 时都需要把当前的帧图像和 accumulationTexture 中的图像混合，accumulationTexture 纹理不需要提前清空，因为它保存了我们之前的混合结果。然后，我们将参数传递给材质，并调用 Graphics.Blit(src, accumulationTexture, material) 把当前的屏幕图像 src 叠加到 accumulationTexture 中。最后使用 Graphics.Blit(accumulationTexture, dest) 把结果显示到屏幕上。</p><p>下面，我们来实现 Shader 部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter12/Chapter12-MotionBlur&quot; &#123;<br><br>    Properties &#123;<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _BlurAmount (&quot;Blur Amount&quot;, Float) = 1.0<br>    &#125;<br><br>    SubShader &#123;<br>        CGINCLUDE<br>        #include &quot;UnityCG.cginc&quot;<br><br>        sampler2D _MainTex;<br>        fixed _BlurAmount;<br><br>        struct v2f &#123;<br>            float4 pos : SV_POSITION;<br>            float2 uv : TEXCOORD0;<br>        &#125;;<br><br>        v2f vert(appdata_img v) &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br>            o.uv = v.texcoord;<br>            return o;<br>        &#125;<br><br>        fixed4 fragRGB (v2f i) : SV_Target &#123;<br>            return fixed4(tex2D(_MainTex, i.uv).rgb, _BlurAmount);<br>        &#125;<br><br>        half4 fragA (v2f i) : SV_Target &#123;<br>            return tex2D(_MainTex, i.uv);<br>        &#125;<br><br>        ENDCG<br>        <br>        ZTest Always Cull Off ZWrite Off<br><br>        Pass &#123;<br>            Blend SrcAlpha OneMinusSrcAlpha<br><br>            ColorMask RGB<br><br>            CGPROGRAM<br>            #pragma vertex vert<br>            #pragma fragment fragRGB<br>            ENDCG<br>        &#125;<br><br>        Pass &#123;<br>            Blend One Zero<br>            ColorMask A<br>            CGPROGRAM<br>            #pragma vertex vert<br>            #pragma fragment fragA<br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    FallBack Off<br>&#125;<br></code></pre></td></tr></table></figure><p>RGB 通道版本的片元着色器对当前图像进行采样，并将其 A 通道的值设为 _BlurAmount，以便在后面混合时可以使用它的透明通道进行混合。A 通道版本的代码就更简单了，直接返回采样结果。实际上，这个版本只是为了维护渲染纹理的透明通道值，不让其受到混合时使用的透明度值的影响。然后，我们定义了运动模糊所需的 Pass。在本例中我们需要两个 Pass，一个用于更新渲染纹理的 RGB 通道，第一个用于更新 A 通道。之所以要把 A 通道和 RGB 通道分开，是因为在更新 RGB 时我们需要设置它的 A 通道来混合图像，但又不希望 A 通道的值写入渲染纹理中。</p><p>本次是对运动模糊的一种简单实现。我们混合了连续帧之间的图像，这样得到一张具有模糊拖尾的图像。然而，当物体运动速度过快时，这种方法可能会造成单独的帧图像变得可见。以后我们会学习如何利用深度纹理重建速度来模拟运动的模糊效果。</p><p><img src="/posts_image/Post_Processing/Post_Processing_9.png" alt="运动模糊效果" title="运动模糊效果"></p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Post Processing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动画效果</title>
    <link href="/posts/%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/"/>
    <url>/posts/%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="Unity-Shader-中的内置变量（时间篇）">Unity Shader 中的内置变量（时间篇）</h2><p>动画效果往往都是把时间添加到一些变量的计算中，以便在时间变化时画面也可以随之变化。Unity Shader 提供了一系列关于时间的内置变量来允许我们方便地在 Shader 中访问运行时间，实现各种动画效果。下表给出了这些内置的时间变量。</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">_Time</td><td style="text-align:left">float4</td><td style="text-align:left">t 是自该场景加载开始所经过的时间，4 个分量的值分别是(t/20, t, 2t, 3t)</td></tr><tr><td style="text-align:left">_SinTime</td><td style="text-align:left">float4</td><td style="text-align:left">t 是时间的正弦值，4 个分量的值分别是(t/8, t/4, t/2, t)</td></tr><tr><td style="text-align:left">_CosTime</td><td style="text-align:left">float4</td><td style="text-align:left">t 是时间的余弦值，4 个分量的值分别是(t/8, t/4, t/2, t)</td></tr><tr><td style="text-align:left">unity_DeltaTime</td><td style="text-align:left">float4</td><td style="text-align:left">dt 是时间增量，4 个分量的值分别是(dt, 1/dt, smoothDt, 1/smoothDt)</td></tr></tbody></table><h2 id="纹理动画">纹理动画</h2><p>纹理动画在游戏中的应用非常广泛。尤其在各种资源都比较局限的移动平台上，我们往往会使用纹理动画来代替复杂的粒子系统等模拟各种动画效果。</p><h3 id="序列帧动画">序列帧动画</h3><p>最常见的纹理动画之一就是序列帧动画。序列帧动画的原理非常简单，它像放电影一样，依次播放一系列关键帧图像，当播放速度达到一定数值时，看起来就是一个连续的动画。它的优点在于灵活性很强，我们不需要进行任何物理计算就可以得到非常细腻的动画效果。而它的缺点也很明显，由于序列帧中每张关键帧图像都不一样，因此要制作一张出色的序列帧纹理所需要的美术工程量也比较大。</p><p>要想实现序列帧动画，我们要先提供一张包含了关键帧图像的图像。</p><p><img src="/posts_image/Animation_Effects/Animation_Effects_1.png" alt="序列帧图像" title="序列帧图像"></p><p>上述图像包含了 8 $\times$ 8 张关键帧图像，它们的大小相同，而且播放顺序为从左到右、从上到下。下图给出了不同时刻播放的不同动画效果。</p><p><img src="/posts_image/Animation_Effects/Animation_Effects_2.png" alt="使用序列帧动画来实现爆炸效果" title="使用序列帧动画来实现爆炸效果"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter11/Chapter11-ImageSequenceAnimation&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)<br>        _MainTex (&quot;Image Sequence&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _HorizontalAmount (&quot;Horizontal Amount&quot;, Float) = 8<br>        _VerticalAmount (&quot;Vertical Amount&quot;, Float) = 8<br>        _Speed (&quot;Speed&quot;, Range(1, 100)) = 30<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;<br><br>        Pass &#123;<br>            Tags &#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;<br>            ZWrite Off<br>            Blend SrcAlpha OneMinusSrcAlpha<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;UnityCG.cginc&quot;<br><br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            float _HorizontalAmount;<br>            float _VerticalAmount;<br>            float _Speed;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float2 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float2 uv : TEXCOORD0;<br>            &#125;;<br>            <br>            v2f vert(a2v v)&#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET<br>            &#123;<br>                float time = floor(_Time.y * _Speed);<br>                float row = floor(time / _HorizontalAmount);<br>                float column = time - row * _HorizontalAmount;<br><br>                //half2 uv = float2(i.uv.x / _HorizontalAmount, i.uv.y / _VerticalAmount);<br>                //uv.x += column / _HorizontalAmount;<br>                //uv.y -= row / _VerticalAmount;<br>                half2 uv = i.uv + half2(column, -row);<br>                uv.x /= _HorizontalAmount;<br>                uv.y /= _VerticalAmount;<br><br>                fixed4 c = tex2D(_MainTex, uv);<br>                c.rgb *= _Color;<br><br>                return c;<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Transparent/VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>_MainTex 就是包含了所有关键帧图像的纹理。_HorizontalAmount 和 _VerticalAmount 分别代表了该图像在水平方向和竖直方向包含的关键帧图像的个数。而 _Speed 属性用于控制序列帧动画的播放速度。由于序列帧图像通常包含了透明通道，因此可以被当成是一个半透明对象。在这里我们使用半透明的“标配”来设置它的 SubShader 标签，即把 Queue 和 RenderType 设置成 Transparent，把 IgnoreProjector 设置为 True。在 Pass 中，我们使用 Blend 命令来开启并设置混合模式，同时关闭了深度写入。</p><p>要播放帧动画，从本质上来说，我们需要计算出每个时刻需要播放的关键帧在纹理中的位置。而由于序列帧纹理都是按行按列排列的，因此这个位置可以认为是该关键帧所在的行列索引数。因此，在片元着色器代码的前三行中我们计算了行列数，其中使用了 Unity 内置时间变量 _Time，_Time.y 就是自该场景加载后所经过的时间。我们首先把 _Time.y 和速度属性 _Speed  相乘来得到模拟的时间，并使用 CG 的 floor 函数对结果值取整来得到整数时间 time。然后，使用 time 除以 _HorizontalAmount 的结果值的商来作为当前对应的行索引，除法结果的余数则是列索引。接下来，我们需要使用行列索引值来构建真正的采样坐标。由于序列帧图像包含了许多关键帧图像，这意味着采样坐标需要映射到每个关键帧图像的坐标范围内。我们可以首先把原纹理坐标 i.uv 按行数和列数进行等分，得到每个子图像的纹理坐标范围。然后，我们需要使用当前的行列数对上面的结果进行偏移，得到当前子图像的纹理坐标。需要注意的是，对竖直方向的坐标偏移需要使用减法，这是因为在 Unity 中纹理坐标竖直方向的顺序（从下到上逐渐增大）和序列帧纹理中的顺序（播放顺序是从上到下）是相反的。这对应了上面代码中注释掉的代码部分。我们可以把上述过程中的除法整合到一起，就得到了注释下方的代码。这样，我们就得到了真正的纹理采样坐标。</p><h3 id="滚动的背景">滚动的背景</h3><p>很多 2D 游戏都使用了不断滚动的背景来模拟游戏角色在场景中的穿梭，这些背景往往包含了多个层（layers）来模拟一种视差效果。而这些背景的实现往往就是利用了纹理动画。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter11/Chapter11-ScrollingBackground&quot;<br>&#123;<br>    Properties<br>    &#123;<br>       _MainTex (&quot;Base Layer (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>       _DetailTex (&quot;2nd Layer (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>       _ScrollX (&quot;Base layer Scroll Speed&quot;, Float) = 1.0<br>       _Scroll2X (&quot;2nd layer Scroll Speed&quot;, Float) = 1.0<br>       _Multiplier (&quot;Layer Multiplier&quot;, Float) = 1<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags &#123;&quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;<br>        Pass &#123;<br>            Tags &#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;<br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;UnityCG.cginc&quot;<br>            <br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            sampler2D _DetailTex;<br>            float4 _DetailTex_ST;<br>            float _ScrollX;<br>            float _Scroll2X;<br>            float _Multiplier;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float4 uv : TEXCOORD0;<br>            &#125;;<br><br>            v2f vert(a2v v)&#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                //frac函数返回标量或每个矢量中各分量的小数部分<br>                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex) + frac(float2(_ScrollX, 0.0) * _Time.y);<br>                o.uv.zw = TRANSFORM_TEX(v.texcoord, _DetailTex) + frac(float2(_Scroll2X, 0.0) * _Time.y);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET<br>            &#123;<br>                fixed4 firstLayer = tex2D(_MainTex, i.uv.xy);<br>                fixed4 secondLayer = tex2D(_DetailTex, i.uv.zw);<br>                fixed4 c = lerp(firstLayer, secondLayer, secondLayer.a);<br>                c.rgb *= _Multiplier;<br>                return c;<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中，_MainTex 和 _DetailTex 分别是第一层（较远）和第二层（较近）的背景纹理，而 _ScrollX 和 _Scroll2X 对应了各自的水平滚动速度。_Multiplier 参数则用于控制纹理的整体亮度。我们首先进行了最基本的顶点变换，把顶点从模型空间变换到裁剪空间中。然后我们计算了两层背景纹理的纹理坐标。为此，我们首先利用 TRANSFORM_TEX 来得到初始的纹理坐标。然后，我们利用内置的 _Time.y 变量在水平方向上对纹理坐标进行偏移，以此来达到滚动的效果。我们把两张纹理的纹理坐标存储在同一个变量 o.uv 中，以减少占用的插值寄存器空间。</p><p>我们首先分别利用 i.uv.xy 和 <a href="http://i.uv.zw">i.uv.zw</a> 对两张背景纹理进行采样。然后，使用第二层纹理的透明通道来混合两张纹理，这使用了 CG 的 lerp 函数。最后，我们使用 _Multiplier 参数和输出颜色进行相乘，以调整背景亮度。</p><p><img src="/posts_image/Animation_Effects/Animation_Effects_3.png" alt="无限滚动的背景" title="无限滚动的背景"></p><h2 id="顶点动画">顶点动画</h2><h3 id="流动的河流">流动的河流</h3><p>河流的模拟是顶点动画最常见的应用之一。它的原理通常就是使用正弦函数等来模拟水流的波动效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter11/Chapter11-Water&quot;<br>&#123;<br>    Properties &#123;<br>_MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>_Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)<br>_Magnitude (&quot;Distortion Magnitude&quot;, Float) = 1<br> _Frequency (&quot;Distortion Frequency&quot;, Float) = 1<br> _InvWaveLength (&quot;Distortion Inverse Wave Length&quot;, Float) = 10<br> _Speed (&quot;Speed&quot;, Float) = 0.5<br>&#125;<br>SubShader &#123;<br>// Need to disable batching because of the vertex animation<br>Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;<br><br>Pass &#123;<br>Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>ZWrite Off<br>Blend SrcAlpha OneMinusSrcAlpha<br>Cull Off<br><br>CGPROGRAM  <br>#pragma vertex vert <br>#pragma fragment frag<br><br>#include &quot;UnityCG.cginc&quot; <br><br>sampler2D _MainTex;<br>float4 _MainTex_ST;<br>fixed4 _Color;<br>float _Magnitude;<br>float _Frequency;<br>float _InvWaveLength;<br>float _Speed;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float2 uv : TEXCOORD0;<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br>v2f o;<br><br>float4 offset;<br>offset.yzw = float3(0.0, 0.0, 0.0);<br>offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;<br>o.pos = UnityObjectToClipPos(v.vertex + offset);<br><br>o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>o.uv +=  float2(0.0, _Time.y * _Speed);<br><br>return o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>fixed4 c = tex2D(_MainTex, i.uv);<br>c.rgb *= _Color.rgb;<br><br>return c;<br>&#125; <br><br>ENDCG<br>&#125;<br>&#125;<br>FallBack &quot;Transparent/VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中，_MainTex 是河流纹理，_Color 用于控制整体颜色，_Magnitude 用于控制水流波动的幅度，_Frequency 用于控制波动频率，_InvWaveLength 用于控制波长的倒数（_InvWaveLength 越大，波长越小），_Speed 用于控制河流纹理的移动速度。在上面的设置中，我们除了为透明效果设置 Queue、IgnoreProjector 和 RenderType 外，还设置了一个新的标签——<strong>DisableBatching</strong>。一些 SubShader 在使用 Unity 的批处理功能时会出现问题，这时可以通过该标签来直接指明是否对该 SubShader 使用批处理。而这些需要特殊处理的 Shader 通常就是指包含了模型空间的顶点动画的 Shader。这是因为，批处理会合并所有相关的模型，而这些模型各自的模型空间就会丢失。而在本例中，我们需要在物体的模型空间下对顶点位置进行偏移。因此，在这里需要取消对该 Shader 的批处理操作。</p><p>我们关闭了深度写入，开启并设置了混合模式，并关闭了剔除功能。这是为了让水流的每个面都能显示。</p><p>我们首先计算顶点位移量。我们只希望对顶点的 x 方向进行位移，因此 yzw 的位移量被设置为 0。然后，我们利用 _Frequency 属性和内置的 _Time.y 变量来控制正弦函数的频率。为了让不同位置具有不同的位移，我们对上述结果加上了模型空间下的位置分量，并乘以 _InvWaveLength 来控制波长。最后，我们对结果值乘以 _Magnitude 属性来控制波动幅度，得到最终的位移。剩下的工作，我们只需要把位移量添加到顶点位置上，在进行正常的顶点变换即可。我们还进行了纹理动画，即使用 _Time.y 和 _Speed 来控制在水平方向上的纹理动画。</p><p><img src="/posts_image/Animation_Effects/Animation_Effects_4.png" alt="使用顶点动画来模拟 2D 的河流" title="使用顶点动画来模拟 2D 的河流"></p><h3 id="广告牌">广告牌</h3><p>另一种常见的顶点动画就是<strong>广告牌技术（Billboarding）</strong>。广告牌技术会根据视角方向来旋转一个被纹理着色的多边形（通常就是简单的四边形，这个多边形就是广告牌），使得多边形看起来好像总是面对着摄像机。广告牌技术被用于很多应用，比如渲染烟雾、云朵、闪光效果等。</p><p>广告牌技术的本质就是构建旋转矩阵，而我们知道一个变换矩阵需要三个基向量。广告牌技术使用的基向量通常就是<strong>表面法线（normal）、指向上的方向（up）<strong>以及</strong>指向右的方向（right）</strong>。除此之外，我们还需要指定一个<strong>锚点（anchor location）</strong>，这个锚点在旋转过程中是固定不变的，以此来确定多边形在空间中的位置。</p><p>广告牌技术的难点在于，如何根据需求来构建 3 个互相正交的基向量。计算过程通常是，我们首先会通过初始计算得到目标的表面法线（例如就是视角方向）和指向上的方向，而两者往往是不垂直的。但是，两者其中之一是固定的，例如当模拟草丛时，我们希望广告牌的指向上的方向永远是(0, 1, 0)，而法线方向应该随视角发生变化；而当模拟粒子效果时，我们希望广告牌的法线方向是固定的，即总是指向视角方向，指向上的方向则可以发生变化。我们假设法线方向是固定的，首先，我们根据初始的表面法线和指向上的方向来计算出目标方向的指向右的方向（通过叉积操作）：<br>$$<br>right = up \times normal<br>$$<br>对其归一化后，再由法线方向和指向右的方向计算出正交的指向上的方向即可：<br>$$<br>up’ = normal \times right<br>$$<br>至此，我们就可以得到用于旋转的三个正交基了。下图给出了上述计算过程的图示。如果指向上的方向是固定的，计算过程也是类似的。</p><p><img src="/posts_image/Animation_Effects/Animation_Effects_5.png" alt="计算正交基的过程" title="计算正交基的过程"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter11/Chapter11-Billboard&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)<br>        _VerticalBillboarding (&quot;Vertical Restraints&quot;, Range(0, 1)) = 1<br>    &#125;<br>    SubShader<br>    &#123;<br>        // Need to disable batching because of the vertex animation<br>        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;<br><br>        Pass &#123;<br>            Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;<br>            ZWrite Off<br>            Blend SrcAlpha OneMinusSrcAlpha<br>            Cull Off<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br>            <br>            #include &quot;Lighting.cginc&quot;<br><br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            fixed4 _Color;<br>            fixed _VerticalBillboarding;<br><br>            struct a2v &#123;<br>float4 vertex : POSITION;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float2 uv : TEXCOORD0;<br>&#125;;<br><br>            v2f vert (a2v v) &#123;<br>v2f o;<br><br>// Suppose the center in object space is fixed<br>float3 center = float3(0, 0, 0);<br>float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, 1));<br>float3 normalDir = viewer - center;<br>// If _VerticalBillboarding equals 1, we use the desired view dir as the normal dir<br>// Which means the normal dir is fixed<br>// Or if _VerticalBillboarding equals 0, the y of normal is 0<br>// Which means the up dir is fixed<br>normalDir.y =normalDir.y * _VerticalBillboarding;<br>normalDir = normalize(normalDir);<br>// Get the approximate up dir<br>// If normal dir is already towards up, then the up dir is towards front<br>float3 upDir = abs(normalDir.y) &gt; 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);<br>float3 rightDir = normalize(cross(upDir, normalDir));<br>upDir = normalize(cross(normalDir, rightDir));<br><br>// Use the three vectors to rotate the quad<br>float3 centerOffs = v.vertex.xyz - center;<br>float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;<br>              <br>o.pos = UnityObjectToClipPos(float4(localPos, 1));<br>o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br><br>return o;<br>&#125;<br><br>fixed4 frag (v2f i) : SV_Target &#123;<br>fixed4 c = tex2D (_MainTex, i.uv);<br>c.rgb *= _Color.rgb;<br><br>return c;<br>&#125;<br><br>ENDCG<br>        &#125;<br><br>    &#125;<br>    FallBack &quot;Transparent/VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中，_MainTex 是广告牌显示的透明纹理，_Color 用于控制显示整体颜色，_VerticalBillboarding 则用于调整是固定法线还是固定指向上的方向，即约束垂直方向的程度。在广告牌技术中，我们需要使用物体的模型空间下的位置来作为锚点进行计算，为了让模型各自的模型空间不丢失，我们需要取消对该 Shader 的批处理操作。我们关闭了深度写入，开启并设置了混合模式，并关闭了剔除功能，这是为了让广告牌的每个面都能显示。</p><p>顶点着色器是我们的核心，所有的计算都是再模型空间下进行的。我们首先选择模型空间的原点作为广告牌的锚点，并利用内置变量获取模型空间下的视角位置，然后开始计算 3 个正交矢量。首先，我们根据观察位置和锚点计算目标法线方向，并根据 _VerticalBillboarding 属性来控制垂直方向上的约束度。当 _VerticalBillboarding 为 1 时，意味着法线方向固定为视角方向；当 _VerticalBillboarding 为 0 时，意味着向上方向固定为(0, 1, 0)。最后，我们需要对计算得到的法线方向进行归一化操作来得到单位矢量。接着，我们得到了粗略的向上方向。为了防止法线方向和向上方向平行（如果平行，那么叉积得到的结果将是错误的），我们对法线方向的 y 分量进行判断，以得到合适的向上方向。然后，根据法线方向和粗略的向上方向得到向右方向，并对结果进行归一化。但由于此时向上的方向还是不准确的，我们又根据准确的法线方向和向右方向得到最后的向上方向。这样，我们得到了所需的 3 个正交基向量。我们根据原始的位置相对于锚点的偏移量以及 3 个正交基矢量，以计算得到新的顶点位置，最后，把模型空间的顶点位置变换到裁剪空间中。</p><p>需要说明的是，在上面的例子中，我们使用的是 Unity 自带的四边形（Quad）来作为广告牌，而不能使用自带的平面（Plane）。这是因为，我们的代码是建立在一个竖直摆放的多边形的基础上的，也就是说，这个多边形的顶点结构需要满足在模型空间下是竖直排列的。只有这样，我们才能使用 v.vertex 来计算得到正确的相对于中心的位置偏移量。</p><p><img src="/posts_image/Animation_Effects/Animation_Effects_6.png" alt="广告牌效果" title="广告牌效果"></p><h3 id="注意事项">注意事项</h3><p>顶点动画虽然非常灵活有效，但有一些注意事项需要在此提醒一下。</p><p>首先，如果我们在模型空间下进行了一些顶点动画，那么批处理往往就会破坏这种动画效果。这时，我们可以通过 SubShader 中的 DisableBatching 标签来强制取消对该 Unity Shader 的批处理。然而，取消批处理会带来一定的性能下降，增加了 Draw Call，因此我们应该尽量避免使用模型空间的中心来作为锚点，我们可以利用顶点颜色来存储每个顶点到锚点的距离值，这种做法在商业游戏中很常见。</p><p>其次，如果我们想要对包含了顶点动画的物体添加阴影，那么如果仍然使用内置的 Diffuse 等包含的阴影的 Pass 来渲染，就得不到正确的阴影效果（这里指的是无法向其他物体正确地投射阴影）。这是因为，Unity 的阴影绘制需要调用一个 ShadowCasterPass，而如果直接使用这些内置的 ShadowCasterPass，这个 Pass 中并没有进行相关的顶点动画，因此 Unity 会仍然按照原来的顶点位置来计算阴影，这并不是我们希望看到的。这时，我们就需要提供一个自定义的 ShadowCasterPass，在这个 Pass 中，我们将进行同样的顶点变换过程。需要注意的是，在前面的实现中，如果涉及半透明物体我们都把 Fallback 设置成了 Transparent/VertexLit，而 Transparent/VertexLit 没有定义 ShadowCasterPass，因此也就不会产生阴影。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter11/Chapter11-VertexAnimationWithShadow&quot;<br>&#123;<br>    Properties &#123;<br>_MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>_Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)<br>_Magnitude (&quot;Distortion Magnitude&quot;, Float) = 1<br> _Frequency (&quot;Distortion Frequency&quot;, Float) = 1<br> _InvWaveLength (&quot;Distortion Inverse Wave Length&quot;, Float) = 10<br> _Speed (&quot;Speed&quot;, Float) = 0.5<br>&#125;<br>SubShader &#123;<br>// Need to disable batching because of the vertex animation<br>Tags &#123;&quot;DisableBatching&quot;=&quot;True&quot;&#125;<br><br>Pass &#123;<br>Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>Cull Off<br><br>CGPROGRAM  <br>#pragma vertex vert <br>#pragma fragment frag<br><br>#include &quot;UnityCG.cginc&quot; <br><br>sampler2D _MainTex;<br>float4 _MainTex_ST;<br>fixed4 _Color;<br>float _Magnitude;<br>float _Frequency;<br>float _InvWaveLength;<br>float _Speed;<br><br>struct a2v &#123;<br>    float4 vertex : POSITION;<br>    float4 texcoord : TEXCOORD0;<br>&#125;;<br><br>struct v2f &#123;<br>    float4 pos : SV_POSITION;<br>    float2 uv : TEXCOORD0;<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br>v2f o;<br><br>float4 offset;<br>offset.yzw = float3(0.0, 0.0, 0.0);<br>offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;<br>o.pos = UnityObjectToClipPos(v.vertex + offset);<br><br>o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>o.uv +=  float2(0.0, _Time.y * _Speed);<br><br>return o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>fixed4 c = tex2D(_MainTex, i.uv);<br>c.rgb *= _Color.rgb;<br><br>return c;<br>&#125; <br><br>ENDCG<br>&#125;<br><br>// Pass to render object as a shadow caster<br>Pass &#123;<br>Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;<br><br>CGPROGRAM<br><br>#pragma vertex vert<br>#pragma fragment frag<br><br>#pragma multi_compile_shadowcaster<br><br>#include &quot;UnityCG.cginc&quot;<br><br>float _Magnitude;<br>float _Frequency;<br>float _InvWaveLength;<br>float _Speed;<br><br>struct v2f &#123; <br>    V2F_SHADOW_CASTER;<br>&#125;;<br><br>v2f vert(appdata_base v) &#123;<br>v2f o;<br><br>float4 offset;<br>offset.yzw = float3(0.0, 0.0, 0.0);<br>offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;<br>v.vertex = v.vertex + offset;<br><br>TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)<br><br>return o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>    SHADOW_CASTER_FRAGMENT(i)<br>&#125;<br>ENDCG<br>&#125;<br>&#125;<br>FallBack &quot;VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/posts_image/Animation_Effects/Animation_Effects_7.png" alt="为变形物体绘制正确的阴影" title="为变形物体绘制正确的阴影"></p><p>阴影投射的重点在于我们需要按正常 Pass 的处理来剔除片元或进行顶点动画，以便阴影可以和物体正常渲染的结果相匹配。在自定义的阴影投射的 Pass 中，我们通常会使用 Unity 提供的内置宏 V2F_SHADOW_CASTER、TRANSFER_SHADOW_CASTER_NORMALOFFSET（旧版本中会使用 TRANSFER_SHADOW_CASTER）和 SHADOW_CASTER_FRAGMENT 来计算阴影投射时需要的各种变量，而我们可以只关注自定义计算的部分。在上面的代码中，我们首先在 v2f 结构体中利用 V2F_SHADOW_CASTER 来定义阴影投射所需要定义的变量。随后，在顶点着色器中，我们首先按之前对顶点的处理方法计算顶点的偏移量，不同的是，我们直接把偏移值加到顶点位置变量中，再使用 TRANSFER_SHADOW_CASTER_NORMALOFFSET 来让 Unity 为我们完成剩下的事情。再片元着色器中，我们直接使用 SHADOW_CASTER_FRAGMENT 来让 Unity 自动完成阴影投射的部分，把结果输出到深度图和阴影映射纹理中。</p><p>通过 Unity 提供的这 3 个内置宏（在 UnityCG.cginc 文件中被定义），我们可以方便地自定义需要的阴影投射的 Pass，但由于这些宏里需要使用一些特定的输入变量，因此我们需要保证为它们提供了这些变量。例如，TRANSFER_SHADOW_CASTER_NORMALOFFSET 会使用名称 v 作为输入结构体，v 中需要包含顶点位置 v.vertex 和顶点法线 v.normal 的信息，我们可以直接使用内置的 appdata_base 结构体，它包含了这些必需的顶点变量。如果我们需要进行顶点动画，可以在顶点着色器中直接修改 v.vertex，再传递给 TRANSFER_SHADOW_CASTER_NORMALOFFSET 即可。</p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级纹理(二)</title>
    <link href="/posts/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86(%E4%BA%8C)/"/>
    <url>/posts/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h2 id="渲染纹理">渲染纹理</h2><p>在之前的学习中，一个摄像机的渲染结果会输出到颜色缓冲中，并显示到我们的屏幕上。现代的 GPU 允许我们把整个三维场景渲染到一个中间缓冲中，即<strong>渲染目标纹理（Render Target Texture，RTT）</strong>，而不是传统的帧缓冲或后备缓冲（back buffer）。与之相关的是<strong>多重渲染目标（Multiple Render Target，MRT）</strong>，这种技术指的是 GPU 允许我们把场景同时渲染到多个渲染目标纹理中，而不再需要为每个渲染目标纹理单独渲染完整的场景。延迟渲染就是使用多重渲染目标的一个应用。</p><p>Unity 为渲染目标纹理定义了一种专门的纹理类型——<strong>渲染纹理（Render Texture）</strong>。在 Unity 中使用渲染纹理通常有两种方式：一种方式是在 Project 目录下创建一个渲染纹理，然后把某个摄像机的渲染目标设置成该渲染纹理，这样一来该摄像机的渲染结果就会实时更新到渲染纹理中，而不会显示在屏幕上。使用这种方法，我么还可以选择渲染纹理的分辨率、滤波模式等纹理属性。另一种方式是在屏幕后处理时使用 GrabPass 命令或 OnRenderImage 函数来获取当前屏幕图像，Unity 会把这个屏幕图像放到一张和屏幕分辨率等同的渲染纹理中，下面我们可以在自定义的 Pass 中把它们当成普通纹理来处理，从而实现各种屏幕特效。</p><h3 id="镜子效果">镜子效果</h3><p>在 Project 视图下创建一个渲染纹理（右键单击 Create -&gt; Render Texture），名为 MirrorTexture，它使用的纹理设置如下图：</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_11.png" alt="渲染纹理使用的纹理设置" title="渲染纹理使用的纹理设置"></p><p>为了得到从镜子出发观察到的场景图像，我们还需要创建一个摄像机，并调整它的位置、裁剪平面、视角等，使得它的显示图像是我们希望的镜子图像。由于这个摄像机不需要直接显示在屏幕上，而是用于渲染纹理，我们把创建的 MirrorTexture 拖拽到该摄像机的 Target Texture 上。下图显示了摄像机面板的设置。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_12.png" alt="摄像机 Target Texture 设置" title="摄像机 Target Texture 设置"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter10/Chapter10-Mirror&quot;<br>&#123;<br>    Properties &#123;<br>_MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>&#125;<br>SubShader &#123;<br>Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;<br><br>Pass &#123;<br>CGPROGRAM<br><br>#pragma vertex vert<br>#pragma fragment frag<br><br>sampler2D _MainTex;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float3 texcoord : TEXCOORD0;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float2 uv : TEXCOORD0;<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.uv = v.texcoord;<br>// Mirror needs to filp x<br>o.uv.x = 1 - o.uv.x;<br><br>return o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>return tex2D(_MainTex, i.uv);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125; <br> FallBack Off<br>&#125;<br><br></code></pre></td></tr></table></figure><p>镜子实现的原理很简单，它使用一个渲染纹理作为输入属性，并把该渲染纹理在水平方向上翻转后直接显示到物体上即可。在上面的代码中，我们翻转了 x 分量的纹理坐标。这是因为镜子里显示的图像都是左右相反的。</p><p>在上面的实现中，我们把渲染纹理的分辨率大小设置为 256 $\times$ 256。有时，这样的分辨率会使图像模糊不清，此时我们可以使用更高的分辨率或更多的抗锯齿采样等。但需要注意的是，更高的分辨率会影响带宽和性能，我们应当尽量使用较小的分辨率。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_13.png" alt="镜子效果" title="镜子效果"></p><h3 id="玻璃效果">玻璃效果</h3><p>在 Unity 中，我们还可以在 Unity Shader 中使用一种特殊的 Pass 来完成获取屏幕图像的目的，这就是 GrabPass。当我们在 Shader 中定义了一个 GrabPass 后，Unity 会把当前屏幕的图像绘制在一张纹理中，以便我们在后续的 Pass 中访问它。我们通常会使用 GrabPass 来实现诸如玻璃等透明材质的模拟，与使用简单的透明混合不同，使用 GrabPass 可以让我们对该物体后面的图像进行更复杂的处理，例如使用法线来模拟折射效果，而不再是简单的和原屏幕颜色进行混合。</p><p>需要注意的是，在使用 GrabPass 时，我们需要额外<strong>小心物体的渲染队列设置</strong>。GrabPass 通常用于渲染透明物体，尽管代码里并不包含混合指令，但我们往往仍然需要把物体的渲染队列设置成透明队列（即&quot;Queue&quot;=“Transparent”）。这样才能保证当渲染物体时，所有的不透明物体都已经被绘制在屏幕上，从而获取正确的屏幕图像。</p><p>我们首先使用一张法线纹理来修改模型的法线信息，然后使用反射方法，通过一个 Cubemap 来模拟玻璃的反射，而在模拟折射时，则使用 GrabPass 获取玻璃后面的屏幕图像，并使用切线空间下的法线对屏幕纹理坐标偏移后，再对屏幕图像进行采样来模拟近似的折射效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br><br>Shader &quot;Custom/Chapter10/Chapter10-GlassRefraction&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;<br>        _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<br>        _Distortion (&quot;Distortion&quot;, Range(0, 100)) = 10<br>        _RefractAmount (&quot;Refract Amount&quot;, Range(0.0, 1.0)) = 1.0<br>    &#125;<br>    SubShader<br>    &#123;<br>        //We must be transparent, so other objects are drawn before this one.<br>        Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;<br><br>        //This pass grabs the screen behind the object into a texture.<br>        //We can access the result in the next pass as _RefractionTex<br>        GrabPass &#123; &quot;_RefractionTex&quot; &#125; <br><br>        Pass &#123;<br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;UnityCG.cginc&quot;<br><br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            sampler2D _BumpMap;<br>            float4 _BumpMap_ST;<br>            samplerCUBE _Cubemap;<br>            float _Distortion;<br>            fixed _RefractAmount;<br>            sampler2D _RefractionTex;<br>            float4 _RefractionTex_TexelSize;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 tangent : TANGENT;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br>            <br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float4 scrPos : TEXCOORD0;<br>                float4 uv : TEXCOORD1;<br>                float4 TtoW0 : TEXCOORD2;  <br>                float4 TtoW1 : TEXCOORD3;  <br>                float4 TtoW2 : TEXCOORD4;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.scrPos = ComputeGrabScreenPos(o.pos);<br>                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                o.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap);<br><br>                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);<br>                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);<br>                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;<br><br>                o.TtoW0 =  float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);<br>                o.TtoW1 =  float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);<br>                o.TtoW2 =  float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);<br><br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET<br>            &#123;<br>                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);<br>                fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));<br><br>                //Get the normal in tangent space<br>                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));<br><br>                //Compute the offset in tangent space<br>                float2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;<br>                i.scrPos.xy = offset + i.scrPos.xy;<br>                fixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;<br><br>                //Convert the normal to world space<br>                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));<br>                fixed3 reflDir = reflect(-worldViewDir, bump);<br>                fixed4 texColor = tex2D(_MainTex, i.uv.xy);<br>                fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb;<br>                fixed3 finalColor = reflCol * (1 - _RefractAmount) + refrCol * _RefractAmount;<br><br>                return fixed4(finalColor, 1);<br><br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Diffuse&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>_MainTex 是该玻璃的材质纹理；_BumpMap 是玻璃的法线纹理；_Cubemap 是用于模拟反射的环境纹理；_Distortion 是用于控制模拟折射时图像的扭曲程度；_RefractAmount 用于控制折射程度，当 _RefractAmount 值为 0 时，该玻璃只包含反射效果，当 _RefractAmount 值为 1 时，该玻璃只包括折射效果。</p><p>我们首先在 SubShader 的标签中将渲染队列设置成 Transparent，尽管在后面的 RenderType 被设置为了 Opaque。这两者看似矛盾，但实际服务于不同的需求。把 Queue 设置成 Transparent 可以确保该物体渲染时，其他所有不透明物体都已经渲染到屏幕上了，否则就可能无法正确得到“透过玻璃看到的图像”。而设置 RenderType 则是为了在使用着色器替换（Shader Replacement）时，该物体可以在需要时被正确渲染。这通常发生在我们需要得到摄像机的深度和法线纹理时。</p><p>随后我们通过关键词 GrabPass 定义了一个抓取屏幕图像的 Pass。在这个 Pass 中我们定义了一个字符串，该字符串内部的名称决定了抓取得到的屏幕图像将会被存入哪个纹理中。实际上，我们可以省略声明该字符串，但直接声明纹理名称的方法往往可以得到更高的性能。下面是两种情况的比较。</p><ul><li>直接使用 GrabPass {}，然后在后续的 Pass 中直接使用 _GrabTexture 来访问屏幕图像。但是，当场景中有多个物体都使用了这样的形式来抓取屏幕时，这种方法的性能消耗比较大，因为对于每一个使用它的物体，Unity 都会为它单独进行一次昂贵的屏幕抓取操作。但这种方法可以让每个物体得到不同的屏幕图像，这取决于它们的渲染队列及渲染它们时当前的屏幕缓冲中的颜色。</li><li>使用 GrabPass {“TextureName”}，我们可以在后续的 Pass 中使用 TextureName 来访问屏幕图像。使用这种方法同样可以抓取屏幕，但 Unity 只会在每一帧时为第一个使用名为 TextureName 的纹理的物体执行一次抓取屏幕的操作，而这个纹理同样可以在其他 Pass 中被访问。这种方法更高效，因为不管场景中有多少物体使用了该命令，每一帧中 Unity 都只会执行一次抓取工作，但这也意味着所有物体都会使用同一张屏幕图像。不过，这在大多数情况下已经足够了。</li></ul><p>我们还定义了 _RefractionTex 和 _RefractionTex_TexelSize 变量，这对应了在使用 GrabPass 时指定的纹理名称。_RefractionTex_TexelSize 可以让我们得到该纹理的纹素大小，例如一个大小为 256 $\times$ 512 的纹理，它的纹素大小为(1/256, 1/512)。我们需要在对屏幕图像的采样坐标进行偏移时使用该变量。</p><p>在进行了必要的顶点坐标变换后，我们通过调用内置的 ComputeGrabScreenPos 函数来得到对应被抓取的屏幕图像的采样坐标。我们可以在 UnityCG.cginc 文件中找到它的声明，它的主要代码和 ComputeScreenPos 基本类似，最大的不同是针对平台差异造成的采样坐标问题进行了处理。接着，我们计算了 _MainTex 和 _BumpMap 的采样坐标，并把它们分别存储在一个 float4 类型变量的 xy 和 zw 分量中。由于我们需要在片元着色器中把法线方向从切线方向（由法线纹理采样得到）变换到世界空间下，以便对 Cubemap 进行采样，因此，我们需要在这里计算该顶点对应的从切线空间到世界空间的变换矩阵，并把该矩阵的每一行分别存储在 TtoW0、TtoW1、和 TtoW2 的 xyz 分量中。这里面使用的数学方法就是，得到切线空间下的 3 个坐标轴（xyz 轴分别对应了副切线、切线和法线的方向）在世界空间下的表示，再把它们依次按<strong>列</strong>组成一个变换矩阵即可。TtoW0 等值的 w 轴同样被利用起来，用于存储世界空间下的顶点坐标。</p><p>我们通过 TtoW0 等变量的 w 分量得到世界坐标，并用该值得到该片元对应的视角方向。随后，我们对法线纹理进行采样，得到切线空间下的法线方向。我们使用该值和 _Distortion 属性以及 _RefractionTex_TexelSize 来对屏幕图像的采样坐标进行偏移，模拟折射效果。_Distortion 值越大，偏移量越大，玻璃背后的物体看起来变形程度越大。在这里，我们选择使用切线空间下单法线方向来进行偏移，是因为该空间下的法线可以反应顶点局部空间下的法线方向。随后，我们对 scrPos 透视除法得到真正的屏幕坐标，再使用该坐标对抓取的屏幕图像 _RefractionTex 进行采样，得到模拟的折射颜色。</p><p>之后，我们把法线方向从切线空间变换到了世界空间下（使用变换矩阵的每一行，即 TtoW0、TtoW1 和 TtoW2，分别和法线方向点乘，构成新的法线方向），并据此得到视角方向相对于法线方向的反射方向。随后，使用反射方向对 Cubemap 进行采样，并把结果和主纹理颜色相乘后得到反射颜色。最后我们使用 _RefractAmount 属性对反射和折射颜色进行混合，作为最终的输出颜色。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_14.png" alt="玻璃效果" title="玻璃效果"></p><h3 id="渲染纹理-vs-GrabPass">渲染纹理 vs. GrabPass</h3><p>尽管 GrabPass 和 渲染纹理 + 额外摄像机的方式都可以抓取屏幕图像，但它们之间还是有一些不同的。GrabPass 的好处在于实现简单，我们只需要在 Shader 中写几行代码就可以实现抓取屏幕的目的。而要使用渲染纹理的话，我们首先需要创建一个渲染纹理和一个额外的摄像机，再把该摄像机的 Render Target 设置为新建的渲染纹理对象，最后把该渲染纹理传递给相应的 Shader。</p><p>但从效率上来讲，使用渲染纹理的效率往往要好于 GrabPass，尤其在移动设备上。使用渲染纹理我们可以自定义渲染纹理的大小，尽管这种方法需要把部分场景再次渲染一遍，但我们可以通过调整摄像机的渲染层来减少二次渲染时的场景大小，或使用其他方法来控制摄像机是否需要开启。而使用 GrabPass 获取到的图像分辨率和显示屏幕是一致的，这意味着在一些高分辨率的设备上可能会造成严重的带宽影响。而且在移动设备上，GrabPass 虽然不会重新渲染场景，但它往往需要 CPU 直接读取后备缓冲（back buffer）中的数据，破坏了 CPU 和 GPU 之间的并行性，这是比较耗时的，甚至在一些移动设备上这是不支持的。</p><p>Unity 引入了<strong>命令缓冲（Command Buffers）<strong>来允许我们扩展 Unity 的渲染流水线。使用命令缓冲我们也可以得到类似抓屏的效果，它可以在不透明物体渲染后把当前的图像复制到一个临时的渲染目标纹理中，然后在那里进行一些额外的操作，例如模糊等等，最后把图像传递给需要使用它的物体进行处理和显示。除此之外，命令缓冲还允许我们实习很多特殊的效果，我们可以在 Unity 官方手册中的</strong>图像命令缓冲</strong>一文（<a href="https://docs.unity.cn/cn/2021.2/Manual/GraphicsCommandBuffers.html%EF%BC%89%E4%B8%AD%E6%89%BE%E5%88%B0%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9%E3%80%82">https://docs.unity.cn/cn/2021.2/Manual/GraphicsCommandBuffers.html）中找到更多内容。</a></p><h2 id="程序纹理">程序纹理</h2><p>**程序纹理（Procedural Texture）**指的是那些由计算机生成的图像，我们通常使用一些特定的算法来创建个性化图案或非常真实的自然元素，例如木头、石子等。使用程序纹理的好处在于我们可以使用各种参数来控制纹理的外观，而这些属性不仅仅是那些颜色属性，甚至可以是完全不同类型的图案属性，这使得我们可以得到更加丰富的动画和视觉效果。</p><h3 id="在-Unity-中实现简单的程序纹理">在 Unity 中实现简单的程序纹理</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br>[<span class="hljs-meta">ExecuteInEditMode</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProceduralTextureGeneration</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br><span class="hljs-keyword">public</span> Material material = <span class="hljs-literal">null</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">region</span> Material properties</span><br>[<span class="hljs-meta">SerializeField, SetProperty(<span class="hljs-string">&quot;textureWidth&quot;</span>)</span>]<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_textureWidth = <span class="hljs-number">512</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> textureWidth &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">return</span> m_textureWidth;<br>&#125;<br><span class="hljs-keyword">set</span> &#123;<br>m_textureWidth = <span class="hljs-keyword">value</span>;<br>_UpdateMaterial();<br>&#125;<br>&#125;<br><br>[<span class="hljs-meta">SerializeField, SetProperty(<span class="hljs-string">&quot;backgroundColor&quot;</span>)</span>]<br><span class="hljs-keyword">private</span> Color m_backgroundColor = Color.white;<br><span class="hljs-keyword">public</span> Color backgroundColor &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">return</span> m_backgroundColor;<br>&#125;<br><span class="hljs-keyword">set</span> &#123;<br>m_backgroundColor = <span class="hljs-keyword">value</span>;<br>_UpdateMaterial();<br>&#125;<br>&#125;<br><br>[<span class="hljs-meta">SerializeField, SetProperty(<span class="hljs-string">&quot;circleColor&quot;</span>)</span>]<br><span class="hljs-keyword">private</span> Color m_circleColor = Color.yellow;<br><span class="hljs-keyword">public</span> Color circleColor &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">return</span> m_circleColor;<br>&#125;<br><span class="hljs-keyword">set</span> &#123;<br>m_circleColor = <span class="hljs-keyword">value</span>;<br>_UpdateMaterial();<br>&#125;<br>&#125;<br><br>[<span class="hljs-meta">SerializeField, SetProperty(<span class="hljs-string">&quot;blurFactor&quot;</span>)</span>]<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_blurFactor = <span class="hljs-number">2.0f</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> blurFactor &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">return</span> m_blurFactor;<br>&#125;<br><span class="hljs-keyword">set</span> &#123;<br>m_blurFactor = <span class="hljs-keyword">value</span>;<br>_UpdateMaterial();<br>&#125;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br><span class="hljs-keyword">private</span> Texture2D m_generatedTexture = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// Use this for initialization</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> ()</span> &#123;<br><span class="hljs-keyword">if</span> (material == <span class="hljs-literal">null</span>) &#123;<br>Renderer renderer = gameObject.GetComponent&lt;Renderer&gt;();<br><span class="hljs-keyword">if</span> (renderer == <span class="hljs-literal">null</span>) &#123;<br>Debug.LogWarning(<span class="hljs-string">&quot;Cannot find a renderer.&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>material = renderer.sharedMaterial;<br>&#125;<br><br>_UpdateMaterial();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> _UpdateMaterial() &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>m_generatedTexture = _GenerateProceduralTexture();<br>material.SetTexture(<span class="hljs-string">&quot;_MainTex&quot;</span>, m_generatedTexture);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Color _MixColor(Color color0, Color color1, <span class="hljs-built_in">float</span> mixFactor) &#123;<br>Color mixColor = Color.white;<br>mixColor.r = Mathf.Lerp(color0.r, color1.r, mixFactor);<br>mixColor.g = Mathf.Lerp(color0.g, color1.g, mixFactor);<br>mixColor.b = Mathf.Lerp(color0.b, color1.b, mixFactor);<br>mixColor.a = Mathf.Lerp(color0.a, color1.a, mixFactor);<br><span class="hljs-keyword">return</span> mixColor;<br>&#125;<br><br><span class="hljs-keyword">private</span> Texture2D _GenerateProceduralTexture() &#123;<br>Texture2D proceduralTexture = <span class="hljs-keyword">new</span> Texture2D(textureWidth, textureWidth);<br><br><span class="hljs-comment">// The interval between circles</span><br><span class="hljs-built_in">float</span> circleInterval = textureWidth / <span class="hljs-number">4.0f</span>;<br><span class="hljs-comment">// The radius of circles</span><br><span class="hljs-built_in">float</span> radius = textureWidth / <span class="hljs-number">10.0f</span>;<br><span class="hljs-comment">// The blur factor</span><br><span class="hljs-built_in">float</span> edgeBlur = <span class="hljs-number">1.0f</span> / blurFactor;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> w = <span class="hljs-number">0</span>; w &lt; textureWidth; w++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> h = <span class="hljs-number">0</span>; h &lt; textureWidth; h++) &#123;<br><span class="hljs-comment">// Initalize the pixel with background color</span><br>Color pixel = backgroundColor;<br><br><span class="hljs-comment">// Draw nine circles one by one</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br><span class="hljs-comment">// Compute the center of current circle</span><br>Vector2 circleCenter = <span class="hljs-keyword">new</span> Vector2(circleInterval * (i + <span class="hljs-number">1</span>), circleInterval * (j + <span class="hljs-number">1</span>));<br><br><span class="hljs-comment">// Compute the distance between the pixel and the center</span><br><span class="hljs-built_in">float</span> dist = Vector2.Distance(<span class="hljs-keyword">new</span> Vector2(w, h), circleCenter) - radius;<br><br><span class="hljs-comment">// Blur the edge of the circle</span><br>Color color = _MixColor(circleColor, <span class="hljs-keyword">new</span> Color(pixel.r, pixel.g, pixel.b, <span class="hljs-number">0.0f</span>), Mathf.SmoothStep(<span class="hljs-number">0f</span>, <span class="hljs-number">1.0f</span>, dist * edgeBlur));<br><br><span class="hljs-comment">// Mix the current color with the previous color</span><br>pixel = _MixColor(pixel, color, color.a);<br>&#125;<br>&#125;<br><br>proceduralTexture.SetPixel(w, h, pixel);<br>&#125;<br>&#125;<br><br>proceduralTexture.Apply();<br><br><span class="hljs-keyword">return</span> proceduralTexture;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>由于我们生成的纹理是由若干圆点构成的，因此在上面的代码中，我们声明了 4 个纹理属性：纹理的大小，数值通常是 2 的整数幂；纹理的背景颜色；原点的颜色；模糊因子，这个参数是用来模糊边界的。对于每个属性使用了 get/set 方法，为了在面板上修改属性时仍可执行 set 函数，我们使用了一个开源插件 SetProperty（<a href="https://github.com/LMNRY/SetProperty/blob/master/Scripts/SetPropertyExample.cs%EF%BC%89%E3%80%82%E8%BF%99%E4%BD%BF%E5%BE%97%E6%88%91%E4%BB%AC%E4%BF%AE%E6%94%B9%E4%BA%86%E6%9D%90%E8%B4%A8%E5%B1%9E%E6%80%A7%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%89%A7%E8%A1%8C">https://github.com/LMNRY/SetProperty/blob/master/Scripts/SetPropertyExample.cs）。这使得我们修改了材质属性时，可以执行</a> _UpdateMaterial 函数来使用新的属性重新生成程序纹理。</p><p>代码首先初始化一张二维纹理，并且提前计算了一些生成纹理时需要的变量。然后，使用了一个两层的嵌套循环遍历纹理中的每个像素，并在纹理上依次绘制 9 个圆形。最后调用 Texture2D.Apply 函数来强制把像素值写入纹理中，并返回该程序纹理。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_15.png" alt="程序纹理" title="程序纹理"></p><h3 id="Unity-的程序材质">Unity 的程序材质</h3><p>在 Unity 中，有一类专门使用程序纹理的材质，叫做<strong>程序材质（Procedural Materials）</strong>。这类材质和我们之前使用的那些材质本质上是一样的，不同的是，它们使用的纹理不是普通的纹理，而是程序纹理。需要注意的是，程序材质和它使用的程序纹理并不是在 Unity 中创建的，而是使用了一个名为 <strong>Substance Designer</strong> 的软件在 Unity 外部生成的。<strong>Substance Designer</strong> 是一个非常出色的纹理生成工具，很多 3A 的游戏项目都使用了由它生成的材质。这些材质都是以 .sbsar 为后缀的。在 Unity 中需要从官方资源商店或 Package Manager 安装 Substance in Unity 插件，把以 .sbsar 为后缀的文件导入到 Unity 后，Unity 就会生成一个 <strong>程序纹理资源（Procedural Material Asset）</strong>。程序纹理资源可以包含一个或多个程序材质。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_16.png" alt="程序纹理资源" title="程序纹理资源"></p><p>我们可以在程序纹理的面板上看到该材质使用的 Unity Shader 及其属性、生成程序纹理使用的纹理属性、材质预览等信息。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_17.png" alt="程序纹理资源效果" title="程序纹理资源效果"></p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Texture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级纹理(一)</title>
    <link href="/posts/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86(%E4%B8%80)/"/>
    <url>/posts/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h2 id="立方体纹理">立方体纹理</h2><p>在图形学中，**立方体纹理（Cubemap）<strong>是</strong>环境映射（Environment Mapping）**的一种实现方法。环境映射可以模拟物体周围的环境，而使用了环境映射的物体可以看起来像镀了层金属一样反射出周围的环境。</p><p>立方体纹理一共包含了 6 张图像，这些图像对应了一个立方体的 6 个面，立方体纹理的名称也由此而来。立方体的每个面表示沿着世界空间下的轴向（上、下、左、右、前、后）观察所得的图像。对立方体纹理采样需要提供一个三维的纹理坐标，这个三维纹理坐标表示了在世界空间下的 3D 方向。这个方向矢量从立方体的中心出发，当它向外部延伸时就会和立方体的 6 个纹理之一发生相交，而采样得到的结果就是由该交点计算而来的。下图给出了使用方向矢量对立方体纹理采样的过程。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_1.png" alt="对立方体纹理的采样" title="对立方体纹理的采样"></p><p>立方体纹理的好处在于实现简单快速，得到的效果也比较好，但是它也有一些缺点，例如当场景中引入了新的物体、光源，或者物体发生移动时，我们就需要重新生成立方体纹理。除此之外，立方体纹理也仅可以反射环境，但不能反射使用了该立方体纹理的物体本身。这是因为立方体纹理不能模拟多次反射的结果，例如两个金属球互相反射的情况（Unity 引入的全局光照系统允许实现这样的自反射效果）。由于这样的原因，想要得到令人信服的渲染结果，应该尽量对凸面体而不要对凹面体使用立方体纹理（因为凹面体会反射自身）。</p><p>立方体纹理在实时渲染中有很多应用，最常见的是用于天空盒子（Skybox）以及环境映射。</p><h3 id="天空盒子">天空盒子</h3><p>**天空盒子（Skybox）**是游戏中用于模拟背景的一种方法。当我们在场景中使用了天空盒子时，整个场景就被包围在一个立方体内。这个立方体的每个面使用的技术就是立方体纹理映射技术。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_2.png" alt="天空盒子材质" title="天空盒子材质"></p><p>为了让天空盒子正常渲染，我们还需要把这 6 张纹理的 <strong>Wrap Mode</strong> 设置为 <strong>Clamp</strong>，以防在接缝处出现不匹配的现象。上面的材质中，除了 6 张纹理属性外还有 3 个属性：<strong>Tint Color</strong>，用于控制该材质的整体颜色；<strong>Exposure</strong>，用于调整天空盒子的亮度；<strong>Rotation</strong>，用于调整天空盒子沿 +y 轴方向的旋转角度。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_3.png" alt="为场景使用自定义的天空盒子" title="为场景使用自定义的天空盒子"></p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_4.png" alt="使用了天空盒子的场景" title="使用了天空盒子的场景"></p><p>在 Unity 中，天空盒子是在所有不透明物体之后渲染的，而其背后使用的网格是一个立方体或一个细分后的球体。</p><h3 id="创建用于环境映射的立方体纹理">创建用于环境映射的立方体纹理</h3><p>除了天空盒子，立方体纹理最常见的用处是用于环境映射。通过这种方法，我们可以模拟出金属质感的材质。</p><p>在 Unity 中，创建用于环境映射的立方体纹理的方法有三种：第一种方法是直接由一些特殊布局的纹理创建；第二种方法是手动创建一个 Cubemap 资源，再把 6 张图赋给它；第三种方法是由脚本生成。</p><p>如果使用第一种方法，我们需要提供一张具有特殊布局的纹理，例如类似立方体展开图的交叉布局、全景布局等。然后，我们只需要把该纹理的 <strong>Texture Type</strong> 设置为 <strong>Cubemap</strong> 即可，Unity 会为我们做好剩下的事情。在基于物理的渲染中，我们通常会使用一张 HDR 图像来生成高质量的 Cubemap。</p><p>第二种方法是 Unity 5 之前的版本中使用的方法。我们首先需要在项目资源中创建一个 Cubemap，然后把 6 张纹理拖拽到它的面板中。官方推荐使用第一种方法创建立方体纹理，这是因为第一种方法可以对纹理数据进行压缩，而且可以支持边缘修正、光滑反射（glossy reflection）和 HDR 等功能。</p><p>前面两种方法都需要我们提前准备好立方体纹理的图像，它们得到的立方体纹理往往是被场景中的物体所共用的。但在理想情况下，我们希望根据物体在场景中位置的不同，生成它们各自不同的立方体纹理。这时，我们就可以在 Unity 中使用脚本来创建。这是通过利用 Unity 提供的 <strong>Camera.RenderToCubemap</strong> 函数来实现的。Camera.RenderToCubemap 函数可以把从任意位置观察到的场景图像存储到 6 张图中，从而创建出该位置上对应的立方体纹理。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEditor;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RenderCubemapWizard</span> : <span class="hljs-title">ScriptableWizard</span> &#123;<br><br><span class="hljs-keyword">public</span> Transform renderFromPosition;<br><span class="hljs-keyword">public</span> Cubemap cubemap;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnWizardUpdate</span> ()</span> &#123;<br>helpString = <span class="hljs-string">&quot;Select transform to render from and cubemap to render into&quot;</span>;<br>isValid = (renderFromPosition != <span class="hljs-literal">null</span>) &amp;&amp; (cubemap != <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnWizardCreate</span> ()</span> &#123;<br><span class="hljs-comment">// create temporary camera for rendering</span><br>GameObject go = <span class="hljs-keyword">new</span> GameObject( <span class="hljs-string">&quot;CubemapCamera&quot;</span>);<br>go.AddComponent&lt;Camera&gt;();<br><span class="hljs-comment">// place it on the object</span><br>go.transform.position = renderFromPosition.position;<br><span class="hljs-comment">// render into cubemap</span><br>go.GetComponent&lt;Camera&gt;().RenderToCubemap(cubemap);<br><br><span class="hljs-comment">// destroy temporary camera</span><br>DestroyImmediate( go );<br>&#125;<br><br>[<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;GameObject/Render into Cubemap&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RenderCubemap</span> ()</span> &#123;<br>ScriptableWizard.DisplayWizard&lt;RenderCubemapWizard&gt;(<br><span class="hljs-string">&quot;Render cubemap&quot;</span>, <span class="hljs-string">&quot;Render!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们在 renderFromPosition（由用户指定）位置处动态创建一个摄像机，并调用 Camera.RenderToCubemap 函数把从当前位置观察到的图像渲染到用户指定的立方体纹理 cubemap 中，完成后再销毁临时摄像机。由于该代码需要添加菜单栏条目，因此我们需要把它放在 Editor 文件夹下才能正确执行。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_5.png" alt="使用脚本创建立方体纹理" title="使用脚本创建立方体纹理"></p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_6.png" alt="使用脚本渲染立方体纹理" title="使用脚本渲染立方体纹理"></p><p>需要注意的是，我们需要为 Cubemap 设置大小，即上图中的 <strong>Face size</strong> 选项。Face size 值越大，渲染出来的立方体纹理分辨率越大，效果可能更好，但需要占用的内存也越大，这可以由面板最下方显示的内存大小得到。</p><p>准备好了需要的立方体纹理后，我们就可以对物体使用环境映射技术。而环境映射最常见的应用就是反射和折射。</p><h3 id="反射">反射</h3><p>使用了反射效果的物体通常看起来就像镀了层金属。想要模拟反射效果很简单，我们只需要通过入射光线的方向和表面法线方向来计算反射方向，再利用反射方向对立方体纹理采样即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br><br>Shader &quot;Custom/Chapter10/Chapter10-Reflection&quot;<br>&#123;<br>    Properties &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)<br>        _ReflectColor (&quot;Reflection Color&quot;, Color) = (1, 1, 1, 1)<br>        _ReflectAmount (&quot;Reflection Amount&quot;, Range(0, 1)) = 1<br>        _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<br>    &#125;<br><br>    SubShader &#123;<br>        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot; &#125;<br><br>        Pass &#123;<br><br>            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br>            <br>            CGPROGRAM<br>            #pragma multi_compile_fwdbase<br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br>#include &quot;AutoLight.cginc&quot;<br><br>            fixed4 _Color;<br>            fixed4 _ReflectColor;<br>            float _ReflectAmount;<br>            samplerCUBE _Cubemap;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldPos : TEXCOORD0;<br>                float3 worldNormal : TEXCOORD1;<br>                float3 worldViewDir : TEXCOORD2;<br>                float3 worldRefl : TEXCOORD3;<br>                SHADOW_COORDS(4)<br>            &#125;;<br><br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);<br>                o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);<br>                <br>                TRANSFER_SHADOW(o);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET &#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed3 worldViewDir = normalize(i.worldViewDir);<br><br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br><br>                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0,dot(worldNormal,worldLightDir));<br><br>                fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb;<br><br>                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br><br>                fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten;<br><br>                return fixed4(color, 1.0);<br>            &#125;<br><br>            <br><br>            ENDCG<br>        &#125;<br><br>    &#125;<br><br>    FallBack &quot;Reflective/VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>_ReflectColor 用于控制反射颜色，_ReflectAmount 用于控制这个材质的反射程度，而 _Cubemap 就是用于模拟反射的环境映射纹理。使用 CG 中的 <strong>reflect</strong> 函数来计算顶点处的反射方向。物体反射到摄像机中的光线方向，可以由光路可逆的原则来求得。也就是说，我们可以计算视角方向关于顶点法线的反射方向来求得入射光线的方向。</p><p>对立方体纹理的采样需要使用 CG 的 <strong>texCUBE</strong> 函数。注意到，在上面的计算中，我们在采样时并没有对 i.worldRefl 进行归一化操作。这是因为，用于采样的参数仅仅是作为方向变量传递给 texCUBE 函数的，因此我们没有必要进行一次归一化的操作。然后，我们使用 _ReflectAmount 来混合漫反射颜色和反射颜色，并和环境光照相加后返回。</p><p>在上面的计算中，我们选择在顶点着色器中计算反射方向。当然，我们也可以选择在片元着色器中计算，这样得到的效果更加细腻。但是，对于绝大多数人来说这种差别往往是可以忽略不计的，因此出于性能方面的考虑，我们选择在顶点着色器中计算反射方向。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_7.png" alt="反射效果" title="反射效果"></p><h3 id="折射">折射</h3><p>当光线从一种介质（例如空气）斜射入另一种介质（例如玻璃）时，传播方向一般会发生改变。当给定入射角时，我们可以使用**斯涅尔定律（Snell’s Law）**来计算反射角。当光从介质 1 沿着和表面法线夹角为 $\theta _1$ 的方向斜射入介质 2 时，我们可以使用如下公式计算折射光线和法线的夹角 $\theta _2$ ：</p><p>$$<br>\eta _1\sin\theta _1 = \eta _2\sin\theta _2<br>$$</p><p>其中，$\eta _1$ 和 $\eta _2$ 分别是两个介质的<strong>折射率（index of refraction）</strong>。折射率是一项重要的物理常数，例如真空的折射率是 1，而玻璃的折射率一般是 1.5。下图给出了这些变量之间的关系。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_8.png" alt="斯涅尔定律" title="斯涅尔定律"></p><p>通常来说，当得到折射方向后我们就会直接使用它来对立方体纹理进行采样，但是这是不符合物理规律的。对一个透明物体来说，一种更准确的模拟方法需要计算两次折射——一次是当光线进入它的内部时，而另一次则是从它内部射出时。但是，想要在实时渲染中模拟出第二次折射方向是比较复杂的，而且仅仅模拟一次得到的效果在视觉上看起来“也挺像那么回事的”。正如我们之前提到的——图形学第一准则“如果它看起来是对的，那么它就是对的”。因此，在实时渲染中我们通常仅模拟第一次折射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br><br>Shader &quot;Custom/Chapter10/Chapter10-Refraction&quot;<br>&#123;<br>    Properties &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)<br>        _RefractColor (&quot;Refraction Color&quot;, Color) = (1, 1, 1, 1)<br>        _RefractAmount (&quot;Refraction Amount&quot;, Range(0, 1)) = 1<br>        _RefractRatio (&quot;Refraction Ratio&quot;, Range(0.1, 1)) = 0.5<br>        _Cubemap (&quot;Refraction Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<br>    &#125;<br><br>    SubShader &#123;<br>        Tags &#123; &quot;RenderType&quot; = &quot;Opaque&quot; &quot;Queue&quot; = &quot;Geometry&quot; &#125;<br><br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br>            <br>            #pragma multi_compile_fwdbase<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br>            #include &quot;AutoLight.cginc&quot;<br><br>            fixed4 _Color;<br>            fixed4 _RefractColor;<br>            float _RefractAmount;<br>            fixed _RefractRatio;<br>            samplerCUBE _Cubemap;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldPos : TEXCOORD0;<br>                fixed3 worldNormal : TEXCOORD1;<br>                fixed3 worldViewDir : TEXCOORD2;<br>                fixed3 worldRefr : TEXCOORD3;<br>                SHADOW_COORDS(4)<br><br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);<br><br>                o.worldRefr = refract(-normalize(o.worldViewDir), normalize(o.worldNormal), _RefractRatio);<br><br>                TRANSFER_SHADOW(o);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET &#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed3 worldViewDir = normalize(i.worldViewDir);<br><br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br>                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir));<br><br>                fixed3 refraction = texCUBE(_Cubemap, i.worldRefr).xyz * _RefractColor.rgb;<br><br>                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br><br>                fixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten;<br><br>                return fixed4(color, 1.0);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    Fallback &quot;Reflective/VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们使用 _RefractRatio 得到不同介质的透射比来计算折射方向，其他属性和控制反射时使用的属性类似。我们使用了 CG 的 <strong>refract</strong> 函数来计算折射方向。它的第一个参数即为入射光线的方向，它必须是归一化后的矢量；第二个参数是表面法线，法线方向同样需要是归一化后的；第三个参数是入射光线所在介质的折射率和折射光线所在介质的折射率之间的比值，例如如果是光从空气射到玻璃表面，那么这个参数应该是空气的折射率和玻璃的折射率之间的比值，即 1/1.5。它的返回值就是计算而得的折射方向，它的模则等于入射光线的模。</p><p>同样，我们也没有对 i.worldRefr 进行归一化操作，因为对立方体纹理的采样只需要提供方向即可。最后，我们使用 _RefractAmount 来混合漫反射颜色和折射颜色，并和环境光照相加后返回。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_9.png" alt="折射效果" title="折射效果"></p><h3 id="菲涅耳反射">菲涅耳反射</h3><p>在实时渲染中，我们经常会使用**菲涅耳反射（Fresnel reflection）**来根据视角方向控制反射程度。通俗地讲，菲涅耳反射描述了一种光学现象，即当光线照射到物体表面上时，一部分发生反射，一部分进入物体内部，发生折射或散射。被反射的光和入射光之间存在一定的比率关系，这个比率关系可以通过菲涅耳等式进行计算。真实世界的菲涅耳等式是非常复杂的，但在实时渲染中，我们通常会用一些近似公式来计算。其中一个著名的近似公式就是 <strong>Schlick 菲涅耳近似等式</strong>：<br>$$<br>F_{Schlick}(v, n) = F_0 + (1 - F_0)(1 - v \cdot n)^5<br>$$</p><p>其中，$F_0$ 是一个反射系数，用于控制菲涅耳反射的强度，$v$ 是视角方向，$n$ 是表面法线。另一个应用比较广泛的等式是 <strong>Empricial 菲涅耳近似等式</strong>：<br>$$<br>F_{Empricial}(v, n) = \max(0, \min(1, bias + scale \times (1 - v \cdot n)^{power}))<br>$$</p><p>其中，$bias$、$scale$ 和 $power$ 是控制项。</p><p>使用上面的菲涅耳近似等式，我们可以在边界处模拟反射光强和折射光强/漫反射光强之间的变化。在许多车漆、水面等材质的渲染中，我们会经常使用菲涅耳反射来模拟更加真实的反射效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br><br>Shader &quot;Custom/Chapter10/Chapter10-Fresnel&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)<br>        _FresnelScale (&quot;Fresnel Scale&quot;, Range(0, 1)) = 0.5<br>        _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<br>        <br>    &#125;<br><br>    SubShader<br>    &#123;<br>        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot; &#125;<br><br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br><br>            #pragma multi_compile_fwdbase<br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br>            #include &quot;AutoLight.cginc&quot;<br><br>            fixed4 _Color;<br>            fixed _FresnelScale;<br>            samplerCUBE _Cubemap;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldPos : TEXCOORD0;<br>                fixed3 worldNormal : TEXCOORD1;<br>                fixed3 worldViewDir : TEXCOORD2;<br>                fixed3 worldRefl : TEXCOORD3;<br>                SHADOW_COORDS(4)<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);<br>                o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);<br>                TRANSFER_SHADOW(o);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET &#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed3 worldViewDir = normalize(i.worldViewDir);<br><br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br>                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br>                fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb;<br><br>                fixed fresnel = _FresnelScale + (1 - _FresnelScale) * pow(1 - dot(worldViewDir, worldNormal), 5);<br>                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir));<br>                fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;<br>                return fixed4(color, 1.0);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Reflective/VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用 Schlick 菲涅耳近似等式来计算 fresnel 变量，并使用它来混合漫反射光照和反射光照。一些实现也会直接把 fresnel 和反射光照相乘后叠加到漫反射光照上，模拟边缘光照的效果。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_10.png" alt="菲涅耳反射效果" title="菲涅耳反射效果"></p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Texture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插值函数</title>
    <link href="/posts/%E6%8F%92%E5%80%BC%E5%87%BD%E6%95%B0/"/>
    <url>/posts/%E6%8F%92%E5%80%BC%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="线性插值函数">线性插值函数</h2><p>$$<br>lerp(y_1, y_2, weight) = y_1 + (y_2 - y_1) \times weight<br>$$</p><p>其中 $weight$ 是一个在 [0, 1] 区间的实数，倒不是因为取更大的值后这个函数就无定义了，而是因为取了更大的值，这个函数就失去了我们构造它的理由，另外，CG 会限制 $weight$ 的值在 [0, 1] 的范围内，超过这个范围会被留在边界 0 或者边界 1。</p><p>这里 $y_1$ 被称为起点，而 $y_2$ 被称为终点，lerp 函数就是取值 $y_1$ 到 $y_2$ 中间的一个值。取值由 $weight$ 来控制，当 $weight$ 为 0.5 时，取值刚好在起点和终点之间。为了更加方便理解，可以把公式写成这种形式：<br>$$<br>lerp(y_1, y_2, weight) = (1 - weight) \times y_1 + weight \times y_2<br>$$</p><p>简单来说，lerp 函数是在 $y_1$ 和 $y_2$ 之间过渡。$y_1$ 和 $y_2$ 可以是一个值，也可以是一个函数。比如，我们可以在正弦函数和线性函数之间做过渡，我们先看一下正弦函数：</p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_1.png" alt="正弦函数曲线" title="正弦函数曲线"></p><p>再看一下最简单的线性函数 $y = x$</p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_2.png" alt="线性函数曲线" title="线性函数曲线"></p><p>在它俩之间过渡，我们只需要使用 $lerp(\sin x, x, 0.5)$ 即可。当然可以调整 $weight$ 参数观察不同的结果。</p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_3.png" alt="weight 为 0.5" title="weight 为 0.5"></p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_4.png" alt="weight 为 0.8" title="weight 为 0.8"></p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_5.png" alt="weight 为 0.2" title="weight 为 0.2"></p><p>当 $y_1$ 和 $y_2$ 分别为两个点时，结果就是两点间的位置。</p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_6.png" alt="线性插值" title="线性插值"></p><h4 id="贝塞尔曲线">贝塞尔曲线</h4><p>当有 $A$、$B$、$C$ 三个点且有 $D$ 为从 $A$ 到 $C$ 上权重为 $t$ 的插值，$E$ 为从 $C$ 到 $B$ 上权重为 $t$ 的插值，点 $F$ 为从 $D$ 到 $E$ 上权重为 $t$ 的插值，则点 $F$ 是以 $A$ 为起点、$B$ 为终点、$C$ 为控制点的二阶贝塞尔曲线上的一点。</p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_7.png" alt="贝塞尔二阶曲线上的点" title="贝塞尔二阶曲线上的点"></p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_8.png" alt="贝塞尔二阶曲线上的点" title="贝塞尔二阶曲线上的点"></p><p>同理，当有 $A$、$B$、$C$、$D$ 四个点，$E$ 为从 $A$ 到 $C$ 上权重为 $t$ 的插值，$F$ 为从 $C$ 到 $D$ 上权重为 $t$ 的插值，$G$ 为从 $D$ 到 $B$ 上权重为 $t$ 的插值，且 $H$ 为从 $E$ 到 $F$ 上权重为 $t$ 的插值，$I$ 为从 $F$ 到 $G$ 上权重为 $t$ 的插值，$J$ 为从 $H$ 到 $I$ 上权重为 $t$ 的插值，则点 $J$ 是以 $A$ 为起点、$B$ 为终点、$C$ 和 $D$ 为控制点的三阶贝塞尔曲线上的一点。</p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_9.png" alt="贝塞尔三阶曲线上的点" title="贝塞尔三阶曲线上的点"></p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_10.png" alt="贝塞尔三阶曲线上的点" title="贝塞尔三阶曲线上的点"></p><h6 id="二阶贝塞尔曲线公式推导">二阶贝塞尔曲线公式推导</h6><p>由 $f(p_0, p_1, t) = (p_1 - p_0) \times t + p_0$ 可得：</p><p>$$<br>\begin{aligned}<br>D &amp;= (C - A)t + A\<br>E &amp;= (B - C)t + C\<br>F &amp;= (E - D)t + D\<br>&amp;= (((B - C)t + C) - ((C - A)t + A)t + ((C - A)t + A))\<br>&amp;= (At + Bt -2Ct + C - A)t + Ct - At + A\<br>&amp;= (t - 1)^2A + t^2B + 2t(1 - t)C\<br>\<br>B(t) &amp;= (1 - t)^2A + t^2B + 2t(1 - t)C, t \in [0, 1]<br>\end{aligned}<br>$$</p><h6 id="三阶贝塞尔曲线公式推导">三阶贝塞尔曲线公式推导</h6><p>由 $f(p_0, p_1, t) = (p_1 - p_0) \times t + p_0$ 可得：</p><p>$$<br>\begin{aligned}<br>E &amp;= (C - A)t + A\<br>F &amp;= (D - C)t + C\<br>G &amp;= (B - D)t + D\<br>\end{aligned}<br>$$</p><p>$H$ 可以看作以 $A$ 为起点、$D$ 为终点、$C$ 为控制点的二阶贝塞尔曲线上的点，$I$ 可以看作以 $C$ 为起点、$B$ 为终点、$D$ 为控制点的二阶贝塞尔曲线上的点，所以由二阶贝塞尔曲线公式可得：</p><p>$$<br>\begin{aligned}<br>H &amp;= (F - E)t + E\<br>&amp;= (1 - t)^2A + t^2D + 2t(1 - t)C\<br>\<br>I &amp;= (G - F)t + F\<br>&amp;= (1 - t)^2C + t^2B + 2t(1 - t)D\<br>\<br>J &amp;= (I - H)t + H\<br>&amp;= (((1 - t)^2C + t^2B + 2t(1 - t)D) - ((1 - t)^2A + t^2D + 2t(1 - t)C))t + ((1 - t)^2A + t^2D + 2t(1 - t)C)\<br>&amp;= (1 - t)^3A + t^3B + 3t(1 - t)^2C + 3t^2(1 - t)D\<br>\<br>B(t) &amp;= (1 - t)^3A + t^3B + 3t(1 - t)^2C + 3t^2(1 - t)D, t \in [0, 1]<br>\end{aligned}<br>$$</p><p>或者 $J$ 也可以看作以 $E$ 为起点、$G$ 为终点、$F$ 为控制点的二阶贝塞尔曲线上的点，由二阶贝塞尔曲线公式可得：</p><p>$$<br>\begin{aligned}<br>E &amp;= (C - A)t + A\<br>F &amp;= (D - C)t + C\<br>G &amp;= (B - D)t + D\<br>J &amp;= (1 - t)^2E + t^2G + 2t(1 - t)F\<br>&amp;= (1 - t)^2((C - A)t + A) + t^2((B - D)t + D) + 2t(1 - t)((D - C)t + C)\<br>&amp;= (1 - t)^3A + t^3B + 3t(1 - t)^2C + 3t^2(1 - t)D\<br>\<br>B(t) &amp;= (1 - t)^3A + t^3B + 3t(1 - t)^2C + 3t^2(1 - t)D, t \in [0, 1]<br>\end{aligned}<br>$$</p><h2 id="阶梯插值函数">阶梯插值函数</h2><p>step 函数的逻辑是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">step(a, x)&#123;<br>    if(x &lt; a)<br>        return 0;<br>    else<br>        return 1;  <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_11.png" alt="阶梯插值函数" title="阶梯插值函数"></p><h2 id="平滑阶梯插值函数">平滑阶梯插值函数</h2><p>smoothstep 函数可以用来生成 0 到 1 的平滑过渡值，它也叫平滑阶梯函数。smoothstep 函数的定义是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float smoothstep(float a, float b, float x) <br>&#123;<br>  x = clamp((x - a) / (b- a), 0.0, 1.0); <br>  return x * x * (3 - 2 * x);<br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说就是：</p><ul><li>在 a &lt; b 的情况下，当 x &lt; a 时，返回 0，当 x &gt; b 时，返回 1，否则在 0 和 1 之间平滑过渡：</li></ul><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_12.png" alt="平滑阶梯插值函数" title="平滑阶梯插值函数"></p><ul><li>在 a &gt; b 的情况下，当 x &lt; b 时，返回 1，当 x &gt; a 时，返回 0，否则在 0 和 1 之间平滑过渡：</li></ul><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_13.png" alt="平滑阶梯插值函数" title="平滑阶梯插值函数"></p><p>两个 smoothstep 进行减法运算可以得到一些波形图，例如 smoothstep(1, 2, x) - smoothstep(2, 3, x):</p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_14.png" alt="smoothstep(1, 2, x) - smoothstep(2, 3, x)" title="smoothstep(1, 2, x) - smoothstep(2, 3, x)"></p><p>想要增加波峰的持续宽度，可以构造 smoothstep(1, 2, x) - smoothstep(3, 4, x)：</p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_15.png" alt="smoothstep(1, 2, x) - smoothstep(3, 4, x)" title="smoothstep(1, 2, x) - smoothstep(3, 4, x)"></p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更复杂的光照(三)</title>
    <link href="/posts/%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E5%85%89%E7%85%A7(%E4%B8%89)/"/>
    <url>/posts/%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E5%85%89%E7%85%A7(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<h2 id="Unity-的阴影">Unity 的阴影</h2><h4 id="阴影是如何实现的">阴影是如何实现的</h4><p>我们先可以考虑真实生活中阴影是如何产生的。当一个光源发射的一条光线遇到一个不透明物体时，这条光线就不可以再继续照亮其他物体(这里不考虑光线反射)。因此这个物体就会向它旁边的物体投射阴影，那些阴影区域的产生是因为光线无法到达这些区域。</p><p>在实时渲染中，我们最常使用的是一种名为 <strong>Shadow Map</strong> 的技术。这种技术理解起来非常简单，它会首先把摄像机的位置放在与光源重合的位置上，那么场景中该光源的阴影区域就是那些摄像机看不到的地方。而 Unity 就是使用的这种技术。</p><p>在前向渲染路径中，如果场景中最重要的平行光开启了阴影，Unity 就会为该光源计算它的阴影映射纹理(shadow map)。这张阴影映射纹理本质上也是一张深度图，它记录了从该光源的位置出发、能看到的场景中距离它最近的表面位置(深度信息)。</p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_12.png" alt="shadow map" title="shadow map"></p><p>那么，在计算阴影映射纹理时，我们如何判定距离它最近的表面位置呢？一种方法是，先把摄像机放置到光源的位置上，然后按正常的渲染流程，即调用 Base Pass 和 Additional Pass 来更新深度信息，得到阴影映射纹理。但这种方法会对性能造成一定的浪费，因为我们实际上仅仅需要深度信息而已，而 Base Pass 和 Additional Pass 中往往涉及很多复杂的光照模型计算。因此，Unity 选择使用一个额外的 Pass 来专门更新光源的阴影映射纹理，这个 Pass 就是 <strong>LightMode</strong> 标签被设置为 <strong>ShadowCaster</strong> 的 Pass。这个 Pass 的渲染目标不是帧缓冲，而是阴影映射纹理(或深度纹理)。Unity 首先把摄像机放置到光源的位置上，然后调用该 Pass，通过对顶点变换后得到光源空间下的位置，并据此来输出深度信息到阴影映射纹理中。因此，当开启了光源的阴影效果后，底层渲染引擎首先会在当前渲染物体的 Unity Shader 中找到 <strong>LightMode</strong> 为 <strong>ShadowCaster</strong> 的 Pass，如果没有，它就会在 <strong>Fallback</strong> 指定的 Unity Shader 中继续寻找，如果仍然没有找到，该物体就无法向其他物体投射阴影(但它仍然可以接收来自其他物体的阴影)。当找到了一个 <strong>LightMode</strong> 为 <strong>ShadowCaster</strong> 的 Pass 后，Unity 会使用该 Pass 来更新光源的阴影映射纹理。</p><p>在传统的阴影映射纹理的实现中，我们会在正常渲染的 Pass 中把顶点位置变换到光源空间下，以得到它在光源空间中的三维位置信息。然后使用 xy 分量对阴影映射纹理进行采样，得到阴影映射纹理中该位置的深度信息。如果该深度值小于该顶点的深度值(通常由 z 分量得到)，那么说明该点位于阴影中。但 Unity 使用了不同于这种传统的阴影采样技术，即<strong>屏幕空间的阴影映射技术(Screenspace Shadow Map)</strong>。屏幕空间的阴影映射原本是延迟渲染中产生阴影的方法。需要注意的是，并不是所有的平台 Unity 都会使用这种技术。这是因为，屏幕空间的阴影映射需要显卡支持 MRT，而有些移动平台不支持这种特性。</p><p>当使用了屏幕空间的阴影映射技术时，Unity 首先会通过调用 <strong>LightMode</strong> 为 <strong>ShadowCaster</strong> 的 Pass 来得到可投射阴影的光源的阴影映射纹理以及摄像机的深度纹理.然后，根据光源的阴影映射纹理和摄像机的深度纹理来得到屏幕空间的阴影图。如果摄像机的深度图中记录的表面深度大于转换到阴影映射纹理中的深度值，就说明该表面虽然是可见的，但是却处于该光源的阴影中。通过这样的方式，阴影图就包含了屏幕空间中所有有阴影的区域。如果我们想要一个物体接收来自其他物体的阴影，只需要在 Shader 中对阴影图进行采样。由于阴影图是屏幕空间下的，因此我们首先需要把表面坐标从模型空间变换到屏幕空间中，然后使用这个坐标对阴影图进行采样即可。</p><p>总结一下，一个物体接收来自其他物体的阴影，以及它向其他物体投射阴影是两个过程。</p><ul><li>如果我们想要一个物体接收来自其他物体的阴影，就必须在 Shader 中对阴影映射纹理(包括屏幕空间的阴影图)进行采样，把采样结果和最后的光照结果相乘来产生阴影效果。</li><li>如果我们想要一个物体向其他物体投射阴影，就必须把该物体加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。在 Unity 中，这个过程是通过为该物体执行 <strong>LightMode</strong> 为 <strong>ShadowCaster</strong> 的 Pass 来实现的。如果使用了屏幕空间的投影映射技术，Unity 还会使用这个 Pass 产生一张摄像机的深度纹理。</li></ul><h4 id="不透明物体的阴影">不透明物体的阴影</h4><h6 id="1-让物体投射阴影">1. 让物体投射阴影</h6><p>在 Unity 中，为了让场景中可以产生阴影，我们首先需要让平行光可以收集阴影信息。这需要在光源的 Light 组件中开启阴影。我们可以通过设置物体的 <strong>Mesh Renderer</strong> 组件中的 <strong>Cast Shadows</strong> 和 <strong>Receive Shadows</strong> 来选择是否让一个物体投射或接收阴影。</p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_13.png" alt="开启光源的阴影效果" title="开启光源的阴影效果"></p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_14.png" alt="Mesh Renderer" title="Mesh Renderer"></p><p>Cast Shadows 可以被设置为开启(On)或关闭(Off)。如果开启了 Cast Shadows 属性，那么 Unity 就会把该物体加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息。正如之前所说，这个过程是通过为该物体执行 <strong>LightMode</strong> 为 <strong>ShadowCaster</strong> 的 Pass 来实现的。<strong>Receive Shadows</strong> 则可以选择是否让物体接收来自其他物体的阴影。如果没有开启 <strong>Receive Shadows</strong>，那么当我们调用 Unity 的内置宏和变量计算阴影时，这些宏通过判断该物体没有开启接收阴影的功能，就不会在内部为我们计算阴影。</p><p>如果 Unity Shader 中没有 <strong>LightMode</strong> 为 <strong>ShadowCaster</strong> 的 Pass，Unity 会在 Fallback 回调的 Shader 中查找 <strong>LightMode</strong> 为 <strong>ShadowCaster</strong> 的 Pass，如果还是没有找到的话，就会在此回调的 Shader 中的 Fallback 回调中查找。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">//Pass to render object as a shadow caster<br>Pass &#123;<br>    Name &quot;ShadowCaster&quot;<br>    Tags &#123;&quot;LightMode&quot; = &quot;ShadowCaster&quot;&#125;<br><br>    CGPROGRAM<br>    #pragma vertex vert<br>    #pragma fragment frag<br>    #pragma multi_compile_shadowcaster<br>    #include &quot;UnityCG.cginc&quot;<br><br>    struct v2f &#123;<br>        V2F_SHADOW_CASTER;<br>    &#125;;<br><br>    v2f vert(appdata_base v)<br>    &#123;<br>        v2f o;<br>        TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)<br>        return o;<br>    &#125;<br><br>    float4 frag(v2f i) : SV_Target<br>    &#123;<br>        SHADOW_CASTER_FRAGMENT(i)<br>    &#125;<br>    ENDCG<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中有一些宏和指令是我们之前没有遇到过的，但它们的作用就是把深度信息写入到渲染目标中。这个 Pass 的渲染目标可以是光源的阴影映射纹理，也可以是摄像机的深度纹理。</p><h6 id="2-让物体接收阴影">2. 让物体接收阴影</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter9/Chapter9-Shadow&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Diffuse(&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)<br>        _Specular(&quot;Specular&quot;, Color) = (1, 1, 1, 1)<br>        _Gloss(&quot;Gloss&quot;, Range(8.0, 256)) = 20<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;<br><br>        Pass &#123;<br>            // Pass for ambient light &amp; first pixel light(directional light)<br>            Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;<br><br>            CGPROGRAM<br><br>            //Apparently need to add this declaration<br>            #pragma multi_compile_fwdbase<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br>            #include &quot;AutoLight.cginc&quot;<br><br>            fixed4 _Diffuse;<br>            fixed4 _Specular;<br>            float _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                SHADOW_COORDS(2)<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                //可以使用顶点变换矩阵的逆转置矩阵对法线进行变换，首先得到模型空间到世界空间的变换矩阵的<br>                //逆矩阵_World2Object，然后通过调换它在mul函数中的位置，得到和转置矩阵相同的矩阵乘法<br>                //o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br>                //Pass shadow coordinates to pixel shader<br>                TRANSFER_SHADOW(o);<br><br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET &#123;<br>                //Use shadow coordinates to sample shadow map<br>                fixed shadow = SHADOW_ATTENUATION(i);<br><br>                //Get ambient term<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);<br>                //Compute diffuse term<br>                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir));<br>                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);<br>                fixed3 halfDir = normalize(worldLightDir + viewDir);<br>                //Compute Specular term<br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal,halfDir)), _Gloss);<br>                //The attenuation of directional light is awaly 1<br>                fixed atten = 1.0;<br>                return fixed4(ambient + shadow * (diffuse +specular) * atten, 1.0);<br>            &#125;<br>            <br>            ENDCG<br>        &#125;<br><br>        Pass&#123;<br>            //Pass for other pixel lights<br>            Tags &#123;&quot;LightMode&quot; = &quot;ForwardAdd&quot;&#125;<br><br>            Blend One One<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            //Apparently need to add this declaration<br>            #pragma multi_compile_fwdadd<br><br>            #include &quot;AutoLight.cginc&quot;<br>            #include &quot;Lighting.cginc&quot;<br>            <br><br>            fixed4 _Diffuse;<br>            fixed4 _Specular;<br>            float _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                //可以使用顶点变换矩阵的逆转置矩阵对法线进行变换，首先得到模型空间到世界空间的变换矩阵的<br>                //逆矩阵_World2Object，然后通过调换它在mul函数中的位置，得到和转置矩阵相同的矩阵乘法<br>                //o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET &#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br><br>                #ifdef USING_DERECTIONAL_LIGHT <br>                    fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);<br>                #else<br>                    fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);<br>                #endif<br><br>                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));<br>                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);<br>                fixed3 halfDir = normalize(worldLightDir + viewDir);<br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal,halfDir)), _Gloss);<br><br>                #ifdef USING_DIRECTIONAL_LIGHT<br>                    fixed atten = 1.0;<br>                #else<br>                    float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;<br>                    fixed atten = tex2D(_LightTexture0, dot(lightCoord,lightCoord).rr).UNITY_ATTEN_CHANNEL;<br>                #endif<br>                return fixed4((diffuse +specular) * atten, 1.0);<br>            &#125;<br>            <br>            ENDCG<br>        &#125;<br>        <br>    &#125;<br>    FallBack &quot;Specular&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在顶点着色器的输出结构体 v2f 中添加了一个内置宏 <strong>SHADOW_COORDS</strong>，这个宏的作用是声明一个用于对阴影纹理采样的坐标。这个宏的参数是下一个可用的插值寄存器的索引值。在顶点着色器返回之前添加另一个内置宏 <strong>TRANSFER_SHADOW</strong>，这个宏用于在顶点着色器中计算上一步声明的阴影纹理坐标。接着，我们在片元着色器中计算阴影值，这同样使用了一个内置宏 <strong>SHADOW_ATTENUATION</strong>。<strong>SHADOW_COORDS、TRANSFER_SHADOW</strong> 和 <strong>SHADOW_ATTENUATION</strong> 是计算阴影时的“三剑客”。这些内置宏帮助我们在必要时计算光源的阴影。</p><p>在前向渲染中，宏 <strong>SHADOW_COOEDS</strong> 实际上就是声明了一个名为 _ShadowCoord 的阴影纹理坐标变量。而 <strong>TRANSFER_SHADOW</strong> 的实现会根据平台不同而有所差异。如果当前平台可以使用屏幕空间的阴影映射技术(通过判断是否定义了 <strong>UNITY_NO_SCREENSPACE_SHADOWS</strong> 来得到)，<strong>TRANSFER_SHADOW</strong> 会调用内置的 ComputeScreenPos 函数来计算 _ShadowCoord；如果该平台不支持屏幕空间的阴影映射技术，就会使用传统的阴影映射技术，<strong>TRANSFER_SHADOW</strong> 会把顶点坐标从模型空间变换到光源空间后存储到 _ShadowCoord 中。然后，<strong>SHADOW_ATTENUATION</strong> 负责使用 _ShadowCoord 对相关的纹理进行采样，得到阴影信息。当关闭了阴影后，<strong>SHADOW_COORDS</strong> 和 <strong>TRANSFER_SHADOW</strong> 实际没有任何作用，而 <strong>SHADOW_ATTENUATION</strong> 会直接等同于数值 1。</p><p>需要注意的是，这些宏中会使用上下文变量来进行相关计算，例如 TRANSFER_SHADOW 会使用 v.vertex 或 a.pos 来计算坐标，因此为了能够让这些宏正确工作，我们需要保证自定义的变量名和这些宏中使用的变量名相匹配。我们需要保证：a2f 结构体中的顶点坐标变量名必须是 <strong>vertex</strong>，顶点着色器的输入结构体 a2v 必须命名为 <strong>v</strong>，且 v2f 中的顶点位置变量必须命名为 <strong>pos</strong>。</p><h4 id="使用帧调试器查看阴影绘制过程">使用帧调试器查看阴影绘制过程</h4><p>绘制场景的渲染事件可以分为 4 个部分：UpdateDepthTexture，即更新摄像机的深度纹理；RenderShadowmap，即渲染得到平行光的阴影映射纹理；CollectShadows，即根据深度纹理和阴影映射纹理得到屏幕空间的阴影图；</p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_15.png" alt="使用帧调试器查看阴影绘制过程" title="使用帧调试器查看阴影绘制过程"></p><p>我们首先来看第一个部分：更新摄像机的深度纹理。下图给出了正方体对深度纹理的更新结果。</p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_16.png" alt="正方体对深度纹理的更新结果" title="正方体对深度纹理的更新结果"></p><p>在上图中，Unity 调用了 Custom/Chapter9-Shadow,SubShader #2 来更新深度纹理，即 Chapter9-Shadow 中的第二个 SubShader。尽管 Chapter9-Shadow 中只定义了一个 SubShader，但正如我们之前所说，Unity 会在它的 Fallback 中找到第二个 SubShader，并使用其中 <strong>LightMode</strong> 为 <strong>ShadowCaster</strong> 的 Pass 来更新摄像机的深度纹理。同样，在第二个部分，即渲染得到平行光的阴影映射纹理的过程中，Unity 也是调用了这个 Pass 来得到光源的阴影映射纹理。</p><p>在第三个部分中，Unity 会根据之前两步的结果得到屏幕空间的阴影图，如下图所示：</p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_17.png" alt="屏幕空间的阴影图" title="屏幕空间的阴影图"></p><p>这张图已经包含了最终屏幕上所有阴影区域的阴影。在最后一个部分中，如果物体所使用的 Shader 包含了对这张阴影图的采样就会得到阴影效果。下图给出了这个部分 Unity 是如何一步步绘制出有阴影的画面效果的。</p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_18.png" alt="Unity 绘制屏幕阴影的过程" title="Unity 绘制屏幕阴影的过程"></p><h4 id="统一管理光照衰减和阴影">统一管理光照衰减和阴影</h4><p>在上一篇中我们已经讲过如何在 Unity Shader 的前向渲染路径中计算光照衰减——在 Base Pass 中，平行光的衰减因子总是等于 1，而在 Additional Pass 中，我们需要判断该 Pass 处理的光源类型，再使用内置变量和宏计算衰减因子。实际上，光照衰减和阴影对物体最终的渲染结果的影响本质上是相同的——我们都是把光照衰减因子和阴影值及光照结果相乘得到最终的渲染结果。那么，是不是可以有一个方法可以同时计算两个信息呢？好消息是，Unity 在 Shader 里提供了这样的功能，这主要是通过内置的 <strong>UNITY_LIGHT_ATTENUATION</strong> 宏来实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter9/Chapter9-AttenuationAndShadowUseBuildInFunctions&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Diffuse(&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)<br>        _Specular(&quot;Specular&quot;, Color) = (1, 1, 1, 1)<br>        _Gloss(&quot;Gloss&quot;, Range(8.0, 256)) = 20<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;<br><br>        Pass &#123;<br>            // Pass for ambient light &amp; first pixel light(directional light)<br>            Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;<br><br>            CGPROGRAM<br><br>            //Apparently need to add this declaration<br>            #pragma multi_compile_fwdbase<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br>            #include &quot;AutoLight.cginc&quot;<br><br>            fixed4 _Diffuse;<br>            fixed4 _Specular;<br>            float _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                SHADOW_COORDS(2)<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                //可以使用顶点变换矩阵的逆转置矩阵对法线进行变换，首先得到模型空间到世界空间的变换矩阵的<br>                //逆矩阵_World2Object，然后通过调换它在mul函数中的位置，得到和转置矩阵相同的矩阵乘法<br>                //o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br>                //Pass shadow coordinates to pixel shader<br>                TRANSFER_SHADOW(o);<br><br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET &#123;<br><br>                //Get ambient term<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);<br>                //Compute diffuse term<br>                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir));<br>                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);<br>                fixed3 halfDir = normalize(worldLightDir + viewDir);<br>                //Compute Specular term<br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal,halfDir)), _Gloss);<br>                //fixed atten = 1.0;<br>                //UNITY_LIGHT_ATTENUATION not only compute attenuation,but also shadow infos<br>                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br>                return fixed4(ambient + (diffuse +specular) * atten, 1.0);<br>            &#125;<br>            <br>            ENDCG<br>        &#125;<br><br>        Pass&#123;<br>            //Pass for other pixel lights<br>            Tags &#123;&quot;LightMode&quot; = &quot;ForwardAdd&quot;&#125;<br><br>            Blend One One<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            //Apparently need to add this declaration<br>            #pragma multi_compile_fwdadd<br><br>            #include &quot;AutoLight.cginc&quot;<br>            #include &quot;Lighting.cginc&quot;<br>            <br><br>            fixed4 _Diffuse;<br>            fixed4 _Specular;<br>            float _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                //可以使用顶点变换矩阵的逆转置矩阵对法线进行变换，首先得到模型空间到世界空间的变换矩阵的<br>                //逆矩阵_World2Object，然后通过调换它在mul函数中的位置，得到和转置矩阵相同的矩阵乘法<br>                //o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br>                TRANSFER_SHADOW(o);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET &#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                <br>                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));<br>                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);<br>                fixed3 halfDir = normalize(worldLightDir + viewDir);<br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal,halfDir)), _Gloss);<br>                //fixed atten = 1.0;<br>                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br>                <br>                return fixed4((diffuse +specular) * atten, 1.0);<br>            &#125;<br>            <br>            ENDCG<br>        &#125;<br>        <br>    &#125;<br>    FallBack &quot;Specular&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>UNITY_LIGHT_ATTENUATION</strong> 是 Unity 内置的用于计算光照衰减和阴影的宏，我们可以在内置的 AutoLight.cginc 里找到它的相关声明。它接受三个参数，它会将光照衰减和阴影值相乘后的结果存储到第一个参数中。注意到，我们并没有在代码中声明第一个参数 <strong>atten</strong>，这是因为 <strong>UNITY_LIGHT_ATTENUATION</strong> 会帮我们声明这个变量。它的第二个参数是结构体 v2f，这个参数会传递给上面讲过的 <strong>SHADOW_ATTENUATION</strong>，用来计算阴影值。而第三个参数是世界空间的坐标，这个参数会用于计算光源空间下的坐标，再对光照衰减纹理采样来得到光照衰减。Unity 针对不同光源类型、是否启用 cookie 等不同情况声明了多个版本的 <strong>UNITY_LIGHT_ATTENUATION</strong>。这些不同版本的声明是保证我们可以通过这样一个简单的代码来得到正确结果的关键。</p><p>由于使用了 <strong>UNITY_LIGHT_ATTENUATION</strong>，我们的 Base Pass 和 Additional Pass 的代码得以统一——我们不需要在 Bass Pass 里单独处理阴影，也不需要在 Additional Pass 中判断光源类型来处理光照衰减，一切都只需要通过 <strong>UNITY_LIGHT_ATTENUATION</strong> 来完成即可。这正是 Unity 内置文件的魅力所在。如果我们希望可以在 Additional Pass 中添加阴影效果，就需要使用 #pragma multi_compile_fwdadd_fullshadows 编译指令来代替 Additional Pass 中的 #pragma multi_compile_fwdadd 指令。这样一来，Unity 也会为这些额外的逐像素光源计算阴影，并传递给 Shader。</p><h4 id="透明度物体的阴影">透明度物体的阴影</h4><p>我们从一开始就强调，想要在 Unity 里让物体能够向其他物体投射阴影，一定要在它使用的 Unity Shader 中提供一个 <strong>LightMode</strong> 为 <strong>ShadowCaster</strong> 的 Pass。在前面的例子中，我们使用内置的 <strong>VertexLit</strong> 中提供的 <strong>ShadowCaster</strong> 来投射阴影。<strong>VertexLit</strong> 中的 <strong>ShadowCaster</strong> 实现很简单，它会正常渲染整个物体，然后把深度结果输出到一张深度图或阴影映射纹理中。对于大多数不透明物体来说，把 <strong>Fallback</strong> 设为 <strong>VertexLit</strong> 就可以得到正确的阴影。但对于透明物体来说，我们就需要小心处理它的阴影。透明物体的实现通常会使用透明度测试或透明度混合，我们需要小心设置这些物体的 Fallback。</p><p>透明度测试的处理比较简单，但如果我们仍然直接使用 VertexLit、Diffuse、Specular 等作为回调，往往无法得到正确的阴影。这是因为透明度测试需要在片元着色器中舍弃某些片元，而 VertexLit 中的阴影投射纹理并没有进行这样的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter9/Chapter9-AlphaTestWithShadow&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Main Tint&quot;, Color) = (1,1,1,1)<br>        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Cutoff (&quot;Alpha Cutoff&quot;, Range(0, 1)) = 0.5<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags &#123; &quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProhector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot; &#125;<br>        <br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br>            #include &quot;AutoLight.cginc&quot;<br><br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            fixed _Cutoff;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>                SHADOW_COORDS(3)<br>            &#125;;<br><br>            v2f vert(a2v v)&#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                TRANSFER_SHADOW(o);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target&#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed4 texColor = tex2D(_MainTex, i.uv);<br><br>                clip(texColor.a - _Cutoff);<br>                //Equal to<br>                //if((texColor.a - _Cutoff) &lt; 0.0)&#123;<br>                //  discard;<br>                //&#125;<br>                fixed3 albedo = texColor.rgb * _Color.rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br>                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));<br>                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br>                return fixed4(ambient + diffuse * atten, 1.0);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Transparent/Cutout/VertexLit&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>在结构体 v2f 中，由于我们已经占用了 3 个插值寄存器(使用 TEXCOORD0、TEXCOORD1 和 TEXCOORD2 修饰的变量)，因此 <strong>SHADOW_COORDS</strong> 中传入的参数是 3，这意味着，阴影纹理坐标将占用第四个插值寄存器 TEXCOOERD3。内置的 <strong>VertexLit</strong> 中提供的 <strong>ShadowCaster</strong> 的 Pass 中没有进行任何透明度测试的计算，因此，它会把整个物体的深度信息渲染到深度图和阴影映射纹理中。因此，如果我们想要得到经过透明度测试后的阴影效果，就需要一个有透明度测试功能的 <strong>ShadowCaster Pass</strong>。所以，我们把 Fallback 设置为 <strong>Transparent/Cutout/VertexLit</strong>，它的 <strong>ShadowCaster Pass</strong> 计算了透明度测试，因此会把裁剪后的物体深度信息写入深度图和阴影映射纹理中。但需要注意的是，由于 <strong>Transparent/Cutout/VertexLit</strong> 中计算透明度测试时，使用了名为 _Cutoff 的属性，因此，这要求我们的 Shader 中也必须提供名为 _Cutoff 的属性。否则，同样无法得到正确的阴影结果。</p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_19.png" alt="正确设置了 Fallback 的使用透明度测试的物体" title="正确设置了 Fallback 的使用透明度测试的物体"></p><p>但是，这样的结果仍然有一些问题，例如出现了一些不应该透过光的部分。出现这种情况的原因是，默认情况下把物体渲染到深度图和阴影映射纹理中仅考虑物体的正面。但对于本例的正方体来说，由于一些面完全背对光源，因此这些面的深度信息没有加入到阴影映射纹理的计算中。为了得到正确的结果，我们可以将正方体的 Mesh Renderer 组件中的 Cast Shadows 属性设置为 <strong>Two Sided</strong>，强制 Unity 在计算阴影映射纹理时计算所有面的深度信息。</p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_20.png" alt="正确设置了 Cast Shadow 属性的使用透明度测试的物体" title="正确设置了 Cast Shadow 属性的使用透明度测试的物体"></p><p>与透明度测试的物体相比，想要为使用透明度混合的物体添加阴影是一件比较复杂的事情。事实上，所有内置的透明度混合的 Unity Shader，如 Transparent/VertexLit 等，都没有包含阴影投射的 Pass。这意味着，这些半透明物体不会参与深度图和阴影映射纹理的计算，也就是说，它们不会向其他物体投射阴影，同样它们也不会接收来自其他物体的阴影。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter9/Chapter9-AlphaBlendWithShadow&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Main Tint&quot;, Color) = (1,1,1,1)<br>        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _AlphaScale (&quot;Alpha Scale&quot;, Range(0, 1)) = 1<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProhector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &#125;<br>        <br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br>            ZWrite Off<br>            Blend SrcAlpha OneMinusSrcAlpha<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br>            #include &quot;AutoLight.cginc&quot;<br><br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            fixed _AlphaScale;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>                SHADOW_COORDS(3)<br>            &#125;;<br><br>            v2f vert(a2v v)&#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                TRANSFER_SHADOW(o);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target&#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed4 texColor = tex2D(_MainTex, i.uv);<br>                fixed3 albedo = texColor.rgb * _Color.rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br>                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));<br>                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br>                return fixed4(ambient + diffuse * atten, texColor.a * _AlphaScale);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Transparent/VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_21.png" alt="Fallback 设为 Transparent/VertexLit 使用透明度混合的物体" title="Fallback 设为 Transparent/VertexLit 使用透明度混合的物体"></p><p>Unity 会这样处理半透明物体是有它的原因的。由于透明度混合需要关闭深度写入，由此带来的问题也影响了阴影的生成。总体来说，要想为这些半透明物体产生正确的阴影，需要在每个光源空间下仍然严格按照从后往前的顺序进行渲染，这会让阴影处理变得非常复杂，而且也会影响性能。因此，在 Unity 中，所有内置的半透明 Shader 是不会产生任何阴影效果的。当然，我们也可以使用一些方法来强制为半透明物体生成阴影，这可以通过把它们的 Fallback 设置为 VertexLit、Diffuse 这些不透明物体使用的 Unity Shader，这样 Unity 就会在它的 Fallback 找到一个阴影投射的 Pass。然后，我们可以通过物体的 Mesh Renderer 组件上的 Cast Shadows 和 Receive Shadows 选项来控制是否需要向其他物体投射或接收阴影。</p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_22.png" alt="Fallback 设为 VertexLit 强制为半透明物体生成阴影" title="Fallback 设为 VertexLit 强制为半透明物体生成阴影"></p><p>可以看出，此时右侧平面的阴影投射到了半透明的立方体上，但它不会再穿透立方体把阴影投射到下方的平面上，这其实是不正确的。同时，立方体也可以把自身的阴影投射到下面的平面上。</p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Light</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更复杂的光照(二)</title>
    <link href="/posts/%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E5%85%89%E7%85%A7(%E4%BA%8C)/"/>
    <url>/posts/%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E5%85%89%E7%85%A7(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h2 id="Unity-的光源类型">Unity 的光源类型</h2><p>Unity 一共支持 4 种光源类型：<strong>平行光(directional light)</strong>、<strong>点光源(point light)</strong>、<strong>聚光灯(spot light)<strong>和</strong>面光源(area light)</strong>。面光源仅在烘焙时才可发挥作用，因此不在本节讨论范围内。</p><h4 id="光源类型有什么影响">光源类型有什么影响</h4><p>Shader 中使用的光源属性最常用的有光源的<strong>位置、方向</strong>(更具体的说就是到某点的方向)<strong>、颜色、强度以及衰减</strong>(更具体的说就是，到某点的衰减，与该点到光源的距离有关)。这些属性和光源的几何定义息息相关。</p><h6 id="1-平行光">1. 平行光</h6><p>平行光可以照亮的范围没有限制，它通常作为太阳这样的角色在场景中出现。平行光没有唯一的位置，它可以放在场景中的任意位置。它的几何属性只有方向，而且平行光到场景中的所有点的方向都是一样的。除此之外，由于平行光没有一个具体的位置，因此也没有衰减的概念，也就是说，光照强度不会随着距离而发生改变。</p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_3.png" alt="平行光" title="平行光"></p><h6 id="2-点光源">2. 点光源</h6><p>点光源的照亮空间时有限的，它由空间中的一个球体定义。点光源可以表示由一个点发出的、向所有方向延伸的光。球体的半径可以由面板中的 Range 属性来调整，也可以在 Scene 视图中直接拖拉点光源的线框来修改。点光源有位置属性，由点光源的 Transform 组件中的 Position 属性定义。对于方向属性，我们需要用点光源的位置减去某点的位置来得到它到该点的方向。而点光源的颜色和方向可以在 Light 组件中调整。同时，点光源也是会衰减的，随着物体逐渐远离点光源，它接收到的光照强度也会逐渐减小。点光源球心处的光照强度最强，球体边界处的最弱，值为 0。其中间的衰减值可以由一个函数定义。</p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_4.png" alt="点光源" title="点光源"></p><h6 id="3-聚光灯">3. 聚光灯</h6><p>聚光灯的照亮空间同样是有限的，是由空间中的一块锥形区域定义的。聚光灯可以用于表示由一个特定位置出发、向特定方向延伸的光。这块锥形区域的半径由面板中的 Range 属性决定，而锥体的张开角度由 Spot Angle 属性决定。我们同样也可以在 Scene 视图中直接拖拉聚光灯的线框来修改它的属性。聚光灯的位置同样是由 Transform 组件中的 Position 属性定义的。对于方向属性，我们需要用聚光灯的位置减去某点的位置来得到它到该点的方向。聚光灯的衰减也是随着物体逐渐远离点光源而逐渐减小，在锥形的顶点处光照强度最强，在锥形的边界处强度为 0。其中间的衰减值可以由一个函数定义，这个函数相对于点光源衰减计算公式要更加复杂，因为我们需要判断一个点是否在锥体的范围内。</p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_5.png" alt="聚光灯" title="聚光灯"></p><h4 id="在前向渲染中处理不同的光源类型">在前向渲染中处理不同的光源类型</h4><p>在了解了 3 种光源的几何定义后，我们来看一下如何在 Unity Shader 中访问它们的 5 个属性：<strong>位置、方向、颜色、强度以及衰减</strong>。需要注意的是，本节均建立在使用前向渲染路径的基础上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_LightMatrix0&#x27; with &#x27;unity_WorldToLight&#x27;<br><br>Shader &quot;Custom/Chapter9/Chapter9-ForwardRendering&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Diffuse(&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)<br>        _Specular(&quot;Specular&quot;, Color) = (1, 1, 1, 1)<br>        _Gloss(&quot;Gloss&quot;, Range(8.0, 256)) = 20<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;<br><br>        Pass &#123;<br>            // Pass for ambient light &amp; first pixel light(directional light)<br>            Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;<br><br>            CGPROGRAM<br><br>            //Apparently need to add this declaration<br>            #pragma multi_compile_fwdbase<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br><br>            fixed4 _Diffuse;<br>            fixed4 _Specular;<br>            float _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                //可以使用顶点变换矩阵的逆转置矩阵对法线进行变换，首先得到模型空间到世界空间的变换矩阵的<br>                //逆矩阵_World2Object，然后通过调换它在mul函数中的位置，得到和转置矩阵相同的矩阵乘法<br>                //o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET &#123;<br>                //Get ambient term<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);<br>                //Compute diffuse term<br>                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * max(0, dot(worldNormal, worldLightDir));<br>                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);<br>                fixed3 halfDir = normalize(worldLightDir + viewDir);<br>                //Compute Specular term<br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal,halfDir)), _Gloss);<br>                //The attenuation of directional light is awaly 1<br>                fixed atten = 1.0;<br>                return fixed4(ambient + (diffuse +specular) * atten, 1.0);<br>            &#125;<br>            <br>            ENDCG<br>        &#125;<br><br>        Pass&#123;<br>            //Pass for other pixel lights<br>            Tags &#123;&quot;LightMode&quot; = &quot;ForwardAdd&quot;&#125;<br><br>            Blend One One<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            //Apparently need to add this declaration<br>            #pragma multi_compile_fwdadd<br><br>            #include &quot;AutoLight.cginc&quot;<br>            #include &quot;Lighting.cginc&quot;<br>            <br><br>            fixed4 _Diffuse;<br>            fixed4 _Specular;<br>            float _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                //可以使用顶点变换矩阵的逆转置矩阵对法线进行变换，首先得到模型空间到世界空间的变换矩阵的<br>                //逆矩阵_World2Object，然后通过调换它在mul函数中的位置，得到和转置矩阵相同的矩阵乘法<br>                //o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET &#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br><br>                #ifdef USING_DERECTIONAL_LIGHT <br>                    fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);<br>                #else<br>                    fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);<br>                #endif<br><br>                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));<br>                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);<br>                fixed3 halfDir = normalize(worldLightDir + viewDir);<br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal,halfDir)), _Gloss);<br><br>                #ifdef USING_DIRECTIONAL_LIGHT<br>                    fixed atten = 1.0;<br>                #else<br>                    #if defined(POINT)<br>                        float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;<br>                        fixed atten = tex2D(_LightTexture0, dot(lightCoord,lightCoord).rr).UNITY_ATTEN_CHANNEL;<br>                    #elif defined(SPOT)<br>                        float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1));<br>                        fixed atten = (lightCoord.z &gt; 0) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + 0.5).w * tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;<br>                    #else<br>                        fixed atten = 1.0;<br>                    #endif<br>                #endif<br>                return fixed4((diffuse +specular) * atten, 1.0);<br>            &#125;<br>            <br>            ENDCG<br>        &#125;<br>        <br>    &#125;<br>    FallBack &quot;Specular&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们在 Base Pass 中处理了场景中的最重要的平行光。在这个例子中，场景中只有一个平行光。如果场景中包含了多个平行光，Unity 会选择最亮的平行光传递给 Base Pass 进行逐像素处理，其他平行光会按照逐顶点或在 Additional Pass 中按逐像素的方式处理。如果场景中没有任何平行光，那么 Base Pass 会当成全黑的光源处理。我们提到过，每一个光源有 5 个属性：位置、方向、颜色、强度以及衰减。对于 Base Pass 来说，它处理的逐像素光源类型一定是平行光。我们可以使用 _WorldSpaceLightPos0 来得到这个平行光的方向(位置对于平行光来说没有意义)，使用 _LightColor0 来得到它的颜色和强度(_LightColor0 已经是颜色和强度相乘后的结果)，由于平行光可以认为是没有衰减的，因此这里我们直接令衰减值为 1.0。</p><p>我们在 Additional Pass 中使用 Blend 命令开启和设置了混合模式。这是因为开启混合模式可以让 Additional Pass 计算得到的光照结果可以在帧缓存中与之前的光照结果进行叠加。如果没有使用 Blend 命令的话，Additional Pass 会直接覆盖掉之前的光照结果。我们通过判断是否定义了 USING_DIRECTIONAL_LIGHT 来决定当前处理的光源类型。如果是平行光的话，衰减值是 1.0。如果是其他光源类型，那么处理更复杂一些。尽管我们可以使用数学表达式来计算给定点相对于点光源和聚光灯的衰减，但这些计算往往涉及开根号、除法等计算量相对较大的操作，因此 Unity 选择了使用一张纹理作为查找表(Lookup Table, LUT)，以在片元着色器中得到光源的衰减。我们首先得到光源空间下的坐标，然后使用该坐标对衰减纹理进行采样得到衰减值。</p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_6.png" alt="使用一个平行光和一个点光源共同照亮物体" title="使用一个平行光和一个点光源共同照亮物体"></p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_7.png" alt="使用一个平行光和四个点光源照亮一个物体" title="使用一个平行光和四个点光源照亮一个物体"></p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_8.png" alt="打开帧调试器查看场景的绘制事件" title="打开帧调试器查看场景的绘制事件"></p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_9.png" alt="本例中的6个渲染事件" title="本例中的6个渲染事件"></p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_10.png" alt="如果物体不在一个光源的光照范围内，Unity不会调用Additional Pass来为该物体处理该光源" title="如果物体不在一个光源的光照范围内，Unity不会调用Additional Pass来为该物体处理该光源"></p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_11.png" alt="把光源的RenderMode设为Not Important时，这些光源就不会按逐像素光来处理" title="把光源的RenderMode设为Not Important时，这些光源就不会按逐像素光来处理"></p><h2 id="Unity-的光照衰减">Unity 的光照衰减</h2><p>Unity 使用一张纹理作为查找表来在片元着色器中计算逐像素光照的衰减。这样的好处在于计算衰减不依赖于数学公式的复杂性，我们只要使用一个参数值去纹理中采样即可。但使用纹理查找来计算衰减也有一些弊端。</p><ul><li>需要预处理得到采样纹理，而且纹理的大小也会影响衰减的精度。</li><li>不直观，同时也不方便，因此一旦把数据存储到查找表中，我们就无法使用其他数学公式来计算衰减。</li></ul><p>但由于这种方法可以在一定程度上提升性能，而且得到的效果在大部分情况下都是良好的，因此 Unity 默认就是使用这种纹理查找的方式来计算逐像素的点光源和聚光灯的衰减的。</p><h4 id="用于光照衰减的纹理">用于光照衰减的纹理</h4><p>Unity 在内部使用一张名为 _LightTexture0 的纹理来计算光源衰减。如果我们使用了 cookie，那么衰减查找纹理是 _LightTextureB0。我们通常只关心 _LightTexture0 对角线上的纹理颜色值，这些值表明了在光源空间中不同位置的点的衰减值。例如，(0, 0)点表明了与光源位置重合的点的衰减值，而(1, 1)点表明了在光源空间中所关心的距离最远的点的衰减。</p><p>为了对 _LightTexture0 纹理采样得到给定点到该光源的衰减值，我们首先需要得到该点在光源空间中的位置，这是通过 _LightMatrix0 变换矩阵得到的。_LightMatrix0 可以把顶点从世界空间变换到光源空间。因此只需要把 _LightMatrix0 和世界空间中的顶点坐标相乘即可得到光源空间中的相应位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float3 lightCoord = mul(_LightMatrix0, float4(i.worldPosition, 1)).xyz;<br></code></pre></td></tr></table></figure><p>然后我们可以使用这个坐标的模的平方对衰减纹理进行采样，得到衰减值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;<br></code></pre></td></tr></table></figure><p>我们使用了光源空间中顶点距离的平方(通过 dot 函数来得到)来对纹理采样，之所以没有使用距离值来采样是因为这种方法可以避免开方操作。然后，我们使用宏 UNITY_ATTEN_CHANNEL 来得到衰减值所在的分量，以得到最终的衰减值。</p><h4 id="使用数学公式计算衰减">使用数学公式计算衰减</h4><p>尽管纹理采样的方法可以减少计算衰减时的复杂度，但有时我们希望可以在代码中利用公式来计算光源的衰减。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float distance = length(_WorldSpaceLightPos0.xyz - i.worldPosition.xyz);<br>atten = 1.0 / distance; //linear attenuation<br></code></pre></td></tr></table></figure><p>可惜的是，Unity 没有在文档中给出内置衰减计算的相关说明。尽管我们仍然可以在片元着色器中利用一些数学公式来计算衰减，但由于我们无法在 Shader 中通过内置变量得到光源的范围、聚光灯的朝向、张开角度等信息，因此得到的效果往往在有些时候不尽如人意，尤其在物体离开光源的照明范围时会发生突变(这是因为，如果物体不在该光源的照明范围内， Unity 就不会为物体执行一个 Additional Pass)。当然，我们可以利用脚本将光源的相关信息传递给 Shader，但这样的灵活性很低。</p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Light</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更复杂的光照(一)</title>
    <link href="/posts/%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E5%85%89%E7%85%A7(%E4%B8%80)/"/>
    <url>/posts/%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E5%85%89%E7%85%A7(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h2 id="Unity-的渲染路径">Unity 的渲染路径</h2><p>在 Unity 里，**渲染路径(Rendering Path)**决定光照是如何运用到 Unity Shader 中的。我们需要为每个 Pass 指定它使用的渲染路径，只有这样才能让 Unity 正确地为我们准备光源和处理后的光照信息等数据，也就是说，我们只有为 Shader 正确地选择和设置了需要的渲染路径，该 Shader 的光照计算才能被正确执行。</p><p>Unity 支持多种类型的渲染路径。<strong>前向渲染路径(Forward Rendering Path)</strong>、<strong>延迟渲染路径(Deferred Rendering Path)<strong>和</strong>顶点照明渲染路径(Vertex Lit Rendering Path)</strong>。顶点照明渲染路径已经被 Unity 抛弃，新的延迟渲染路径代替了原来的延迟渲染路径(但目前仍然可以对之前使用了顶点照明渲染路径和旧的延迟渲染路径的 Unity Shader 兼容)。</p><p>大多数情况下，一个项目只用一种渲染路径，因此我们可以通过在 Unity 的 Edit -&gt; Project Settings -&gt; Graphics -&gt; Tier Settings -&gt; Rendering Path 中选择项目所需的渲染路径。默认情况下该设置选择的都是前向渲染路径。但有时我们希望使用多个渲染路径，如不同的摄像机使用不同的渲染路径，这时我们可以在摄像机的渲染路径设置中进行设置，以覆盖 Project Settings 中的设置。如果当前显卡不支持所选择的渲染路径，Unity 会自动使用更低一级的渲染路径。例如，如果一个 GPU 不支持延迟渲染，那么 Unity 就会使用前向渲染。</p><p>完成上面的设置后，我们就可以在每个 Pass 中使用 <strong>LightMode</strong> 标签来指定该 Pass 使用的渲染路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br></code></pre></td></tr></table></figure><p>上面的代码将告诉 Unity，该 Pass 使用前向渲染路径中的 <strong>ForwardBase</strong> 路径。而前向渲染路径还有一种路径叫 <strong>ForwardAdd</strong>。下表给出了 Pass 的 LightMode 标签支持的渲染路径设置选项。</p><table><thead><tr><th style="text-align:left">标签名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Always</td><td style="text-align:left">不管使用哪种渲染路径，该 Pass 总是会被渲染，但不会计算任何光照</td></tr><tr><td style="text-align:left">ForwardBase</td><td style="text-align:left">用于<strong>前向渲染</strong>。该 Pass 会计算环境光、最重要的平行光、逐顶点/SH 光源和 Lightmaps</td></tr><tr><td style="text-align:left">ForwardAdd</td><td style="text-align:left">用于<strong>前向渲染</strong>。该 Pass 会计算额外的逐像素光源，每个 Pass 对应一个光源</td></tr><tr><td style="text-align:left">Deferred</td><td style="text-align:left">用于<strong>延迟渲染</strong>。该 Pass 会渲染 G 缓冲(G-buffer)</td></tr><tr><td style="text-align:left">ShadowCaster</td><td style="text-align:left">把物体的深度信息渲染到阴影映射纹理(shadowmap)或一张深度纹理中</td></tr><tr><td style="text-align:left">PrepassBase</td><td style="text-align:left">用于<strong>遗留的延迟渲染</strong>。该 Pass 会渲染法线和高光反射的指数部分</td></tr><tr><td style="text-align:left">PrepassFinal</td><td style="text-align:left">用于<strong>遗留的延迟渲染</strong>。该 Pass 通过合并纹理、光照和自发光来渲染得到最后的颜色</td></tr><tr><td style="text-align:left">Vertex、VertexLMRGBM 和 VertexLM</td><td style="text-align:left">用于<strong>遗留的顶点照明渲染</strong>。</td></tr></tbody></table><p>指定渲染路径是我们和 Unity 底层渲染引擎的一次重要的沟通。例如，如果我们为一个 Pass 设置了前向渲染路径的标签，Unity 会把那些光照属性都按前向渲染的流程准备好，我们就可以通过 Unity 提供的内置光照变量来访问这些属性。如果我们没有指定任何渲染路径，那么一些光照变量很可能不会被正确赋值，我们计算出的效果也就很有可能是错误的。</p><h4 id="前向渲染路径">前向渲染路径</h4><h6 id="1-前向渲染路径的原理">1. 前向渲染路径的原理</h6><p>每进行一次完整的前向渲染，我们需要渲染该对象的渲染图元，并计算两个缓冲区的信息：一个是颜色缓冲区，一个是深度缓冲区。我们利用深度缓冲来决定一个片元是否可见，如果可见就更新颜色缓冲区中的颜色值。我们可以利用下面的伪代码来描述前向渲染路径的大致过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Pass &#123;<br>    for (each primitive in this model) &#123;<br>        for (each fragment covered by this primitive) &#123;<br>            if (failed in depth test) &#123;<br>                //如果没有通过深度测试，说明该片元是不可见的<br>                discard;<br>            &#125; else &#123;<br>                //如果该片元可见，就进行光照计算<br>                float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);<br>                //更新帧缓冲<br>                writeFrameBuffer(fragment, color);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于每个逐像素光源，我们都需要进行上面一次完整的渲染流程。如果一个物体在多个逐像素光源的影响区域内，那么该物体就需要执行多个 Pass，每个 Pass 计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。假设，场景中有 N 个物体，每个物体受 M 个光源的影响，那么需要渲染整个场景一共需要 N * M 个 Pass。可以看出，如果有大量逐像素光照，那么需要执行的 Pass 数目也会很大。因此，渲染引擎通常会限制每个物体的逐像素光照的数目。</p><h6 id="2-Unity-中的前向渲染">2. Unity 中的前向渲染</h6><p>一个 Pass 不仅仅可以用来计算逐像素光照，也可以计算逐顶点等其他光照。这取决于光照计算所处流水线阶段以及计算时使用的数学模型。当我们渲染一个物体时，Unity 会计算哪些光源照亮了它以及这些光源照亮该物体的方式。</p><p>在 Unity 中，前向渲染路径有 3 种处理光照(即照亮物体)的方式：<strong>逐顶点处理、逐像素处理、球谐函数(Spherical Harmonics, SH)处理</strong>。而决定一个光源使用哪种处理模式取决于它的类型和渲染模式。光源类型指的是该光源是平行光还是其他类型的光源，而光源的渲染模式指的是该光源是否是<strong>重要的(Important)</strong>。如果一个光照的模式被设置为 Important，Unity就会把它当成一个逐像素光源来处理。我们可以在光源的 Light 组件中设置这些属性，如下图所示。</p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_1.png" alt="Light 组件" title="Light 组件"></p><p>在前向渲染中，当我们渲染一个物体时，Unity 会根据场景中各个光源的设置以及这些光源对物体的影响程度(例如，距离该物体的远近、光源强度等)对这些光源进行一个重要度排序。其中，一定数目的光源会按逐像素的方式处理，然后最多有 4 个光源按逐顶点的方式处理，剩下的光源可以按 SH 方式处理。Unity 使用的判断规则如下。</p><ul><li>场景中最亮的平行光总是按逐像素处理的。</li><li>渲染模式被设置成 Not Important 的光源，会按逐顶点或者 SH 处理。</li><li>渲染模式被设置成 Important 的光源，会按逐像素处理。</li><li>如果根据以上规则得到的逐像素光源数量小于 Quality Setting 中的逐像素光源数量(Pixel Light Count)，会有更多的光源以逐像素的方式进行渲染。</li></ul><p>光照计算都在 Pass 里进行。前向渲染有两种 Pass：Base Pass 和 Additional Pass。通常来说，这两种 Pass 进行的标签和渲染设置以及常规光照计算如下图所示。</p><p><img src="/posts_image/MoreComplexLighting/MoreComplexLighting_2.png" alt="前向渲染的两种Pass" title="前向渲染的两种Pass"></p><p>上图中有几点需要说明的地方。</p><ul><li>首先，可以发现在渲染设置中，我们除了设置了 Pass 的标签外，还使用了 #pragma multi_compile_fwdbase 这样的编译指令。只有分别为 Bass Pass 和 Additional Pass 使用 #pragma multi_compile_fwdbase 和 #pragma multi_compile_fwdadd 编译指令，我们才可以在相关的 Pass 中得到一些正确的光照变量，例如光照衰减值等。</li><li>Bass Pass 旁边的注释给出了 Base Pass 中支持的一些光照特性。例如在 Base Pass 中，我们可以访问光照纹理(lightmap)。</li><li>Bass Pass 中渲染的平行光默认是支持阴影的(如果开启了光源的阴影功能)，而 Additional Pass 中渲染的光源在默认情况下是没有阴影效果的，即便我们在它的 Light 组件中设置了有阴影的 <strong>Shadow Type</strong>。但我们可以在 Additional Pass 中使用 #pragma multi_compile_fwdadd_fullshadows 代替 #pragma multi_compile_fwdadd 编译指令，为点光源和聚光灯开启阴影效果，但这需要 Unity 在内部使用更多的 Shader 变种。</li><li>环境光和自发光也是在 Base Pass 中计算的。这是因为，对于一个物体来说，环境光和自发光我们只希望计算一次即可，而如果我们在 Additional Pass 中计算这两种光照，就会造成叠加多次环境光和自发光，这不是我们想要的。</li><li>在 Additional Pass 的渲染设置中，我们还开启和设置了混合模式。这是因为，我们希望每个 Additional Pass 可以与上一次的光照结果在帧缓存中进行叠加，从而得到最终的有多个光照的渲染效果。如果我们没有开启和设置混合模式，那么 Additional Pass 的渲染结果会覆盖掉之前的渲染结果，看起来就好像该物体只受该光源的影响。通常情况下，我们选择的混合模式是 <strong>Blend One One</strong>。</li><li>对于前向渲染来说，一个 Unity Shader 通常会定义一个 Base Pass (Base Pass 也可以定义多次，例如需要双面渲染等情况)以及一个 Additional Pass。一个 Bass Pass 仅会执行一次(定义了多个 Bass Pass 的情况除外)，而一个 Additional Pass 会根据影响该物体的其他逐像素光源的数目被多次调用，即每个逐像素光源会执行一次 Additional Pass。</li></ul><p>上图给出的光照计算是<strong>通常情况</strong>下我们在每种 Pass 中进行的计算。实际上，渲染路径的设置用于告诉 Unity 该 Pass 在前向渲染路径中的位置，然后底层的渲染引擎会进行相关计算并填充一些内置变量(如 _LightColor0 等)，如何使用这些内置变量进行计算完全取决于开发者的选择。例如，我们完全可以利用 Unity 提供的内置变量在 Base Pass 中只进行逐顶点的光照；同样，我们也完全可以在 Additional Pass 中按逐顶点的方式进行光照计算，不进行任何逐像素光照计算。</p><h6 id="3-内置的光照变量和函数">3. 内置的光照变量和函数</h6><p>对于前向渲染(即 <strong>LightMode</strong> 为 <strong>ForwardBase</strong> 或 <strong>ForwardAdd</strong>)来说，下表给出了我们可以在 Shader 中访问到的光照变量。</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">_LightColor0</td><td style="text-align:left">float4</td><td style="text-align:left">该 Pass 处理的逐像素光源的颜色</td></tr><tr><td style="text-align:left">_WorldSpaceLightPos0</td><td style="text-align:left">float4</td><td style="text-align:left">_WorldSpaceLightPos0.xyz 是该 Pass 处理的逐像素光源的位置。如果该光源是平行光，那么 _WorldSpaceLightPos0.w 是 0，其他光源类型 w 值为 1</td></tr><tr><td style="text-align:left">_LightMatrix0</td><td style="text-align:left">float4x4</td><td style="text-align:left">从世界空间到光源空间的变换矩阵。可以用于采样 cookie 和光强衰减(attenuation)纹理</td></tr><tr><td style="text-align:left">unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0</td><td style="text-align:left">float4</td><td style="text-align:left">仅用于 Bass Pass。前 4 个非重要的点光源在世界空间中的位置</td></tr><tr><td style="text-align:left">unity_4LightAtten0</td><td style="text-align:left">float4</td><td style="text-align:left">仅用于 Bass Pass。存储了前 4 个非重要的点光源的衰减因子</td></tr><tr><td style="text-align:left">unity_LightColor</td><td style="text-align:left">half4[4]</td><td style="text-align:left">仅用于 Bass Pass。存储了前 4 个非重要的点光源的颜色</td></tr></tbody></table><p>下表列出了前向渲染中可以使用的内置光照函数。</p><table><thead><tr><th style="text-align:left">函数名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">float3 WorldSpaceLightDir(float4 v)</td><td style="text-align:left"><strong>仅可用于前向渲染中</strong>。输入一个模型空间中的顶点位置，返回世界空间中从该点到光源的光照方向。内部实现使用了 UnityWorldSpaceLightDir 函数。没有被归一化</td></tr><tr><td style="text-align:left">float3 UnityWorldSpaceLightDir(float4 v)</td><td style="text-align:left"><strong>仅可用于前向渲染中</strong>。输入一个世界空间中的顶点位置，返回世界空间中从该点到光源的光照方向。没有被归一化</td></tr><tr><td style="text-align:left">float3 ObjSpaceLightDir(float4 v)</td><td style="text-align:left"><strong>仅可用于前向渲染中</strong>。输入一个模型空间中的顶点位置，返回模型空间中从该点到光源的光照方向。没有被归一化</td></tr><tr><td style="text-align:left">float3 Shade4PointLights(…)</td><td style="text-align:left"><strong>仅可用于前向渲染中</strong>。计算四个点光源的光照，它的参数是已经打包进矢量的光照数据，通常就是上表中的内置变量，如 unity_4LightPosX0，unity_4LightPosY0，unity_4LightPosZ0，unity_LightColor 和 unity_4LightAtten0 等。前向渲染通常会使用这个函数来计算逐顶点光照</td></tr></tbody></table><p>需要说明的是，上面给出的变量和函数并不是完整的，一些前向渲染可以使用的内置变量和函数官方文档中并没有给出说明。</p><h4 id="顶点照明渲染路径">顶点照明渲染路径</h4><p>顶点照明渲染路径是对硬件配置要求最少、运算性能最高，但同时也是得到的效果最差的一种类型，它不支持那些逐像素才能得到的效果，例如阴影、法线映射、高精度的高光反射等。实际上，它仅仅是前向渲染路径的一个子集，也就是说，所有可以在顶点照明渲染路径中实现的功能都可以在前向渲染路径的一个子集，也就是说，所有可以在顶点照明渲染路径中实现的功能都可以在前向渲染路径中完成。就如它的名字一样，顶点照明渲染路径只是使用了逐顶点的方式来计算光照，并没有什么神奇的地方。实际上，我们在上面的前向渲染路径中也可以计算一些逐顶点的光源。但如果选择使用顶点照明渲染路径，那么 Unity 会只填充那些逐顶点相关的光源变量，意味着我们不可以使用一些逐像素光照变量。</p><h6 id="1-Unity-中的顶点照明渲染">1. Unity 中的顶点照明渲染</h6><p>顶点照明渲染路径通常在一个 Pass 中就可以完成对物体的渲染。在这个 Pass 中，我们会计算我们关心的所有光源对该物体的照明，并且这个计算是按逐顶点处理的。这是 Unity 中最快速的渲染路径，并且具有最广泛的硬件支持(但是游戏机上并不支持这种路径)。由于顶点照明渲染路径仅仅是前向渲染路径的一个子集，因此顶点照明渲染路径成为了一个遗留的渲染路径，在未来的版本中，顶点照明渲染路径的相关设定可能会被移除。</p><h6 id="2-可访问的内置变量和函数">2. 可访问的内置变量和函数</h6><p>在 Unity 中，我们可以在一个顶点照明的 Pass 中最多访问到 8 个逐顶点光源。如果我们只需要渲染其中两个光源对物体的照明，可以仅使用下表中内置光照数据的前两个。如果影响该物体的光源数目小于 8，那么数组中剩下的光源颜色会设置成黑色。</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">unity_LightColor</td><td style="text-align:left">half4[8]</td><td style="text-align:left">光源颜色</td></tr><tr><td style="text-align:left">unity_LightPosition</td><td style="text-align:left">float4[8]</td><td style="text-align:left">xyz 分量是视角空间中的光源位置。如果光源是平行光，那么 z 分量值为 0，其他光源类型 z 分量值为 1</td></tr><tr><td style="text-align:left">unity_LightAtten</td><td style="text-align:left">half4[8]</td><td style="text-align:left">光源衰减因子。如果光源是聚光灯，x 分量是 cos(spotAngle/2)，y 分量是 1/cos(spotAngle/4);如果是其他类型的光源，x 分量是 -1，y 分量是 1。z 分量是衰减的平方，w 分量是光源范围开根号的结果</td></tr><tr><td style="text-align:left">unity_SpotDirection</td><td style="text-align:left">float4[8]</td><td style="text-align:left">如果光源是聚光灯的话，值为视角空间的聚光灯的位置；如果是其他类型的光源，值为(0, 0, 1, 0)</td></tr></tbody></table><p>可以看出，一些变量我们同样可以在前向渲染路径中使用，例如 unity_LightColor。但这些变量数组的维度和数值在不同渲染路径中的值是不同的。下表给出了顶点照明渲染路径中可以使用的内置函数。</p><table><thead><tr><th style="text-align:left">函数名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">float3 ShadeVertexLights(float4 vertex, float3 normal)</td><td style="text-align:left">输入模型空间中的顶点位置和法线，计算四个逐顶点光源的光照以及环境光。内部实现实际上调用了 ShadeVertexLightsFull 函数</td></tr><tr><td style="text-align:left">float3 ShadeVertexLightsFull(float4 vertex,float3 normal,int lightCount,bool spotLight)</td><td style="text-align:left">输入模型空间中的顶点位置和法线，计算 lightCount 个光源的光照以及环境光。如果 spotLight 值为 true，那么这些光源会被当成聚光灯来处理，虽然结果更精确，但计算更加耗时；否则，按点光源处理</td></tr></tbody></table><h4 id="延迟渲染路径">延迟渲染路径</h4><p>前向渲染的问题是：当场景中包含大量实时光源时，前向渲染的性能会急速下降。例如，如果我们在场景的某一块区域放置了多个光源，这些光源影响的区域互相重叠，那么为了得到最终光照效果，我们就需要为该区域内的每个物体执行多个 Pass 来计算不同光源对该物体的光照结果，然后在颜色缓存中把这些结果混合起来得到最终的光照。然而，每执行一个 Pass 我们都需要重新渲染一遍物体，但实际上很多计算是重复的。</p><p>延迟渲染是一种更古老的渲染方法，但是由于上述前向渲染可能造成的瓶颈问题，近几年又流行起来。除了前向渲染中使用的颜色缓冲和深度缓冲外，延迟渲染还会利用额外的缓冲区，这些缓冲区也被统称为 G 缓冲(G-buffer)，其中 G 是英文 Geometry 的缩写。G 缓冲区存储了我们所关心的表面(通常指的是离摄像机最近的表面)的其他信息，例如该表面的法线、位置、用于光照计算的材质属性等。</p><h6 id="1-延迟渲染的原理">1. 延迟渲染的原理</h6><p>延迟渲染主要包含了两个 Pass。在第一个 Pass 中，我们不进行任何光照计算，而是仅仅计算哪些片元是可见的，这主要是通过深度缓冲技术来实现，当发现一个片元是可见的，我们就把它的相关信息存储到 G 缓冲区中。然后，在第二个 Pass 中，我们利用 G 缓冲区的各个片元信息，例如表面法线、视角方向、漫反射系数等，进行真正的光照计算。</p><p>延迟渲染的过程大致可以用下面的伪代码来描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Pass 1 &#123;<br>    //第一个 Pass 不进行真正的光照计算，仅仅把光照计算需要的信息存储到 G 缓冲中<br>    for (each primitive in this model) &#123;<br>        for (each fragment covered by this primitive) &#123;<br>            if (failed in depth test) &#123;<br>                //如果没有通过深度测试，说明该片元是不可见的<br>                discard;<br>            &#125; else &#123;<br>                //如果该片元可见，就把需要的信息存储到 G 缓冲中<br>                writeGBuffer(materialInfo, pos, normal, lightDir, viewDir);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>Pass 2 &#123;<br>    //利用 G 缓冲中的信息进行真正的光照计算<br>    for (each pixel in the screen) &#123;<br>        if (the pixel is valid) &#123;<br>            //如果该像素是有效的，读取它对应的 G 缓冲中的信息<br>            readGBuffer(pixel, materialInfo, pos, normal, lightDir, viewDir);<br>            //根据读取到的信息进行光照计算<br>            float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);<br>            //更新帧缓冲<br>            writeFrameBuffer(pixel, color);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，延迟渲染使用的 Pass 数目通常就是两个，这跟场景中包含的光源数目是没有关系的。换句话说，延迟渲染的效率不依赖于场景的复杂度，而是和我们使用的屏幕空间的大小有关。这是因为，我们需要的信息都存储在缓冲区中，而这些缓冲区可以理解成是一张张 2D 图像，我们的计算实际上就是在这些图像空间中进行的。</p><h6 id="2-Unity-中的延迟渲染">2. Unity 中的延迟渲染</h6><p>对于延迟渲染路径来说，它最适合在场景中光源数目很多、如果使用前向渲染会造成性能瓶颈的情况下使用。而且，延迟渲染路径中的每个光源都可以按逐像素的方式处理。但是，延迟渲染也有一些缺点</p><ul><li>不支持真正的抗锯齿(anti-aliasing)功能。</li><li>不能处理半透明物体。</li><li>对显卡有一定要求。如果要使用延迟渲染的话，显卡必须支持 MRT(Multiple Render Targets)、Shader Mode 3.0 及以上、深度渲染纹理以及双面的模板缓冲。</li></ul><p>当使用延迟渲染时，Unity 要求我们提供两个 Pass。</p><p>(1) 第一个 Pass 用于渲染 G 缓冲。在这个 Pass 中，我们会把物体的漫反射颜色、高光反射颜色、平滑度、法线、自发光和深度等信息渲染到屏幕空间的 G 缓冲区中。对于每个物体来说，这个 Pass 仅会执行一次。</p><p>(2) 第二个 Pass 用于计算真正的光照模型。这个 Pass 会使用上一个 Pass 中渲染的数据来计算最终的光照颜色，再存储到帧缓冲中。</p><p>默认的 G 缓冲区(注意，不同 Unity 版本的渲染纹理存储内容会有所不同)包含了以下几个渲染纹理(Render Texture，RT)。</p><ul><li>RT0：格式是 ARGB32，RGB 通道用于存储漫反射颜色，A 通道没有被使用。</li><li>RT1：格式是 ARGB32，RGB 通道用于存储高光反射颜色，A 通道用于存储高光反射的指数部分。</li><li>RT2：格式是 ARGB2101010，RGB通道用于存储法线，A 通道没有被使用。</li><li>RT3，格式是 ARGB32(非 HDR) 或 ARGBHalf(HDR)，用于存储自发光 + lightmap + 反射探针(reflection probes)。</li><li>深度缓冲和模板缓冲。</li></ul><p>当在第二个 Pass 中计算光照时，默认情况下仅可以使用 Unity 内置的 Standard 光照模型。如果我们想要使用其他的光照模型，就需要替换掉原有的 Internal-DeferredShading.shader 文件。</p><h6 id="3-可访问的内置变量和函数">3. 可访问的内置变量和函数</h6><p>下表给出了处理延迟渲染路径可以使用的光照变量。这些变量都可以在 UnityDeferredLibrary.cginc 文件中找到它们的声明。</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">_LightColor</td><td style="text-align:left">float4</td><td style="text-align:left">光源颜色</td></tr><tr><td style="text-align:left">_LightMatrix0</td><td style="text-align:left">float4x4</td><td style="text-align:left">从世界空间到光源空间的变换矩阵。可以用于采样 cookie 和光强衰减纹理</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Light</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>透明效果(二)</title>
    <link href="/posts/%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C(%E4%BA%8C)/"/>
    <url>/posts/%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h2 id="开启深度写入的半透明效果">开启深度写入的半透明效果</h2><p>在上一篇中，我们给出了一种由于关闭深度写入而造成排序错误的情况。一种解决办法是<strong>使用两个 Pass</strong> 来渲染模型：第一个 Pass 开启深度写入，但不输出颜色，它的目的仅仅是为了把该模型的深度值写入到深度缓冲中；第二个 Pass 进行正常的透明度混合，由于上一个 Pass 已经得到了逐像素的正确的深度信息，该 Pass 就可以按照像素级别的深度排序结果进行透明渲染。但这个方法的缺点在于，多使用一个 Pass 会对性能造成一定的影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter8/Chapter8-AlphaBlendZWrite&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Main Tint&quot;, Color) = (1,1,1,1)<br>        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _AlphaScale (&quot;Alpha Scale&quot;, Range(0, 1)) = 1<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProhector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &#125;<br><br>        Pass &#123;<br>            ZWrite On<br>            ColorMask 0<br>        &#125;<br>        <br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br>            ZWrite Off<br>            Blend SrcAlpha OneMinusSrcAlpha<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br><br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            fixed _AlphaScale;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v)&#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target&#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed4 texColor = tex2D(_MainTex, i.uv);<br>                fixed3 albedo = texColor.rgb * _Color.rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br>                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));<br>                return fixed4(ambient + diffuse, texColor.a * _AlphaScale);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Transparent/VertexLit&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个新添加的 Pass 的目的仅仅是为了把模型的深度信息写入深度缓冲中，从而剔除模型中被自身遮挡的片元。因此，Pass 的第一行开启了深度写入。在第二行，我们使用了一个新的渲染命令——<strong>ColorMask</strong>。在 ShaderLab 中，ColorMask 用于设置颜色通道的写掩码(write mask)。它的语义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">ColorMask RGB | A | 0 | 其他任何 R、G、B、A 的组合<br></code></pre></td></tr></table></figure><p>当 ColorMask 设为 0 时，意味着该 Pass 不写入任何颜色通道，即不会输出任何颜色。这正是我们需要的——该 Pass 只需写入深度缓存即可。</p><p>效果如下图所示：</p><p><img src="/posts_image/Transparent/Transparent_10.png" alt="开启深度写入的半透明效果" title="开启深度写入的半透明效果"></p><p>可以看出，使用这种方法，我们仍然可以实现模型与它后面的背景混合的效果，但模型内部之间不会有任何真正的半透明效果。</p><h2 id="ShaderLab-的混合命令">ShaderLab 的混合命令</h2><p>混合除了用于透明度混合，还有很多其他用处。下面我们将更加详细地了解混合中的细节问题。</p><p>我们首先来看一下混合是如何实现的。当片元着色器产生一个颜色的时候，可以选择与颜色缓存中的颜色进行混合。这样一来，混合就和两个操作数有关：<strong>源颜色(source color)<strong>和</strong>目标颜色(destination color)</strong>。源颜色，我们用 <strong>S</strong> 表示，指的是由片元着色器产生的颜色值；目标颜色，我们用 <strong>D</strong> 表示，指的是从颜色缓冲中读取到的颜色值。对它们进行混合后得到的输出颜色，我们用 <strong>O</strong> 表示，它会重新写入到颜色缓冲中。需要注意的是，当我们谈及混合中的源颜色、目标颜色和输出颜色时，它们都包含了 RGBA 四个通道的值，而并非仅仅是 RGB 通道。</p><p>想要使用混合，我们必须首先开启它。在 Unity 中，当我们使用 Blend(Blend Off 命令除外) 命令时，除了设置混合状态外也开启了混合。但是，在其他图形 API 中我们是需要手动开启的。例如在 OpenGL 中，我们需要使用 glEnable(GL_BLEND) 来开启混合。但在 Unity 中，它已经在背后为我们做了这些工作。</p><h4 id="混合等式和参数">混合等式和参数</h4><p>混合是一个逐片元的操作，而且它不是可编程的，但却是高度可配置的。也就是说，我们可以设置混合时使用的运算操作、混合因子等来影响混合。那么，这些配置又是如何实现的呢？</p><p>现在，我们已知两个操作数：源颜色 S 和目标颜色 D，想要得到输出颜色 O 就必须使用一个等式来计算。我们把这个等式称为<strong>混合等式(blend equation)</strong>。当进行混合时，我们需要使用两个混合等式：一个用于混合 RGB 通道，一个用于混合 A 通道。当设置混合状态时，我们实际上设置的就是混合等式中的<strong>操作</strong>和<strong>因子</strong>。在默认情况下，混合等式使用的操作都是加操作(我们也可以使用其他操作)，我们只需要再设置一下混合因子即可。由于需要两个等式(分别用于混合 RGB 通道和 A 通道)，每个等式有两个因子(一个用于和源颜色相乘，一个用于和目标颜色相乘)，因此一共需要 4 个因子。下表给出了 ShaderLab 中设置混合因子的命令。</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Blend SrcFactor DstFactor</td><td style="text-align:left">开启混合，并设置混合因子。源颜色(该片元产生的颜色)会乘以 SrcFactor，而目标颜色(已经存在于颜色缓存的颜色)会乘以 DstFactor，然后把两者相加后在存入颜色缓冲中</td></tr><tr><td style="text-align:left">Blend SrcFactor DstFactor, SrcFactorA DstFactorA</td><td style="text-align:left">和上面几乎一样，只是使用不同的因子来混合透明通道</td></tr></tbody></table><p>可以发现，第一个命令只提供了两个因子，这意味着将使用同样的混合因子来混合 RGB 通道和 A 通道，即此时 SrcFactorA 将等于 SrcFactor，DstFactorA 将等于 DstFactor。下面就是使用这些因子进行加法混合时使用的混合公式：</p><p>$$<br>O_{rgb} = SrcFactor \times S_{rgb} + DstFactor \times D_{rgb}<br>$$<br>$$<br>O_a = SrcFactorA \times S_a + DstFactorA \times D_a<br>$$</p><p>那么，这些混合因子可以有哪些值呢？下表给出了 ShaderLab 支持的几种混合因子。</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">One</td><td style="text-align:left">因子为 1</td></tr><tr><td style="text-align:left">Zero</td><td style="text-align:left">因子为 0</td></tr><tr><td style="text-align:left">SrcColor</td><td style="text-align:left">因子为源颜色值，当用于混合 RGB 的混合等式时，使用 SrcColor 的 RGB 分量作为混合因子；当用于混合 A 的混合等式时，使用 SrcColor 的 A 分量作为混合因子</td></tr><tr><td style="text-align:left">SrcAlpha</td><td style="text-align:left">因子为源颜色的透明度值(A 通道)</td></tr><tr><td style="text-align:left">DstColor</td><td style="text-align:left">因子为目标颜色值。当用于混合 RGB 通道的混合等式时，使用 DstColor 的 RGB 分量作为混合因子；当用于混合 A 通道的混合等式时，使用 DstColor 的 A 分量作为混合因子</td></tr><tr><td style="text-align:left">DstAlpha</td><td style="text-align:left">因子为目标颜色的透明度值(A 通道)</td></tr><tr><td style="text-align:left">OneMinusSrcColor</td><td style="text-align:left">因子为(1-源颜色)。当用于混合 RGB 的混合等式时，使用结果的 RGB 分量作为混合因子；当用于混合 A 的混合等式时，使用结果的 A 分量作为混合因子</td></tr><tr><td style="text-align:left">OneMinusSrcAlpha</td><td style="text-align:left">因子为(1-源颜色的透明度值)</td></tr><tr><td style="text-align:left">OneMinusDstColor</td><td style="text-align:left">因子为(1-目标颜色)。当用于混合 RGB 的混合等式时，使用结果的 RGB 分量作为混合因子；当用于混合 A 的混合等式时，使用结果的 A 分量作为混合因子</td></tr><tr><td style="text-align:left">OneMinusDstAlpha</td><td style="text-align:left">因子为(1-目标颜色的透明度值)</td></tr></tbody></table><p>使用上面的指令进行设置时，RGB 通道的混合因子和 A 通道的混合因子都是一样的，有时我们希望可以使用不同的参数混合 A 通道，这时就可以利用 <strong>Blend SrcFactor DstFactor, SrcFactorA DstFactorA</strong> 指令。例如，如果我们想要在混合后，输出颜色的透明度值就是源颜色的透明度，可以使用下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Blend SrcAlpha OneMinusSrcAlpha, One Zero<br></code></pre></td></tr></table></figure><h4 id="混合操作">混合操作</h4><p>在上面涉及的混合等式中，当把源颜色和目标颜色与它们对应的混合因子相乘后，我们都是把它们的结果加起来作为输出颜色的。那么可不可以选择不用加法，而使用减法呢？答案是肯定的，我们可以使用 ShaderLab 的 <strong>BlendOp BlendOperation</strong> 命令，即混合操作命令。下表给出了 ShaderLab 中支持的混合操作。</p><table><thead><tr><th style="text-align:left">操作</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Add</td><td style="text-align:left">将混合后的源颜色和目的颜色相加。默认的混合操作使用的混合等式是：<br>$O_{rgb} = SrcFactor \times S_{rgb} + DstFactor \times D_{rgb}$<br>$O_a = SrcFactorA \times S_a + DstFactorA \times D_a$</td></tr><tr><td style="text-align:left">Sub</td><td style="text-align:left">用混合后的源颜色减去混合后的目的颜色。使用的混合等式是： <br>$O_{rgb} = SrcFactor \times S_{rgb} - DstFactor \times D_{rgb}$<br>$O_a = SrcFactorA \times S_a - DstFactorA \times D_a$</td></tr><tr><td style="text-align:left">RevSub</td><td style="text-align:left">用混合后的目的颜色减去混合后的源颜色。使用的混合等式是： <br>$O_{rgb} = DstFactor \times D_{rgb} - SrcFactor \times S_{rgb}$<br>$O_a = DstFactorA \times D_a - SrcFactorA \times S_a$</td></tr><tr><td style="text-align:left">Min</td><td style="text-align:left">使用源颜色和目的颜色中较小的值，是逐分量比较的。使用的混合等式是：<br>$O_{rgba} = (min(S_r, D_r), min(S_g, D_g), min(S_b, D_b), min(S_a, D_a))$</td></tr><tr><td style="text-align:left">Max</td><td style="text-align:left">使用源颜色和目的颜色中较大的值，是逐分量比较的。使用的混合等式是：<br>$O_{rgba} = (max(S_r, D_r), max(S_g, D_g), max(S_b, D_b), max(S_a, D_a))$</td></tr><tr><td style="text-align:left">其他逻辑操作</td><td style="text-align:left">仅在 DirectX 11.1 中支持</td></tr></tbody></table><p>混合操作命令通常是与混合因子命令一起工作的。但需要注意的是，当使用 <strong>Min</strong> 或 <strong>Max</strong> 混合操作时，混合因子实际上是不起任何作用的，它们仅会判断原始的源颜色和目的颜色之间的比较结果。</p><h4 id="常见的混合类型">常见的混合类型</h4><p>通过混合操作和混合因子命令的组合，我们可以得到一些类似 Photoshop 混合模式中的混合效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">//正常(Normal)，即透明度混合<br>Blend SrcAlpha OneMinusSrcAlpha<br><br>//柔和相加(Soft Additive)<br>Blend OneMinusDstColor One<br><br>//正片叠底(Multiply)，即相乘<br>Blend DstColor Zero<br><br>//两倍相乘(2x Multiply)<br>Blend DstColor SrcColor<br><br>//变暗(Darken)<br>BlendOp Min<br>Blend One One<br><br>//变亮(Lighten)<br>BlendOp Max<br>Blend One One<br><br>//滤色(Screen)<br>Blend OneMinusDstColor One<br>//等同于<br>Blend One OneMinusSrcColor<br><br>//线性减淡(Linear Dodge)<br>Blend One One<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/posts_image/Transparent/Transparent_11.png" alt="常见的混合类型" title="常见的混合类型"></p><p>需要注意的是，虽然上面使用 Min 和 Max 混合操作时仍然设置了混合因子，但实际上它们并不会对结果有任何影响，因为 Min 和 Max 混合操作会忽略混合因子。另一点是，虽然上面有些混合模式并没有设置混合操作的种类，但是他们默认就是使用加法操作，相当于设置了 BlendOp Add。</p><h2 id="双面渲染的透明效果">双面渲染的透明效果</h2><p>在现实生活中，如果一个物体是透明的，意味着我们不仅可以透过它看到其他物体的样子，也可以看到它内部的结构。但在前面实现的透明效果中，无论是透明度测试还是透明度混合，我们都无法观察到正方体内部及其背面的形状，导致物体看起来就好像只有半个一样。这是因为，默认情况下渲染引擎剔除了物体背面(相对于摄像机的方向)的渲染图元，而只渲染了物体的正面。如果我们想要得到双面渲染的效果，可以使用 <strong>Cull</strong> 指令来控制需要剔除哪个面的渲染图元。在 Unity 中，Cull 指令的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Cull Back | Front | Off<br></code></pre></td></tr></table></figure><p>如果设置为 Back，那么那些背对着摄像机的渲染图元就不会被渲染，这也是默认情况下的剔除状态；如果设置为 Front，那么那些朝向摄像机的渲染图元就不会被渲染：如果设置为 Off，就会关闭剔除功能，那么所有的渲染图元都会被渲染，但由于这时需要渲染的图元数目会成倍增加，因此除非是用于特殊效果，例如这里的双面渲染的透明效果，通常情况下是不会关闭剔除功能的。</p><h4 id="透明度测试的双面渲染">透明度测试的双面渲染</h4><p>实现透明度测试物体的双面渲染效果非常简单，只需要在 Pass 的渲染设置中使用 Cull 指令来关闭剔除即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Pass &#123;<br>    Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;<br><br>    //Turn off culling<br>    Cull Off<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，这行代码的作用是关闭剔除功能，使得该物体的所有的渲染图元都会被渲染，此时，我们可以透过正方体的镂空区域看到内部的渲染结果。效果如下图所示：</p><p><img src="/posts_image/Transparent/Transparent_12.png" alt="透明度测试的双面渲染" title="透明度测试的双面渲染"></p><h4 id="透明度混合的双面渲染">透明度混合的双面渲染</h4><p>和透明度测试相比，想要让透明度混合实现双面渲染会更复杂一些，这是因为透明度混合需要关闭深度写入，而这是“一切混乱的开端”。我们知道，想要得到正确的透明效果，渲染顺序是非常重要的——我们想要保证图元是从后往前渲染的。对于透明度测试来说，由于我们没有关闭深度写入，因此可以利用深度缓冲按逐像素的粒度进行深度排序，从而保证渲染的正确性。然而一旦关闭了深度写入，我们就需要小心地控制渲染顺序来得到正确的深度关系。如果我们仍然只是直接关闭剔除功能，那么我们就无法保证同一个物体的正面和背面图元的渲染顺序，就有可能得到错误的半透明效果。</p><p>为此，我们选择把双面渲染的工作分成两个 Pass——第一个 Pass 只渲染背面，第二个 Pass 只渲染正面，由于 Unity 会顺序执行 SubShader 中的各个 Pass，因此我们可以保证背面总是在正面渲染之前渲染，从而可以保证正确的深度渲染关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter8/Chapter8-AlphaBlendBothSided&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Main Tint&quot;, Color) = (1,1,1,1)<br>        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _AlphaScale (&quot;Alpha Scale&quot;, Range(0, 1)) = 1<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProhector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &#125;<br>        <br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br>            Cull Front<br>            ZWrite Off<br>            Blend SrcAlpha OneMinusSrcAlpha<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br><br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            fixed _AlphaScale;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v)&#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target&#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed4 texColor = tex2D(_MainTex, i.uv);<br>                fixed3 albedo = texColor.rgb * _Color.rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br>                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));<br>                return fixed4(ambient + diffuse, texColor.a * _AlphaScale);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br><br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br>            Cull Back<br>            ZWrite Off<br>            Blend SrcAlpha OneMinusSrcAlpha<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br><br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            fixed _AlphaScale;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v)&#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target&#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed4 texColor = tex2D(_MainTex, i.uv);<br>                fixed3 albedo = texColor.rgb * _Color.rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br>                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));<br>                return fixed4(ambient + diffuse, texColor.a * _AlphaScale);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Transparent/VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过上面的代码，我们可以得到下图中的效果：</p><p><img src="/posts_image/Transparent/Transparent_13.png" alt="透明度混合的双面渲染" title="透明度混合的双面渲染"></p><h2 id="参考">参考</h2><p>《Unity Shader入门精要》</p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alpha</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>透明效果(一)</title>
    <link href="/posts/%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C(%E4%B8%80)/"/>
    <url>/posts/%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h2 id="透明效果">透明效果</h2><p>在实时渲染中要实现透明效果，通常会在渲染模型时控制它的<strong>透明通道(Alpha Channel)</strong>。当开启透明混合后，当一个物体被渲染到屏幕上时，每个片元除了颜色值和深度值之外，它还有另一个属性——透明度。当透明度为 1 时，表示该像素是完全不透明的，而当其为 0 时，则表示该像素完全不会显示。</p><p>在 Unity 中，我们通常使用两种方法来实现透明效果：第一种是使用<strong>透明度测试(Alpha Test)</strong>，这种方法其实无法得到真正的半透明效果；另一种是<strong>透明度混合(Alpha Blending)</strong>。</p><p>对于不透明(opaque)物体，不考虑它们的渲染顺序也能得到正确的排序效果，这是由于强大的深度缓冲(depth buffer，也被称为 z-buffer)的存在。在实时渲染中，深度缓冲是用于解决可见性(visibility)问题的，它可以决定哪个物体的哪些部分会被渲染在前面，而哪些部分会被其他物体遮挡。它的基本思想是：根据深度缓存中的值来判断该片元距离摄像机的距离，当渲染一个片元时，需要把它的深度值和已经存在于深度缓冲中的值进行比较(如果开启了深度测试)，如果它的值距离摄像机更远，那么说明这个片元不应该被渲染到屏幕上(有物体挡住了它)；否则，这个片元应该覆盖掉此时颜色缓冲中的像素值，并把它的深度值更新到深度缓冲中(如果开启了深度写入)。</p><p>使用深度缓冲，可以让我们不用关心不透明物体的渲染顺序，例如 A 挡住 B，即便我们先渲染 A 再渲染 B，也不用担心 B 会遮盖掉 A，因为在进行深度测试时会判断出 B 距离摄像机更远，也就不会写入到颜色缓冲中。但如果想要实现透明效果，事情就不那么简单了，这是因为，当使用透明度混合时，我们关闭了深度写入(ZWrite)。</p><p>简单来说，透明度测试和透明度混合的基本原理如下。</p><ul><li><p><strong>透明度测试</strong>：它采用一种“霸道极端”的机制，只要一个片元的透明度不满足条件(通常是小于某个阈值)，那么它对应的片元就会被舍弃。被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲产生任何影响；否则，就会按照普通的不透明物体的处理方式来处理它，即进行深度测试、深度写入等。也就是说，透明度测试是不需要关闭深度写入的，它和其他不透明物体最大的不同就是它会根据透明度来舍弃一些片元。虽然简单，但是它产生的效果也很极端，要么完全透明，即看不到，要么完全不透明，就像不透明物体那样。</p></li><li><p><strong>透明度混合</strong>：这种方法可以得到真正的半透明效果。它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。但是，透明度混合需要关闭深度写入，这使得我们要非常小心物体的渲染顺序。需要注意的是，透明度混合只关闭了深度写入，但没有关闭深度测试。这意味着，当使用透明度混合渲染一个片元时，还是会比较它的深度值与当前深度缓冲中的深度值，如果它的深度值距离摄像机更远，那么就不会再进行混合操作。这一点决定了，当一个不透明物体出现在一个透明物体的前面，而我们先渲染了不透明物体，它仍然可以正常地遮挡住透明物体。也就是说，对于透明度混合来说，深度缓冲是只读的。</p></li></ul><h2 id="为什么渲染顺序很重要">为什么渲染顺序很重要</h2><p>使用透明度混合技术时，为什么要关闭深度写入呢？如果不关闭深度写入，一个半透明表面背后的表面本来是可以透过它被我们看到的，但由于深度测试时判断结果是该半透明表面距离摄像机更近，导致后面的表面将会被剔除，我们也就无法透过半透明表面看到后面的物体了。但是，我们由此就破坏了深度缓冲的工作机制，而这是一个<strong>非常非常非常</strong>糟糕的事情，尽管我们不得不这样做。关闭深度写入导致渲染顺序将变得非常重要。</p><p>我们来考虑最简单的情况。假设场景里有两个物体 A 和 B，如下图所示，其中 A 是半透明物体，而 B 是不透明物体。</p><p><img src="/posts_image/Transparent/Transparent_1.png" alt="A半透明，B不透明" title="A半透明，B不透明"></p><p>我们来考虑不同的渲染顺序会有什么结果。</p><ul><li><p>第一种情况，我们先渲染 B，再渲染 A。那么由于不透明物体开启了深度测试和深度检验，而此时深度缓冲中没有任何有效数据，因此 B 首先会写入颜色缓冲和深度缓冲。随后我们渲染 A，透明物体仍然会进行深度测试，因此我们发现和 B 相比，A 距离摄像机更近，因此，我们会使用 A 的透明度来和颜色缓冲中的 B 颜色进行混合，得到正确的半透明效果。</p></li><li><p>第二种情况，我们先渲染 A，再渲染 B。渲染 A 时，深度缓冲区中没有任何有效数据，因此 A 直接写入颜色缓冲，但由于对半透明物体关闭了深度写入，因此 A 不会修改深度缓冲。等到渲染 B 时，B 会进行深度测试，它发现深度缓存中还没有数据，那么它就写入颜色缓冲了，结果就是 B 会直接覆盖 A 的颜色。从视觉上来看，B 就出现在了 A 的前面，而这是错误的。</p></li></ul><p>从这个例子可以看出，当关闭了深度写入后，渲染顺序多么重要。由此我们知道，我们应该在不透明物体渲染完之后再渲染半透明物体。如果都是半透明物体，渲染顺序依然重要。还是假设场景里有两个物体 A 和 B，如下图所示，其中 A 和 B 都是半透明物体。</p><p><img src="/posts_image/Transparent/Transparent_2.png" alt="A、B都是半透明" title="A、B都是半透明"></p><p>我们还是考虑不同的渲染顺序有什么不同结果。</p><ul><li><p>第一种情况，我们先渲染 B，再渲染 A。那么 B 会正常写入颜色缓冲，然后 A 会和颜色缓冲中的 B 颜色进行混合，得到正确的半透明效果。</p></li><li><p>第二种情况，我们先渲染 A，再渲染 B。那么 A 会先写入颜色缓冲，随后 B 会和颜色缓冲中的 A 进行混合，这样混合结果会完全反过来，看起来就好像 B 在 A 的前面，得到的就是错误的半透明结构。</p></li></ul><p>从这个例子可以看出，半透明物体之间也是要符合一定的渲染顺序的。基于这两点，渲染引擎一般都会先对物体进行排序，再渲染。常用的方法是。</p><ol><li><p>先渲染所有不透明物体，并开启它们的深度测试和深度写入。</p></li><li><p>把半透明物体按他们距离摄像机的远近进行排序，然后按照从后往前的顺序渲染这些半透明物体，并开启它们的深度测试，但关闭深度写入。</p></li></ol><p>但现在问题仍然没有完全解决，在一些情况下，半透明物体的渲染还是会出现问题。这是因为第二步中的渲染顺序仍然含糊不清，若距离摄像机的远近是由距离摄像机的深度值决定的，但深度缓冲中的值都是像素级别的，每个像素都有一个深度值，如果我们现在对单个物体级别进行排序，那么这意味着排序结果是：要么物体 A 全部在 B 前面渲染，要么 A 全部在 B 后面渲染。但如果存在循环重叠的情况，那么使用这种方法就永远无法得到正确的结果。下图给出了 3 个物体循环重叠的情况。</p><p><img src="/posts_image/Transparent/Transparent_3.png" alt="三个物体循环重叠" title="三个物体循环重叠"></p><p>在上图中，由于 3 个物体互相重叠，我们不能得到一个正确的排序顺序。这种时候，我们可以选择把物体拆分为两个部分，然后在进行正确的排序。但即便我们通过分割的方法解决了循环覆盖的问题，还是会有其他情况发生，比如下图中的情况。</p><p><img src="/posts_image/Transparent/Transparent_4.png" alt="两个物体错位遮挡" title="两个物体错位遮挡"></p><p>这里的问题是：如何进行排序？我们知道，一个物体的网格结构往往占据了空间中的某一块区域，也就是说，这个网格上每一个点的深度值可能都是不一样的。我们无论选择网格中点、最远的点还是最近的点的深度值来作为整个物体的深度值和其他物体进行排序，都会得到错误的结果。我们的排序结果总是 A 在 B 的前面，但实际上 A 有一部分被 B 遮挡了。这也意味着，一旦选定了一种判断方式后，在某些情况下半透明物体之间一定会出现错误的遮挡问题。这种问题的解决方法通常也是分割网格。</p><p>尽管这样做总会出现一些意外情况，但由于上述方法足够有效且容易实现，因此大多数游戏引擎都使用了这种方法。为了减少错误排序的情况，我们可以尽可能让模型是凸面体，并且考虑将复杂模型拆分成可以独立排序的多个子模型等。其实就算排序错误结果有时也不会非常糟糕，如果不想分割网格，可以试着让透明通道更加柔和，使穿插看起来不是那么明显。我们也可以使用开启了深度写入的半透明效果来近似模拟物体的半透明。</p><p>下面我们来看一下 Unity 如何解决排序问题。</p><h2 id="Unity-Shader-的渲染顺序">Unity Shader 的渲染顺序</h2><p>Unity 为了解决渲染顺序的问题提供了**渲染队列(render queue)**这一解决方案。我们可以使用 SubShader 的 Queue 标签来决定我们的模型将归于哪个渲染队列。Unity 在内部使用一系列整数索引来表示每个渲染队列，且索引号越小表示越早被渲染。</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">队列索引号</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">Background</td><td style="text-align:center">1000</td><td style="text-align:left">这个渲染队列会在任何其他队列之前被渲染，我们通常使用该队列来渲染那些需要绘制在背景上的物体</td></tr><tr><td style="text-align:center">Geometry</td><td style="text-align:center">2000</td><td style="text-align:left">默认的渲染队列，大多数物体都使用这个队列。不透明物体使用这个队列</td></tr><tr><td style="text-align:center">AlphaTest</td><td style="text-align:center">2450</td><td style="text-align:left">需要透明度测试的物体使用这个队列。在 Unity5 中从 Geometry 队列中被单独分离出来，这是因为在所有不透明物体渲染之后再渲染它们会更加高效</td></tr><tr><td style="text-align:center">Transparent</td><td style="text-align:center">3000</td><td style="text-align:left">这个队列中的物体会在所有 Geometry 和 AlphaTest 物体渲染后，再按<strong>从后往前</strong>的顺序进行渲染。任何使用了透明度混合(例如关闭了深度写入的 Shader)的物体都应该使用该队列</td></tr><tr><td style="text-align:center">Overlay</td><td style="text-align:center">4000</td><td style="text-align:left">该队列用于实现一些叠加效果。任何需要在最后渲染的物体都应该使用该队列</td></tr></tbody></table><p>因此，如果我们想要通过透明度测试实现透明效果，代码中应该包含类似下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">SubShader &#123;<br>    Tags &#123; &quot;Queue&quot; = &quot;AlphaTest&quot; &#125;<br>    Pass &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们想要通过透明度混合来实现透明效果，代码中应该包含类似下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">SubShader &#123;<br>    Tags &#123; &quot;Queue&quot; = &quot;Transparent&quot; &#125;<br>    Pass &#123;<br>        ZWrite Off<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<strong>ZWrite Off</strong>用于关闭深度写入，在这里我们选择把它写在 Pass 中。我们也可以把它写在 SubShader 中，这意味着该 SubShader 下所有 Pass 都会关闭深度写入。</p><h2 id="透明度测试">透明度测试</h2><p><strong>透明度测试</strong>：只要一个片元的透明度不满足条件(通常是小于某个阈值)，那么它对应的片元就会被舍弃。被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲产生任何影响；否则，就会按照普通的不透明的物体的处理方式来处理它。</p><p>通常我们会在片元着色器中使用 clip 函数来进行透明度测试。clip 是 CG 中的一个函数，它的定义如下。</p><p><strong>函数</strong>：void clip(float4 x); void clip(float3 x); void clip(float2 x); void clip(float1 x); void clip(float x);</p><p><strong>参数</strong>：裁剪时使用的标量或矢量条件。</p><p><strong>描述</strong>：如果给定参数的任何一个分量是负数，就会舍弃当前像素的输出颜色。它等同于下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">void clip(float4 x)&#123;<br>    if(any(x &lt; 0))<br>        discard;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将用下面这张图来实现透明度测试。</p><p><img src="/posts_image/Transparent/Transparent_5.png" alt="透明度测试用图" title="透明度测试用图"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br><br>Shader &quot;Custom/Chapter8/Chapter8-AlphaTest&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Main Tint&quot;, Color) = (1,1,1,1)<br>        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Cutoff (&quot;Alpha Cutoff&quot;, Range(0, 1)) = 0.5<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags &#123; &quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProhector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot; &#125;<br>        <br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br><br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            fixed _Cutoff;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v)&#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target&#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed4 texColor = tex2D(_MainTex, i.uv);<br><br>                clip(texColor.a - _Cutoff);<br>                //Equal to<br>                //if((texColor.a - _Cutoff) &lt; 0.0)&#123;<br>                //  discard;<br>                //&#125;<br>                fixed3 albedo = texColor.rgb * _Color.rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br>                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));<br>                return fixed4(ambient + diffuse, 1.0);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Transparent/Cutout/VertexLit&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下图所示：</p><p><img src="/posts_image/Transparent/Transparent_6.png" alt="透明度测试效果图1" title="透明度测试效果图1"></p><p>Unity 中透明度测试使用的渲染队列是名为 AlphaTest 的队列，因此我们需要把 Queue 标签设置成 AlphaTest。而 RenderType 标签可以让 Unity 把这个 Shader 归入到提前定义的组(这里就是 TransparentCutout 组)中，以指明该 Shader 是一个使用了透明度测试的 Shader。RenderType 标签通常被用于着色器替换功能。我们还把 IgnoreProjector 设置为 True，这意味着这个 Shader 不会受到投影器(Projectors)的影响。通常，使用了透明度测试的 Shader 都应该在 SubShader 中设置这三个标签。</p><p>前面我们已经提到过 clip 函数的定义，它会判断它的参数，即 texColor.a - _Cutoff 是否为负数，如果是就会舍弃该片元的输出。也就是说，当 texColor.a 小于材质参数 _Cutoff 时，该片元就会产生完全透明的效果。使用 clip 函数等同于先判断参数是否小于零，如果是就使用 discard 指令来显示剔除该片元。材质面板中的 Alpha cutoff 参数用于调整透明度测试时使用的阈值，当纹理像素的透明度小于该值时，对应的片元就会被舍弃。当我们逐渐调大该值时，立方体上的网格会逐渐消失。如下图所示。</p><p><img src="/posts_image/Transparent/Transparent_7.png" alt="透明度测试效果图2" title="透明度测试效果图2"></p><p>和之前使用的 Diffuse 和 Specular 不同，这次我们使用内置的 Transparent/Cutout/VertexLit 来作为回调 Shader。这不仅能够保证在我们编写的 SubShader 无法在当前显卡上工作时可以有合适的代替 Shader，还可以保证使用透明度测试的物体可以正确地向其他物体投射阴影。</p><p>从上边的图可以看出，透明度测试得到的透明效果很“极端”——要么完全透明，要么完全不透明，它的效果往往像在一个不透明物体上挖了一个空洞。而且，得到的透明效果往往在边缘处参差不齐，有锯齿，这是因为在边界处纹理的透明度的变化精度问题。为了得到更加柔滑的透明效果，就可以使用透明度混合。</p><h2 id="透明度混合">透明度混合</h2><p><strong>透明度混合</strong>：这种方法可以得到真正的半透明效果。它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。但是，透明度混合需要关闭深度写入，这使得我们要非常小心物体的渲染顺序。</p><p>为了进行混合，我们需要使用 Unity 提供的混合命令——Blend。Blend 是 Unity 提供的设置混合模式的命令。想要实现半透明的效果就需要把当前自身的颜色和已经存在于颜色缓冲中的颜色值进行混合，混合时使用的函数就是由该指令决定的。下表给出了 Blend 命令的语义。</p><table><thead><tr><th style="text-align:left">语义</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Blend Off</td><td style="text-align:left">关闭混合</td></tr><tr><td style="text-align:left">Blend SrcFactor DstFactor</td><td style="text-align:left">开启混合，并设置混合因子。源颜色(该片元产生的颜色)会乘以 SrcFactor，而目标颜色(已经存在于颜色缓存的颜色)会乘以 DstFactor，然后把两者相加后在存入颜色缓冲中</td></tr><tr><td style="text-align:left">Blend SrcFactor DstFactor, SrcFactorA DstFactorA</td><td style="text-align:left">和上面几乎一样，只是使用不同的因子来混合透明通道</td></tr><tr><td style="text-align:left">BlendOp BlendOperation</td><td style="text-align:left">并非是把源颜色和目标颜色简单相加后混合，而是使用 BlendOperation 对它们进行其他操作</td></tr></tbody></table><p>我们下面会使用 Blend SrcFactor DstFactor 来进行混合，这个命令在设置混合因子的同时也开启了混合模式。这是因为开启了混合之后，设置片元的透明通道才有意义，而 Unity 在我们使用 Blend 命令的时候就自动帮我们打开了。我们会把源颜色的混合因子 SrcFactor 设为 SrcAlpha，而目标颜色的混合因子 DstFactor 设为 OneMinusSrcAlpha。这意味着，经过混合后新的颜色是：<br>$$<br>DstColor_{new} = SrcAlpha \times SrcColor + (1 - SrcAlpha) \times DstColor_{old}<br>$$<br>我们仍然使用透明度测试用的纹理图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter8/Chapter8-AlphaBlend&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Main Tint&quot;, Color) = (1,1,1,1)<br>        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _AlphaScale (&quot;Alpha Scale&quot;, Range(0, 1)) = 1<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProhector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &#125;<br>        <br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br>            ZWrite Off<br>            Blend SrcAlpha OneMinusSrcAlpha<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br><br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            fixed _AlphaScale;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v)&#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target&#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed4 texColor = tex2D(_MainTex, i.uv);<br>                fixed3 albedo = texColor.rgb * _Color.rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br>                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));<br>                return fixed4(ambient + diffuse, texColor.a * _AlphaScale);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Transparent/VertexLit&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下图所示，我们可以调节材质面板上的 Alpha Scale 参数，以控制整体透明度。</p><p><img src="/posts_image/Transparent/Transparent_8.png" alt="透明度混合效果图1" title="透明度混合效果图1"></p><p>我们在前面解释了由于关闭深度写入带来的各种问题。当模型本身有复杂的遮挡关系或是包含了复杂的非凸网格的时候，就会有各种各样因为排序错误而产生的错误的透明效果。下图给出了使用上面的 Unity Shader 渲染的有复杂遮挡关系模型的效果。</p><p><img src="/posts_image/Transparent/Transparent_9.png" alt="透明度混合效果图2" title="透明度混合效果图2"></p><p>这都是由于我们关闭了深度写入造成的，因为这样我们无法对模型进行像素级别的深度排序。前面我们提到了一种解决方法是分割网格，从而得到一个“质量优等”的网格。但是很多情况下这往往是不切实际的。这时，我们可以想办法重新利用深度写入，让模型可以像半透明物体一样进行淡入淡出。这就是开启深度写入的半透明效果。</p><h2 id="参考">参考</h2><p>《Unity Shader入门精要》</p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Alpha</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础纹理(二)</title>
    <link href="/posts/%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86(%E4%BA%8C)/"/>
    <url>/posts/%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h2 id="渐变纹理">渐变纹理</h2><p>纹理其实可以用于存储任何表面属性。一种常见的用法就是使用渐变纹理来控制漫反射光照的结果。下面我们将学习如何使用一张渐变纹理来控制漫反射光照。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter7/Chapter7-RampTexture&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (1,1,1,1)<br>        _RampTex (&quot;Ramp Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Specular (&quot;Specular&quot;, Color) = (1,1,1,1)<br>        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20<br>    &#125;<br>    SubShader<br>    &#123;<br>        Pass<br>        &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br><br>            fixed4 _Color;<br>            sampler2D _RampTex;<br>            float4 _RampTex_ST;<br>            fixed4 _Specular;<br>            float _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v)<br>            &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.uv = TRANSFORM_TEX(v.texcoord, _RampTex);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target<br>            &#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br><br>                //use the texture to sample the diffuse color<br>                fixed halfLambert = 0.5 * dot(worldNormal, worldLightDir) + 0.5;<br>                fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;<br>                fixed3 diffuse = _LightColor0.rgb * diffuseColor;<br>                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));<br>                fixed3 halfDir = normalize(worldLightDir + viewDir);<br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);<br>                return fixed4(ambient + diffuse + specular, 1.0);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Specular&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用了半兰伯特模型，通过对法线方向和光照方向的点积做一次 0.5 倍的缩放以及一个 0.5 大小的偏移来计算半兰伯特部分 halfLambert。这样，我们得到的 halfLambert 的范围被映射到了[0, 1]之间。之后，我们使用 halfLambert 来构建一个纹理坐标，并用这个纹理坐标对渐变纹理 _RampTex 进行采样。由于 _RampTex 实际上就是一个一维纹理(它在纵轴方向上颜色不变)，因此纹理坐标的 u 和 v 方向我们都使用了 halfLambert。然后，把从渐变纹理采样得到的颜色和材质颜色 _Color 相乘，得到最终的漫反射颜色。剩下的代码就是计算高光反射和环境光，并把它们的结果进行相加。</p><p>效果如下图所示：</p><p><img src="/posts_image/Base_Texture/Base_Texture_19.png" alt="渐变纹理效果图" title="渐变纹理效果图"></p><p>需要注意的是，我们需要把渐变纹理的 Wrap Mode 设为 Clamp 模式，以防止对纹理进行采样时由于浮点数精度而造成的问题。下图给出了 Wrap Mode 分别为 Repeat 和 Clamp 模式的效果对比。</p><p><img src="/posts_image/Base_Texture/Base_Texture_20.png" alt="Wrap Mode分别为Repeat和Clamp模式的效果对比" title="Wrap Mode分别为Repeat和Clamp模式的效果对比"></p><p>可以看出，使用 Repeat 模式在高光区域有一些黑点。这是由于浮点精度造成的，当我们使用 fixed2(halfLambert, halfLambert) 对渐变纹理进行采样时，虽然理论上 halfLambert 对值在[0, 1]之间，但可能会有 1.00001 这样的值出现。如果我们使用的是 Repeat 模式，此时就会舍弃整数部分，只保留小数部分，得到的值就是 0.00001，对应了渐变图中最左边的值，即黑色。因此，就会出现图中这样在高光区域反而有黑点的情况。我们只需要把渐变纹理的 Wrap Mode 设为 Clamp 模式就可以解决这种问题。</p><h2 id="遮罩纹理">遮罩纹理</h2><p><strong>遮罩纹理</strong>允许我们可以保护某些区域，使他们免于某些修改。例如，在之前的实现中，我们都是把高光反射应用到模型表面的所有地方，即所有的像素都使用同样大小的高光强度和高光指数。但有时，我们希望模型表面某些区域的反光强烈一些，而某些区域弱一些。为了得到更加细腻的效果，我们就可以使用一张遮罩纹理来控制光照。另一种常见的应用是在制作地形材质时需要混合多张图片，例如表现草地的纹理、表现石子的纹理、表现裸露土地的纹理等，使用遮罩纹理可以控制如何混合这些纹理。</p><p>使用遮罩纹理的流程一般是：通过采样得到遮罩纹理的纹素值，然后使用其中某个(或某几个)通道的值(例如 texel.r)来与某种表面属性进行相乘，这样，当该通道的值为 0 时，可以保护表面不受该属性的影响。总而言之，使用遮罩纹理可以让美术人员更加精准(像素级别)地控制模型表面的各种性质。</p><h4 id="实践">实践</h4><p>下面我们将学习如何使用一张高光遮罩纹理，逐像素地控制模型表面的高光反射强度。下图显示了只包含漫反射、未使用遮罩的高光反射和使用遮罩的高光反射的对比效果。</p><p><img src="/posts_image/Base_Texture/Base_Texture_21.png" alt="使用高光遮罩纹理" title="使用高光遮罩纹理"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter7/Chapter7-MaskTexture&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (1,1,1,1)<br>        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;<br>        _BumpScale (&quot;Bump Scale&quot;, Float) = 1.0<br>        _SpecularMask (&quot;Specular Mask&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _SpecularScale (&quot;Specular Scale&quot;, Float) = 1.0<br>        _Specular (&quot;Specular&quot;, Color) = (1,1,1,1)<br>        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20<br>    &#125;<br>    SubShader<br>    &#123;<br>        Pass<br>        &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br><br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            sampler2D _BumpMap;<br>            float _BumpScale;<br>            sampler2D _SpecularMask;<br>            float _SpecularScale;<br>            fixed4 _Specular;<br>            float _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 tangent : TANGENT;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float2 uv : TEXCOORD0;<br>                float3 lightDir : TEXCOORD1;<br>                float3 viewDir : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<br>                <br>                TANGENT_SPACE_ROTATION;<br>                //Transform the light direction from object space to tangent space<br>                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;<br>                //Transform the view direction from object space to tangent space<br>                o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;<br><br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                fixed3 tangentLightDir = normalize(i.lightDir);<br>                fixed3 tangentViewDir = normalize(i.viewDir);<br><br>                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv));<br>                tangentNormal.xy *= _BumpScale;<br>                tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));<br><br>                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br>                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir));<br>                fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);<br><br>                fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;<br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss) * specularMask;<br>                return fixed4(ambient + diffuse + specular, 1.0);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Specular&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们为主纹理 _MainTex、法线纹理 _BumpMap 和遮罩纹理 _SpecularMask 定义了它们共同使用的纹理属性变量 _MainTex_ST。这意味着，在材质面板中修改主纹理的平铺系数会同时影响 3 个纹理的采样。使用这种方式可以让我们节省需要存储的纹理坐标数目，如果我们为每一个纹理都使用一个单独的属性变量 TextureName_ST，那么随着使用的纹理数目的增加，我们会迅速占满顶点着色器中可以使用的插值寄存器。而很多时候，我们不需要对纹理进行平铺和位移操作，或者很多纹理可以使用同一种平铺和位移操作，此时我们就可以对这些纹理使用同一个变换后的纹理坐标进行采样。</p><p>在计算高光反射时，我们首先对遮罩纹理 _SpecularMask 进行采样。由于我们使用的遮罩纹理中每个纹素的 rgb 分量其实都是一样的，表明了该点对应的高光反射强度，在这里我们使用 r 分量来计算掩码值。然后，我们用得到的掩码值和 _SpecularScale相乘，一起来控制高光反射的强度。</p><p>需要说明的是，我们使用的这张遮罩纹理其实有很多空间被浪费了——它的 rgb 分量存储的都是同一个值。在实际的游戏制作中，我们往往会充分利用遮罩纹理中的每一个颜色通道来存储不同的表面属性。</p><h4 id="其他遮罩纹理">其他遮罩纹理</h4><p>在真实的游戏制作过程中，遮罩纹理已经不止限于保护某些区域使它们免于某些修改，而是可以存储任何我们希望逐像素控制的表面属性。通常，我们会充分利用一张纹理的 RGBA 四个通道，用于存储不同的属性。例如，我们可以把高光反射的强度存储在 R 通道，把边缘光照的强度存储在 G 通道，把高光反射的指数部分存储在 B 通道，最后把自发光强度存储在 A 通道。</p><h2 id="参考">参考</h2><p>《Unity Shader入门精要》</p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Texture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础纹理(一)</title>
    <link href="/posts/%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86(%E4%B8%80)/"/>
    <url>/posts/%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h2 id="基础纹理">基础纹理</h2><p>纹理最初的目的就是使用一张图片来控制模型的外观。使用<strong>纹理映射(texture mapping)技术</strong>，我们可以把一张图“黏”在模型表面，逐**纹素(texel)**地控制模型的颜色。</p><p>在美术人员建模的时候，通常会在建模软件中利用纹理展开技术把**纹理映射坐标(texture-mapping corrdinates)**存储在每个顶点上。纹理映射坐标定义了该顶点在纹理中对应的2D坐标。通常，这些坐标使用一个二维变量(u, v)来表示，其中 u 是横向坐标，而 v 是纵向坐标。因此，纹理映射坐标也被称为 UV 坐标。</p><p>尽管纹理的大小可以是多种多样的，例如可以是 256 $\times$ 256，或者 1028 $\times$ 1028，但顶点 UV 坐标的范围通常都是被归一化到[0, 1]范围内。需要注意的是，纹理采样时使用的纹理坐标不一定时在[0, 1]范围内。实际上，这种不在[0, 1]范围内的纹理坐标有时会非常有用。与之关系紧密的是纹理的平铺模式，它将决定渲染引擎在遇到不在[0, 1]范围内的纹理坐标时如何进行纹理采样。</p><h2 id="单张纹理">单张纹理</h2><h4 id="实践">实践</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br>// Upgrade NOTE: replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;<br><br>Shader &quot;Custom/Chapter7/Chapter7-SingleTexture&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Color&quot;, Color) = (1,1,1,1)<br>        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)<br>        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20<br>    &#125;<br>    SubShader<br>    &#123;<br>        Pass &#123;<br><br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br><br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            fixed4 _Specular;<br>            float _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v)&#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br>                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));<br>                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));<br>                fixed3 halfDir = normalize(worldLightDir + viewDir);<br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);<br><br>                return fixed4(ambient + diffuse + specular, 1.0);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Specular&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>与其他属性类型不同的是，我们还需要为纹理类型的属性声明一个 float4 类型的变量 _MainTex_ST。其中，_MainTex_ST 的名字不是任意起的。在Unity中，我们需要使用<strong>纹理名_ST</strong>的方式来声明某个纹理的属性。其中，ST 是缩放(scale)和平移(translation)的缩写。_MainTex_ST 可以让我们得到该纹理的缩放和平移(偏移)值，_MainTex_ST.xy 存储的是缩放值，而 _MainTex_ST.zw 存储的是偏移值。这些值可以在材质面板的纹理属性中调节，如下图所示。</p><p><img src="/posts_image/Base_Texture/Base_Texture_1.png" alt="材质面板的纹理属性" title="材质面板的纹理属性"></p><p>在顶点着色器中，我们使用纹理的属性值 _MainTex_ST 来对顶点纹理坐标进行变换，得到最终的纹理坐标。计算过程是，首先使用缩放属性 _MainTex_ST.xy 对顶点纹理坐标进行缩放，然后再使用偏移属性 _MainTex_ST.zw 对结果进行偏移。Unity 提供了一个内置宏 TRANSFORM_TEX 来帮我们计算上述过程。TRANSFORM_TEX 是在 UnityCG.cginc 中定义的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">//Transforms 2D UV by scale/bias property<br>#define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)<br></code></pre></td></tr></table></figure><p>它接受两个参数，第一个参数是顶点纹理坐标，第二个参数是纹理名，在它的实现中，将利用<strong>纹理名_ST</strong>的方式来计算变换后的纹理坐标。</p><p>上面的代码首先计算了世界空间下的法线方向和光照方向。然后，使用 CG 的 tex2D 函数对纹理进行采样。它的第一个参数是需要被采样的纹理，第二个参数是一个 float2 类型的纹理坐标，它将返回计算得到的纹素值。我们使用采样结果和颜色属性 _Color 的乘积来作为材质的反射率 albedo，并把它和环境光照相乘得到的环境光部分。随后，我们使用 albedo 来计算漫反射光照的结果，并和环境光照、高光反射光照相加后返回。结果如下图：</p><p><img src="/posts_image/Base_Texture/Base_Texture_2.png" alt="SingleTexture" title="SingleTexture"></p><h4 id="纹理的属性">纹理的属性</h4><p>在我们向 Unity 中导入一张纹理资源后，可以在它的材质面板上调整其属性，如下图所示。</p><p><img src="/posts_image/Base_Texture/Base_Texture_3.png" alt="纹理的属性" title="纹理的属性"></p><p>纹理面板中的第一个属性是纹理类型，我们之所以要为导入的纹理选择合适的类型，是因为只有这样才能让 Unity 知道我们的意图，为 Unity Shader 传递正确的纹理，并在一些情况下可以让 Unity 对该纹理进行优化。</p><p>下面一个属性非常重要——Wrap Mode。它决定了当纹理坐标超过[0, 1]范围后将如何被平铺。在 Repeat 模式下，如果纹理坐标超过了1，那么它的整数部分将会被舍弃，而直接使用小数部分进行采样，这样的结果是纹理将会不断重复；在 Clamp 模式下，如果纹理坐标大于1，那么将会截取到1，如果小于0，那么将会截取到0。</p><p><img src="/posts_image/Base_Texture/Base_Texture_4.png" alt="Repeat模式" title="Repeat模式"></p><p><img src="/posts_image/Base_Texture/Base_Texture_5.png" alt="Clamp模式" title="Clamp模式"></p><p>我们还可以在材质面板中调整纹理的偏移量，下图展示了在纹理的偏移属性为(0.2, 0.6)时分别使用 Repeat 和 Clamp 模式的结果。</p><p><img src="/posts_image/Base_Texture/Base_Texture_6.png" alt="Repeat模式下偏移" title="Repeat模式下偏移"></p><p><img src="/posts_image/Base_Texture/Base_Texture_7.png" alt="Clamp模式下偏移" title="Clamp模式下偏移"></p><p>纹理导入面板中 Filter Mode 属性决定了当纹理由于变换而产生拉伸时将会采用哪种滤波模式。Filter Mode 支持3种模式：Point，Bilinear 以及 Trilinear。它们得到的图片滤波效果依次提升，但需要耗费的性能也依次增大。纹理滤波会影响放大或缩小纹理时得到的图片质量。例如，当我们把一张 64 $\times$ 64 大小的纹理贴在一个 512 $\times$ 512 大小的平面上时，就需要放大纹理。下图给出了三种滤波模式下的放大结果。</p><p><img src="/posts_image/Base_Texture/Base_Texture_8.png" alt="Point模式放大图片" title="Point模式放大图片"></p><p><img src="/posts_image/Base_Texture/Base_Texture_9.png" alt="Bilinear模式放大图片" title="Bilinear模式放大图片"></p><p><img src="/posts_image/Base_Texture/Base_Texture_10.png" alt="Trilinear模式放大图片" title="Trilinear模式放大图片"></p><p>纹理缩小的过程比放大更加复杂一些，此时原纹理中的多个像素将会对应一个目标像素。纹理缩放更加复杂的原因在于我们往往需要处理抗锯齿问题，一个最常用的方法就是使用<strong>多级渐远纹理(mipmapping)技术</strong>，多级渐远纹理技术将原纹理提前用滤波处理来得到很多更小的图像，形成了一个图像金字塔，每一层都是对上一层图像降采样的结果。这样在实时运行时，就可以快速得到结果像素，例如当物体远离摄像机时，可以直接使用较小的纹理。但缺点是需要使用一定的空间用于存储这些多级渐远纹理，通常会多占用 33% 的内存空间。这是一种典型的用空间换取时间的方法。在 Unity 中，我们可以在纹理导入面板中勾选 Generate Mip Maps 即可开启多级渐远纹理技术。</p><p>下图给出了从一个倾斜的角度观察一个网格结构的地板时，使用不同的 Filter Mode (同时也使用了多级渐远纹理技术)得到的效果。</p><p><img src="/posts_image/Base_Texture/Base_Texture_11.png" alt="不同Filter Mode加多级渐远纹理技术" title="不同Filter Mode加多级渐远纹理技术"></p><p>在内部实现上，Point 模式使用了**最近邻(nearest neighbor)**滤波，在放大或缩小时，它的采样像素数目通常只有一个，因此图像会看起来有种像素风格的效果。而 Bilinear 滤波则使用了线性滤波，对于每个目标像素，他会找到4个临近像素，然后对它们进行线性插值混合后得到的最终像素，因此图像看起来像被模糊了。而 Trilinear 滤波几乎是和 Bilinear 一样的，只是 Trilinear 还会在多级渐远纹理之间进行混合。如果一张纹理没有使用多级渐远纹理技术，那么 Trilinear 得到的结果是和 Bilinear 就一样的。通常我们会选择 Bilinear 滤波模式。需要注意的是，有时我们不希望纹理看起来是模糊的，例如对于一些类似棋盘的纹理，我们希望它就是像素风的，这时我们可能会选择 Point 模式。</p><p>最后，我们来讲一下纹理的最大尺寸和纹理模式。当我们在为不同平台发布游戏时，需要考虑目标平台的纹理尺寸和质量问题。Unity 允许我们为不同目标平台选择不同的分辨率，如下图所示。</p><p><img src="/posts_image/Base_Texture/Base_Texture_12.png" alt="选择纹理的最大尺寸和纹理模式" title="选择纹理的最大尺寸和纹理模式"></p><p>如果导入的纹理大小超过了 Max Texture Size 中的设置值，那么 Unity 将会把该纹理缩放为这个最大分辨率。理想情况下，导入的纹理可以是非正方形的，但长宽的大小应该是2的幂，例如2、4、8、16、32、64等。如果使用了非2的幂大小(Non Power of Two，NPOT)的纹理，那么这些纹理往往会占用更多的内存空间，而且GPU读取该纹理的速度也会有所下降。有一些平台甚至不支持这种 NPOT 纹理，这时 Unity 在内部会把它缩放成最近的2的幂大小。出于性能和空间的考虑，我们应该尽量使用2的幂大小的纹理。</p><p>而 Format 决定了 Unity 内部使用哪种格式来存储该纹理。使用的纹理格式精度越高，占用的内存空间越大，但得到的效果也越好。我们可以从纹理导入面板的最下方看到存储该纹理需要占用的内存空间(如果开启了多级渐远纹理技术，也会增加纹理的内存占用)。对于一些不需要使用很高精度的纹理(例如用于漫反射颜色的纹理)，我们应该尽量使用压缩格式。</p><h2 id="凹凸映射">凹凸映射</h2><p>纹理的另一种常见的应用就是<strong>凹凸映射(bump mapping)</strong>。凹凸映射的目的是使用一张纹理来修改模型表面的法线，以便为模型提供更多的细节。这种方法不会真的改变模型的顶点位置，只是让模型看起来好像是“凹凸不平”的，但可以从模型的轮廓处看出“破绽”。</p><p>有两种主要的方法可以用来进行凹凸映射：一种方法是使用一张<strong>高度纹理(height map)<strong>来模拟</strong>表面位移(displacement)</strong>，然后得到一个修改后的法线值，这种方法也被称为<strong>高度映射(height mapping)</strong>；另一种方法则是使用一张<strong>法线纹理(normal map)<strong>来直接存储表面法线，这种方法又被称为</strong>法线映射(normal mapping)</strong>。</p><h4 id="高度纹理">高度纹理</h4><p>我们首先来看第一种技术，即使用一张高度图来实现凹凸映射。高度图中存储的是强度值(intensity)，它用于表示模型表面局部的海拔高度。因此，颜色越浅表明该位置的表面越向外凸起，而颜色越深表明该位置越向里凹。这种方法的好处是非常直观，我们可以从高度图中明确地知道一个模型表面的凹凸情况，但缺点是计算更加复杂，在实时计算时不能直接得到表面法线，而是需要由像素的灰度值计算而得，因此需要消耗更多的性能。下图是一张高度图。</p><p><img src="/posts_image/Base_Texture/Base_Texture_13.png" alt="高度图" title="高度图"></p><p>高度图通常会和法线映射一起使用，用于给出表面凹凸的额外信息。也就是说，我们通常会使用法线映射来修改光照。</p><h4 id="法线纹理">法线纹理</h4><p>而法线纹理中存储的就是表面的法线方向。由于法线方向的分量范围在[-1, 1]，而像素的分量范围为[0, 1]，因此我们需要做一个映射，通常使用的映射就是：<br>$$<br>pixel = \cfrac{normal + 1}{2}<br>$$<br>这就要求，我们在Shader中对法线纹理进行采样后，还需要对结果进行一次反映射的过程，以得到原先的法线方向。反映射的过程实际就是使用上面映射函数的逆函数：<br>$$<br>noraml = pixel \times 2 - 1<br>$$<br>然而，由于方向是相对于坐标空间来说的，那么法线纹理中存储的法线方向在哪个坐标空间中呢？对于模型顶点自带的法线，它们是定义在模型空间中的，因此一种直接的想法就是将修改后的模型空间中的表面法线存储在一张纹理中，这种纹理被称为是<strong>模型空间的法线纹理(object-space normal map)</strong>。然而，在实际制作中，我们往往会采用另一种坐标空间，即模型顶点的**切线空间(tangent space)**来存储法线。对于模型的每个顶点，它都有一个属于自己的切线空间，这个切线空间的原点就是该顶点本身，而 z 轴是顶点的法线方向(n)，x 轴是顶点的切线方向(t)，而 y 轴可由法线和切线叉积而得，也被称为是副切线(bitangent，b)或副法线，如下图所示。</p><p><img src="/posts_image/Base_Texture/Base_Texture_14.png" alt="切线空间" title="切线空间"></p><p>这种纹理被称为是<strong>切线空间的法线纹理(tangent-space normal map)</strong>。下图分别给出了模型空间和切线空间下的法线纹理。</p><p><img src="/posts_image/Base_Texture/Base_Texture_15.png" alt="法线纹理" title="法线纹理"></p><p>从图中可以看出，模型空间下的法线纹理看起来是“五颜六色”的。这是因为所有法线所在的坐标空间是同一个坐标空间，即模型空间，而每个点存储的法线方向是各异的，有的是(0, 1, 0)，经过映射后存储到纹理中就对应了RGB(0.5, 1, 0.5)浅绿色，有的是(0, -1, 0)，经过映射后存储到纹理中就对应了(0.5, 0, 0.5)紫色。而切线空间下的法线纹理看起来几乎全部是浅蓝色的，这是因为，每个法线方向所在的坐标空间是不一样的，即是表面每点各自的切线空间。这种法线纹理其实就是存储了每个点在各自的切线空间中的法线扰动方向。也就是说，如果一个点的法线方向不变，那么在它的切线空间中，新的法线方向就是 z 轴方向，即值为(0, 0, 1)，经过映射后存储在纹理中就对应了RGB(0.5, 0.5, 1)浅蓝色。而这个颜色就是法线纹理中大片的蓝色。这些蓝色实际上说明顶点的大部分法线是和模型本身法线一样的，不需要改变。</p><p>总体来说，模型空间下的法线纹理更符合人类的直观认识，而且法线纹理本身也很直观，容易调整，因为不同的法线方向就代表了不同的颜色。但美术人员往往更喜欢使用切线空间下的法线纹理。实际上，法线本身存储在哪个坐标系中都是可以的，我们甚至可以选择存储在世界空间下。但问题是，我们并不是单纯地想要得到法线，后续的光照计算才是我们的目的。而选择哪个坐标系意味着我们需要把不同信息转换到相应的坐标系中。例如，如果选择了切线空间，我们需要把从法线纹理中得到的法线方向从切线空间转换到世界空间(或其他空间)中。</p><p>总体来说，使用模型空间来存储法线的优点如下。</p><ul><li>实现简单，更加直观。我们甚至都不需要模型原始的法线和切线等信息，也就是说，计算更少。生成它也非常简单，而如果要生成切线空间下的法线纹理，由于模型的切线一般是和 UV 方向相同，因此想要得到效果比较好的法线映射就要求纹理映射也是连续的。</li><li>在纹理坐标的缝合处和尖锐的边角部分，可见的突变(缝隙)较少，即可以提供平滑的边界。这是因为模型空间下的法线纹理存储的是同一坐标系下的法线信息，因此在边界处通过插值得到的法线可以平滑变换。而切线空间下的法线纹理中的法线信息是依靠纹理坐标的方向得到的结果，可能会在边缘处或尖锐的部分造成更多可见的缝合迹象。</li></ul><p>但使用切线空间有更多优点。</p><ul><li>自由度很高。模型空间下的法线纹理记录的是<strong>绝对法线信息</strong>，仅可用于创建它时的那个模型，而应用到其他模型上效果就完全错误了。而切线空间下的法线纹理记录的是相对法线信息，这意味着，即便把该纹理应用到一个完全不同的网格上，也可以得到一个合理的结果。</li><li>可以进行 UV 动画。比如，我们可以移动一个纹理的 UV 坐标来实现一个凹凸移动的效果，但使用模型空间下的法线纹理会得到完全错误的结果。原因同上。这种 UV 动画在水或者火山熔岩这种类型的物体上会经常用到。</li><li>可以重用法线纹理。比如，一个砖块，我们仅使用一张法线纹理就可以用到所有的6个面上。原因同上。</li><li>可压缩。由于切线空间下的法线纹理中法线的 Z 方向总是正方向，因此我们可以仅存储 XY 方向，而推导得到 Z 方向。而模型空间下的法线纹理由于每个方向都是可能的，因此必须存储3个方向的值，不可压缩。</li></ul><p>切线空间下的法线纹理的前两个优点足以让很多人放弃模型空间下的法线纹理而选择它。从上面的优点可以看出，切线空间在很多情况下都优于模型空间，而且可以节省美术人员的工作。</p><h4 id="实践-2">实践</h4><p>我们需要在计算光照模型中统一各个方向矢量所在的坐标空间。由于法线纹理中存储的法线是切线空间下的方向，因此我们通常有两种选择：一种选择是在切线空间下进行光照计算，此时我们需要把光照方向、视角方向变换到切线空间下；另一种选择是在世界空间下进行光照计算，此时我们需要把采样得到的法线方向变换到世界空间下，再和世界空间下的光照方向和视角方向进行计算。从效率上来说，第一种方法往往要优于第二种方法，因为我们可以在顶点着色器中就完成对光照方向和视角方向的变换，而第二种方法由于要先对法线纹理进行采样，所以变换过程必须在片元着色器中实现，这意味着我们需要在片元着色器中进行一次矩阵操作。但从通用性角度来说，第二种方法要优于第一种方法，因为有时我们需要在世界空间下进行一些计算，例如在使用 Cubemap 进行环境映射时，我们需要使用世界空间下的反射方向对 Cubemap 进行采样。如果同时需要进行法线映射，我们就需要把法线方向变换到世界空间下。当然，读者可以选择其他坐标空间进行计算，例如模型空间等，但切线空间和世界空间是最为常用的两种空间。</p><h6 id="在切线空间下计算">在切线空间下计算</h6><p>我们首先来看第一种方法，即在切线空间下计算光照模型。基本思路是：在片元着色器种通过纹理采样得到切线空间下的法线，然后再与切线空间下的视角方向、光照方向等进行计算，得到最终的光照结果。为此，我们首先需要在顶点着色器中把视角方向和光照方向从模型空间变换到切线空间中，即我们需要知道从模型空间到切线空间的变换矩阵。这个变换矩阵的逆矩阵，即从切线空间到模型空间的变换矩阵是非常容易求得的，我们在顶点着色器中按切线(x 轴)、副切线(y 轴)、法线(z 轴)的顺序<strong>按列</strong>排列即可得到。如果一个变换中仅存在平移和旋转，那么这个变换的逆矩阵就等于它的转置矩阵，而从切线空间到模型空间的变换正是符合这样的要求的变换。因此，从模型空间到切线空间的变换矩阵就是从切线空间到模型空间的变换矩阵的转置矩阵，我们把切线(x 轴)、副切线(y 轴)、法线(z 轴)的顺序<strong>按行</strong>排列即可得到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;<br><br>Shader &quot;Custom/Chapter7/Chapter7-NormalMapTangentSpace&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (1,1,1,1)<br>        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;<br>        _BumpScale (&quot;Bump Scale&quot;, Float) = 1.0<br>        _Specular (&quot;Specular&quot;, Color) = (1,1,1,1)<br>        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20<br>    &#125;<br><br>    SubShader<br>    &#123;<br>        Pass<br>        &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br><br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            sampler2D _BumpMap;<br>            float4 _BumpMap_ST;<br>            float _BumpScale;<br>            fixed4 _Specular;<br>            float _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 tangent : TANGENT;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float4 uv : TEXCOORD0;<br>                float3 lightDir : TEXCOORD1;<br>                float3 viewDir : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<br>                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;<br><br>                //Compute the binormal<br>                //float3 binormal = cross(normalize(v.normal), normalize(v.tangent.xyz)) * v.tangent.w;<br>                //Construct a matrix which transform vectors from object space to tangent space<br>                //float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal);<br>                //Or just use the build-in macro<br>                TANGENT_SPACE_ROTATION;<br><br>                //Transform the light direction from object space to tangent space<br>                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;<br>                //Transform the view direction from object space to tangent space<br>                o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;<br><br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                fixed3 tangentLightDir = normalize(i.lightDir);<br>                fixed3 tangentViewDir = normalize(i.viewDir);<br><br>                //Get the texel in the normal map<br>                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);<br>                fixed3 tangentNormal;<br><br>                //if the texture is not marked as &quot;Normal map&quot;<br>                //tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;<br>                //tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));<br><br>                //Or mark the texture as &quot;Normal map&quot;, and use the built-in function<br>                tangentNormal = UnpackNormal(packedNormal);<br>                tangentNormal.xy *= _BumpScale;<br>                tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));<br><br>                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br>                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir));<br>                fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);<br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(tangentNormal, halfDir)), _Gloss);<br>                return fixed4(ambient + diffuse + specular, 1.0);<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>    <br>    FallBack &quot;Specular&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>对于法线纹理_BumpMap，我们使用&quot;bump&quot;作为它的默认值。&quot;bump&quot;是 Unity 内置的法线纹理，当没有提供任何法线纹理时，&quot;bump&quot;就对应了模型自带的法线信息。_BumpScale则是用于控制凹凸程度的，当它为0时，意味着该法线纹理不会对光照产生任何影响。我们使用 TANGENT 语义来描述 float4 类型的 tangent 变量，以告诉 Unity 把顶点的切线方向填充到 tangent 变量中。需要注意的是，和法线 normal 不同，tangent 的类型是 float4，而非 float3，这是因为我们需要使用 tangent.w 分量来决定切线空间中的第三个坐标轴——副切线的方向性。</p><p>由于我们使用了两张纹理，因此需要存储两个纹理坐标。为此，我们把 v2f 中的 uv 变量的类型定义为 float4 类型，其中 xy 分量存储了 _MainTex 的纹理坐标，而 zw 分量存储了 _BumpMap 的纹理坐标(实际上，_MainTex 和 _Bumpmap 通常会使用同一组纹理坐标，出于减少插值寄存器的使用数目的目的，我们往往只计算和存储一个纹理坐标即可)。然后，我们把模型空间下切线方向、副切线方向和法线方向按行排列来得到从模型空间到切线空间的变换矩阵 rotation。需要注意的是，在计算副切线时，我们使用 v.tangent.w 和叉积结果进行相乘，这是因为和切线与法线方向都垂直的方向有两个，而 w 决定了我们选择其中哪一个方向。Unity 也提供了一个内置宏 TANGENT_SPACE_ROTATION (在 UnityCG.cginc 中被定义)来帮助我们直接计算得到 rotation 变换矩阵，它的实现和上边的代码完全一样。然后，我们使用 Unity 的内置函数 ObjSpaceLightDir 和 ObjSpaceViewDir 来得到模型空间下的光照和视角方向，再利用变换矩阵 rotation 把它们从模型空间变换到切线空间中。</p><p>在片元着色器中，我们首先利用 tex2D 对法线纹理 _BumpMap 进行采样。法线纹理中存储的是把法线经过映射后得到的像素值，因此我们需要把它们反映射回来。如果我们没有在 Unity 中把该法线纹理的类型设置成 Normal Map，就需要在代码中手动进行这个过程。我们首先把 packedNormal 的 xy 分量按之前提到的公式映射回法线方向，然后乘以 _BumpScale(控制凹凸程度)来得到 tangentNormal 的 xy 分量。由于法线都是单位矢量，因此 tangentNormal.z 分量可以由 tangentNormal.xy 计算而得。由于我们使用的是切线空间下的法线纹理，因此可以保证法线方向的 z 分量为正。在 Unity 中，为了方便 Unity 对法线纹理的存储进行优化，我们通常会把法线纹理的纹理类型标识成 Normal Map，Unity 会根据平台来选择不同的压缩方法。这时，如果我们再使用上面的方法来计算就会得到错误的结果，因为此时 _BumpMap 的 rgb 分量不再是切线空间下法线方向的 xyz 值了。这种情况下，我们可以使用 Unity 的内置函数 UnpackNormal 来得到正确的法线方向。</p><p>结果如下：</p><p><img src="/posts_image/Base_Texture/Base_Texture_16.png" alt="在切线空间下计算光照" title="在切线空间下计算光照"></p><h6 id="在世界空间下计算">在世界空间下计算</h6><p>现在，我们来实现在世界空间下计算光照模型。我们需要在片元着色器中把法线方向从切线空间变换到世界空间下。这种方法的基本思想是：在顶点着色器中计算从切线空间到世界空间的变换矩阵，并把它传递给片元着色器。变换矩阵的计算可以由顶点的切线、副切线和法线在世界空间下的表示来得到。最后，我们只需要在片元着色器中把法线纹理中的法线方向从切线空间变换到世界空间下即可。尽管这种方法需要更多的计算，但在需要使用 Cubemap 进行环境映射等情况下，我们就需要使用这种方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br><br>Shader &quot;Custom/Chapter7/Chapter7-NormalMapWorldSpace&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (1,1,1,1)<br>        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;<br>        _BumpScale (&quot;Bump Scale&quot;, Float) = 1.0<br>        _Specular (&quot;Specular&quot;, Color) = (1,1,1,1)<br>        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20<br>    &#125;<br><br>    SubShader<br>    &#123;<br>        Pass<br>        &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br><br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            sampler2D _BumpMap;<br>            float4 _BumpMap_ST;<br>            float _BumpScale;<br>            fixed4 _Specular;<br>            float _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 tangent : TANGENT;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float4 uv : TEXCOORD0;<br>                float4 TtoW0 : TEXCOORD1;<br>                float4 TtoW1 : TEXCOORD2;<br>                float4 TtoW2 : TEXCOORD3;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<br>                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;<br><br>                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);<br>                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);<br>                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;<br><br>                //Compute the matrix that transform directions from tangent space to world space <br>                //Put the world position in w component for optimization<br><br>                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);<br>                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);<br>                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);<br><br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                //Get the position in world space<br>                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);<br>                //Compute the light and view dir in world space<br>                fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));<br>                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));<br><br>                //Get the normal in tangent space<br>                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));<br>                bump.xy *= _BumpScale;<br>                bump.z = sqrt(1.0 - saturate(dot(bump.xy, bump.xy)));<br>                //Transform the normal from tangent space to world space<br><br>                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));<br><br>                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br>                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(bump, lightDir));<br>                fixed3 halfDir = normalize(lightDir + viewDir);<br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(bump, halfDir)), _Gloss);<br>                return fixed4(ambient + diffuse + specular, 1.0);<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>    <br>    FallBack &quot;Specular&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个插值寄存器最多只能存储 float4 大小的变量，对于矩阵这样的变量，我们可以把它们按行拆成多个变量再进行存储。上面代码中的 TtoW0、TtoW1、和 TtoW2 就依次存储了从切线空间到世界空间的变换矩阵的每一行。实际上，对方向矢量的变换只需要使用 3 $\times$ 3 大小的矩阵，也就是说，每一行只需要使用 float3 类型的变量即可。但为了充分利用插值寄存器的存储空间，我们把世界空间下的顶点位置存储在这些变量的 w 分量中。</p><p>我们首先从 TtoW0、TtoW1、和 TtoW2 的 w 分量中构建世界空间下的坐标。然后，使用内置的 UnityWorldSpaceLightDir 和 UnityWorldSpaceViewDir 函数得到世界空间下的光照和视角方向。接着，我们使用内置的 UnpackNormal 函数对法线纹理进行采样和解码(需要把法线纹理的格式标识成 Normal Map)，并使用 _BumpScale 对其进行缩放。最后，我们使用 TtoW0、TtoW1、和 TtoW2 存储的变换矩阵把法线变换到世界空间下。这是通过使用点乘操作来实现矩阵的每一行和法线相乘来得到的。从视觉表现上，在切线空间下和在世界空间下计算光照几乎没有任何差别。</p><h4 id="Unity中的法线纹理类型">Unity中的法线纹理类型</h4><p><img src="/posts_image/Base_Texture/Base_Texture_17.png" alt="法线纹理标识成Normal map" title="法线纹理标识成Normal map"></p><p>上面我们提到了当把法线纹理的纹理类型标识成 Normal Map 时，可以使用 Unity 的内置函数 UnpackNormal 来得到正确的法线方向。当我们需要使用那些包含了法线映射的内置的 Untiy Shader 时，必须把使用的法线纹理标识成 Normal map 才能得到正确的结果，这是因为这些 Unity Shader 都使用了内置的 UnpackNormal 函数来采样法线方向。当我们把纹理类型设置成 Normal map 可以让 Unity 根据不同平台对纹理进行压缩，再通过 UnpackNormal 函数来针对不同的压缩格式对法线纹理进行正确的采样。</p><p>当我们把纹理类型设置成 Normal map 后，还有一个复选框是 Create from Grayscale，它是用于从高度图中生成法线纹理的。高度图本身记录的是相对高度，是一张灰度图，白色表示相对更高，黑色表示相对更低。当我们把一张高度图导入到 Unity 后，除了需要把它的纹理类型设置成 Normal map 外，还需勾选 Create from Grayscale，这样就可以得到类似下图的结果。然后，我们就可以把它和切线空间下的法线纹理同等对待了。</p><p><img src="/posts_image/Base_Texture/Base_Texture_18.png" alt="Unity根据高度图生成切线空间下的法线纹理" title="Unity根据高度图生成切线空间下的法线纹理"></p><p>当勾选了 Create from Grayscale后，还多出了下两个选项——Bumpiness 和 Filtering。其中 Bumpiness 用于控制凹凸程度，而 Filtering 决定我们使用哪种方式来计算凹凸程度，它有两种选项：一种是 Smooth，这使得生成后的法线纹理会比较平滑；另一种是 Sharp，它会使用 Sobel 滤波(一种边缘检测时使用的滤波器)来生成法线。Sobel 滤波的实现非常简单，我们只需要在一个 3 $\times$ 3 的滤波器中计算 x 和 y 方向上的导数，然后从中得到法线即可。具体方法是：对于高度图中的每个像素，我们考虑它与水平方向和竖直方向上的像素差，把它们的差当成该点对应的法线在 x 和 y 方向上的位移，然后使用之前提到的映射函数存储成到法线纹理的 r 和 g 分量即可。</p><h2 id="参考">参考</h2><p>《Unity Shader入门精要》</p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Texture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标准光照模型</title>
    <link href="/posts/%E6%A0%87%E5%87%86%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/posts/%E6%A0%87%E5%87%86%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="标准光照模型">标准光照模型</h2><p>虽然光照模型有很多种类，但在早期游戏引擎中往往只使用一个光照模型，这个模型被称为标准光照模型。标准光照模型在BRDF理论被提出之前就已经被广泛使用了。标准光照模型只关心直接光照(direct light)，也就是那些直接从光源发射出来照射到物体表面后，经过物体表面的一次反射直接进入摄像机的光线</p><p>它的基本方法是，把进入到摄像机内的光线分为4个部分，每个部分使用一种方法来计算它的贡献度。这四个部分是</p><ul><li>**自发光(emissive)**部分，这个部分用于描述当给定一个方向时，一个表面本身会向该方向发射多少辐射量。需要注意的是，如果没有使用全局光照(global illumination)技术，这些自发光的表面并不会真的照亮周围的物体，而是它本身看起来更亮了而已。</li><li>**高光反射(specular)**部分，这个部分用于描述当光线从光源照射到模型表面时，该表面会在完全镜面反射方向散射多少辐射量。</li><li>**漫反射(diffuse)**部分，这个部分用于描述当光线从光源照射到模型表面时，该表面会向每个方向散射多少辐射量。</li><li>**环境光(ambient)**部分，它用于描述其他所有的间接光照。</li></ul><h3 id="环境光">环境光</h3><p>虽然标准光照模型的重点在于描述直接光照，但在真实的世界中，物体也可以被**间接光照(indirect light)**所照亮。间接光照指的是，光线通常会在多个物体之间反射，最后进入摄像机，也就是说，在光线进入摄像机前，经过了不止一次的物体反射。</p><p>在标准光照模型中，我们使用了一种被称为环境光的部分来近似模拟间接光照。环境光的计算非常简单，它通常是一个全局变量，即场景中的所有物体都使用这个环境光。下面的等式给出了计算环境光的部分：<br>$$<br>c_{ambient} = g_{ambient}<br>$$</p><h3 id="自发光">自发光</h3><p>光线也可以直接由光源发射进入摄像机，而不需要经过任何物体的反射。标准光照模型使用自发光来计算这个部分的贡献度。它的计算也很简单，就是直接使用了该材质的自发光颜色：<br>$$<br>c_{emissive} = m_{emissive}<br>$$<br>通常在实时渲染中，自发光的表面往往并不会照亮周围的表面，也就是说，这个物体并不会被当成一个光源。而使用全局光照系统则可以模拟这类自发光物体对周围物体的影响。</p><h3 id="漫反射">漫反射</h3><p>漫反射光照是用于对那些被物体表面随机散射到各个方向的辐射度进行建模的。在漫反射中，视角的位置是不重要的，因为反射是完全随机的，因此可以认为在任何反射方向上的分布都是一样的。但是，入射光线的角度很重要。</p><p>漫反射光照符合<strong>兰伯特定律(Lambert’s law)</strong>：反射光线的强度与表面法线和光源方向之间夹角的余弦值成正比。因此，漫反射部分的计算如下：<br>$$<br>c_{diffuse} = (c_{light} \cdot m_{diffuse})\max(0, n \cdot I)<br>$$<br>其中，$n$是表面法线，$I$是指向光源的单位矢量，$m_{diffuse}$是材质的漫反射颜色，$c_{light}$是光源颜色。需要注意的是，我们需要防止法线和光源方向点乘的结果为负值，为此，我们使用取最大值的函数来将其截取到0，这可以防止物体被从后面来的光源照亮。</p><h3 id="高光反射">高光反射</h3><p>这里的高光反射是一种经验模型，也就是说，它并不完全符合真实世界中的高光反射现象。它可用于计算那些沿着完全镜面反射方向被反射的光线，这可以让物体看起来是有光泽的，例如金属材质。</p><p>计算高光反射需要知道的信息比较多，如表面法线、视角方向、光源方向、反射方向等。我们假设这些矢量都是单位矢量。下图给出了这些方向矢量。</p><p><img src="/posts_image/Standard_Lighting_Model/Standard_Lighting_Model_1.png" alt="Phong模型高光反射" title="Phong模型高光反射"></p><p>在这四个矢量中，我们实际上只需要知道其中3个矢量即可，而第四个矢量——反射方向可以通过其他信息计算得到：<br>$$<br>r = 2(n \cdot I)n - I<br>$$<br>这样，我们就可以利用Phong模型来计算高光反射的部分：<br>$$<br>c_{specular} = (c_{light} \cdot m_{specular})\max(0, v \cdot r)^{m_{gloss}}<br>$$<br>其中，$m_{gloss}$ 是材质的<strong>光泽度(gloss)</strong>，也被称为<strong>反光度(shininess)</strong>。它用于控制高光区域的“亮点”有多宽，$m_{gloss}$ 越大，亮点就越小。$m_{specular}$ 是材质的高光反射颜色，它用于控制该材质对于高光反射的强度和颜色。$c_{light}$ 则是光源的颜色和强度。同样，这里也需要防止$v \cdot r$的结果为负数。</p><p>和上述的Phong模型相比，Blinn提出了一个简单的修改方法来得到类似的效果。它的基本思想是，避免计算反射方向$r$。为此，Blinn模型引入了一个新的矢量$h$，它是通过对$v$和$I$的取平均后再归一化得到的。即<br>$$<br>h = \cfrac{v + I}{\vert v + I \vert}<br>$$<br>然后，使用$n$和$h$之间对夹角进行计算，而非$v$和$r$之间的夹角，如下图所示。</p><p><img src="/posts_image/Standard_Lighting_Model/Standard_Lighting_Model_2.png" alt="Blinn模型高光反射" title="Blinn模型高光反射"></p><p>总结一下，Blinn模型的公式如下：<br>$$<br>c_{specular} = (c_{light} \cdot m_{specular})\max(0,n \cdot h)^{m_{gloss}}<br>$$<br>在硬件实现时，如果摄像机和光源距离模型足够远的话，Blinn模型会快于Phong模型，这是因为，此时可以认为$v$和$I$都是定值，因此$h$将是一个常量。但是，当$v$或者$I$不是定值时，Phong模型可能反而更快一些。需要注意的是，这两种光照模型都是经验模型，也就是说，我们不应该认为Blinn模型是对“正确的”Phong模型的近似。实际上，在一些情况下，Blinn模型更符合实验结果。</p><h3 id="半兰伯特模型">半兰伯特模型</h3><p>广义的半兰伯特光照模型的公式如下：<br>$$<br>c_{diffuse} = (c_{light} \cdot m_{diffuse})(\alpha(n \cdot I) + \beta)<br>$$<br>可以看出，与原兰伯特模型相比，半兰伯特光照模型没有使用 $\max$ 操作来防止$n$和$I$的点积为负值，而是对其结果进行了一个$\alpha$倍的缩放再加上一个$\beta$大小的偏移。绝大多数情况下，$\alpha$和$\beta$的值均为0.5，即公式为：<br>$$<br>c_{diffuse} = (c_{light} \cdot m_{diffuse})(0.5(n \cdot I) + 0.5)<br>$$<br>通过这样的方式，我们可以把 $n \cdot l$ 的结果范围从[-1, 1]映射到[0, 1]范围内。也就是说，对于模型的背光面，在原兰伯特光照模型中点积结果将映射到同一个值，即0值处；而在半兰伯特模型中，背光面也可以有明暗变化，不同的点积结果会映射到不同的值上。</p><p>需要注意的是，半兰伯特是没有任何物理依据的，它仅仅是一个视觉加强技术。</p><h2 id="逐像素还是逐顶点">逐像素还是逐顶点</h2><p>上面，我们给出了基本光照模型使用的数学公式，那么我们在哪里计算这些光照模型呢？通常来讲，我们有两种选择：在片元着色器中计算，也被称为<strong>逐像素光照(per-pixel lighting)</strong>;在顶点着色器中计算，也被称为<strong>逐顶点光照(per-vertex lighting)</strong>。</p><p>在逐像素光照中，我们会以每个像素为基础，得到它的法线(可以是对顶点法线插值得到的，也可以是从法线纹理中采样得到的)，然后进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为<strong>Phong着色(Phong shading)</strong>，也被称为Phong插值或法线插值着色技术。这不同于我们之前讲到的Phong光照模型。</p><p>与之相对的是逐顶点光照，也被称为<strong>高洛徳着色(Gouraud shading)</strong>。在逐顶点光照中，我们在每个顶点上计算光照，然后会在渲染图元内部进行线性插值，最后输出成像素颜色。由于顶点数目往往小于像素数目，因此，逐顶点光照的计算量往往要小于像素数目。但是，由于逐顶点光照依赖于线性插值来得到像素光照，因此，当光照模型中有非线性的计算(例如计算高光反射时)时，逐顶点光照就会出现问题。而且，由于逐顶点光照会在渲染图元内部对顶点颜色进行插值，这会导致渲染图元内部的颜色总是暗于顶点处的最高颜色值，这在某些情况下会产生明显的棱角现象。</p><h2 id="参考">参考</h2><p>《Unity Shader入门精要》</p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Light</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clip Space</title>
    <link href="/posts/Clip-Space/"/>
    <url>/posts/Clip-Space/</url>
    
    <content type="html"><![CDATA[<h2 id="裁剪空间">裁剪空间</h2><p>顶点从观察空间转换到<strong>裁剪空间(clip space，也被称为齐次裁剪空间)<strong>所用的矩阵叫做</strong>裁剪矩阵(clip matrix)</strong>，也被称为投影矩阵(projection matrix)。</p><p>裁剪空间的目标是能够方便地对渲染图元进行裁剪：完全位于这块空间内部的图元将会被保留，完全位于这块空间外部的图元将会被剔除，而与这块空间边界相交的图元就会被裁剪。那么，这块空间是如何决定的呢？答案是由**视锥体(view frustum)**来决定。</p><p>视锥体指的是空间中的一块区域，这块区域决定了摄像机可以看到的空间。视锥体由六个平面包围而成，这些平面也被称为<strong>裁剪平面(clip planes)</strong>。视锥体有两种类型，这涉及两种投影类型：一种是<strong>正交投影(orthographic projection)</strong>，一种是<strong>透视投影(perspective projection)</strong>。下图显示了从同一位置、同一角度渲染同一个场景的两种摄像机的渲染结果。</p><p><img src="/posts_image/Clip_Space/Clip_Space_1.png" alt="透视投影和正交投影" title="透视投影和正交投影"></p><p>透视投影模拟了人眼看世界的方式，而正交投影则完全保留了物体的距离和角度。因此，在追求真实感的3D游戏中我们往往会使用透视投影，而在一些2D游戏或渲染小地图等其他HUD元素时，我们会使用正交投影。在透视空间里使用的并不是笛卡尔坐标系，为了描述透视空间，科学家提出了“齐次坐标”的概念：</p><p>即，用 N+1 个数来表示 N 维空间中的点或向量，对于三维空间中的点，通常是使用 (x, y, z, w) 来表示三维空间中的点在齐次坐标空间中的位置。三维空间（笛卡尔坐标系）和齐次坐标系之间可以通过齐次除法进行相互转换，科学家定义的规则是：</p><p><img src="/posts_image/Clip_Space/Clip_Space_2.jpeg" alt="齐次除法规则" title="齐次除法规则"></p><p>比如平行线在透视空间中相交于一个点，这个点的齐次坐标可以表示为 (x, y, z, 0)，这里 xyz 为多少并不重要，重要的是 w = 0，因为这使得这个齐次坐标点转换为三维坐标是（x/0, y/0, z/0）= (无穷， 无穷， 无穷) ，因此我们成功描述了这个点。</p><p>在视锥体的6块裁剪平面中，有两块裁剪平面比较特殊，它们分别被称为<strong>近裁剪平面(near clip plane)<strong>和</strong>远裁剪平面(far clip plane)</strong>。它们决定了摄像机可以看到的深度范围。正交投影和透视投影的视锥体如下图所示。</p><p><img src="/posts_image/Clip_Space/Clip_Space_3.png" alt="透视投影和正交投影的视锥体" title="透视投影和正交投影的视锥体"></p><p>前面讲到，我们希望根据视锥体围成的区域对图元进行裁剪，但是，如果直接使用视锥体定义的空间来进行裁剪，那么不同的视锥体就需要不同的处理过程，而且对于透视投影的视锥体来说，想要判断一个顶点是否处于一个金字塔内部是比较麻烦的。因此，我们想用一种更加通用、方便和整洁的方式来进行裁剪的工作，这种方式就是通过一个投影矩阵把顶点转换到一个裁剪空间中。在裁剪空间之前，虽然我们使用了齐次坐标来表示点和矢量，但它们的第四个分量都是固定的：点的w分量是1，方向矢量的w分量是0。经过投影矩阵的变换后，我们就会赋予齐次坐标的第四个坐标更加丰富的含义。</p><p>投影矩阵有两个目的。</p><ul><li>首先是为投影做准备。虽然投影矩阵的名称包含了投影二字，但是它并没有进行真正的投影工作，而是在为投影做准备。真正的投影发生在后面的**齐次除法(homogeneous division)**过程中。而经过投影矩阵的变换后，顶点的w分量将会具有特殊的意义。</li></ul><p>投影可以理解为一个空间的降维，例如从四维空间投影到三维空间中。而投影矩阵实际上并不会真的进行这个步骤，它会为真正的投影做准备工作。真正的投影会在屏幕映射时发生，通过齐次除法来得到二维坐标。</p><ul><li>其次是对x、y、z分量进行缩放。我们上面讲过直接使用视锥体的6个裁剪平面来进行裁剪会比较麻烦。而经过投影矩阵的缩放后，我们可以直接使用w分量作为一个范围值，如果x、y、z分量都位于这个范围内，就说明该顶点位于裁剪空间内。</li></ul><p>裁剪空间中的顶点是用齐次坐标表示的，在屏幕映射阶段里要对裁剪空间的顶点进行一个统一的齐次除法操作，来把顶点从齐次坐标系转换到笛卡尔坐标系的归一化设备坐标（Normalized Device Coordinates, NDC）空间里，经过这一步之后，裁剪空间将会变换到一个立方体内。</p><p>OpenGL 和 DirectX 对 NDC 空间的定义有所不同，前者定义 NDC 空间的 xyz 取值范围是 [-1, 1] ，而后者定义 NDC 空间的 xy 取值范围为 [-1, 1]，z 的取值范围为 [0, 1]。而 Unity 选择了 OpenGL 的规范：</p><p><img src="/posts_image/Clip_Space/Clip_Space_4.jpeg" alt="齐次除法" title="齐次除法"></p><p>转换之后如果 x,y,z 满足条件：</p><p><img src="/posts_image/Clip_Space/Clip_Space_5.jpeg" alt="裁剪条件" title="裁剪条件"></p><p>符合此条件的顶点参与渲染，不符合的则裁剪掉不参与渲染。对于正交摄像机的话，他的裁剪空间是一个长方体，拍摄出来的画面是可以用三维坐标来描述的，不需要齐次坐标来描述，所以正交摄像机的投影矩阵对 w 分量没有进行操作（或者理解为正交摄像机的裁剪空间是 w 恒等于 1 的齐次坐标空间）。</p><p>下面，我们来看一下两种投影类型使用的投影矩阵具体是什么。</p><h4 id="1-正交投影">1. 正交投影</h4><p>视锥体的意义在于定义了场景中的一块三维空间。所有位于这块空间内的物体都将会被渲染，否则就会被剔除或裁剪。我们已经知道视锥体由6个裁剪平面定义，那么这6个裁剪平面又是怎么决定的呢？在Unity中，它们由Camera组件中的参数和Game视图的纵横比共同决定。如下图所示。</p><p><img src="/posts_image/Clip_Space/Clip_Space_1_1.png" alt="正交摄像机的参数对正交投影视锥体的影响" title="正交摄像机的参数对正交投影视锥体的影响"></p><p>由图我们可以看出，我们可以通过Camera组件的Size属性来改变视锥体竖直方向上高度的一半，而Clipping Planes中的Near和Far参数可以控制视锥体的近裁剪平面和远裁剪平面距离摄像机的远近。这样我们就可以求出视锥体近裁剪平面和远裁剪平面的高度，也就是：<br>$$<br>nearClipPlaneHeight = 2 \cdot Size<br>$$<br>$$<br>farClipPlaneHeight = NearClipPlaneHeight<br>$$<br>我们可以通过摄像机的纵横比得倒横向的信息。在Unity中，一个摄像机的纵横比由Game视图的纵横比和Viewport Rect中的W和H属性共同决定(实际上。Unity允许我们在脚本里通过Camera.aspect进行修改，但这里不做讨论)。假设，当前摄像机的纵横比为Aspect，我们定义：<br>$$<br>nearClipPlaneWidth = Aspect \cdot nearClipPlaneHeight<br>$$<br>$$<br>farClipPlaneWidth = nearClipPlaneWidth<br>$$</p><p>现在，我们可以根据已知的Near、Far、Size和Aspect的值来确定正交投影的裁剪矩阵。如下：</p><p>$$<br>M_{ortho} =<br>\begin{bmatrix}<br>\cfrac{1}{Aspect \cdot Size}&amp;0&amp;0&amp;0\<br>0&amp;\cfrac{1}{Size}&amp;0&amp;0\<br>0&amp;0&amp;-\cfrac{2}{Far - Near}&amp;-\cfrac{Far + Near}{Far - Near}\<br>0&amp;0&amp;0&amp;1\<br>\end{bmatrix}<br>$$</p><p>需要注意的是,这里的投影矩阵是建立在Unity对坐标系的假定上面的，也就是说，我们针对的是观察空间为右手坐标系，使用列矩阵在矩阵右侧进行相乘，且变换后z分量范围将在 [-w, w]之间的情况。而在类似DirectX这样的图形接口中，它们希望变换后z分量范围将在 [0, w]之间，因此就需要对上面的透视矩阵进行一些更改。</p><p><strong>推导过程如下</strong></p><p>正交摄像机的视锥体空间定义为：L(left)、R(right)、T(top)、B(bottom)、N(near)、F(far)</p><p>转换到裁剪空间的顶点应该满足： $L \leq x \leq R$、$B \leq y \leq T$、$N \leq z \leq F$</p><p>先单独研究x分量，x分量最后是要映射到-1～1之间的，所以：</p><p>$L \leq x \leq R$</p><p>$0 \leq (x - L) \leq (R - L)$</p><p>$0 \leq \cfrac{x - L}{R - L} \leq 1$</p><p>$0 \leq 2 \times \cfrac{x - L}{R - L} \leq 2$</p><p>$-1 \leq \cfrac{2 \times (x - L)}{R - L} - 1\leq 1$</p><p>最后化简后得到，转换后的x‘分量与原本的x分量之间的表达式是</p><p>$x’ = \cfrac{2 \times x - L - R}{R - L} = \cfrac{2}{R - L} \times x - \cfrac{R + L}{R - L}$</p><p>由于x、y、z都是转换到取值范围为 [-1, 1]的，所以我们可以同理得到其他两个变量：</p><p>$y’ = \cfrac{2 \times y - B - T}{T - B} = \cfrac{2}{T - B} \times y - \cfrac{T + B}{T - B}$</p><p>$z’ = \cfrac{2 \times z - N - F}{F - N} = \cfrac{2}{F - N} \times z - \cfrac{F + N}{F - N}$</p><p>结合正交相机提供的参数，我们可以得到：</p><p>L = -Width / 2、 R = Width / 2、 B = -Height / 2、 T = Height / 2</p><p>而且正交摄像机的参数提供的有： Aspect = Width / Height、 Height = 2 $\times$ Size</p><p>代入后可以得到：</p><p>x’ = (2 / Width) $\times$ x = x / (Aspect $\times$ Size)</p><p>y’ = (2 / Height) $\times$ y = y / Size</p><p>由x’、y‘、z’即可得到正交矩阵的P矩阵：</p><p>$$<br>\begin{bmatrix}<br>\cfrac{1}{Aspect \cdot Size}&amp;0&amp;0&amp;0\<br>0&amp;\cfrac{1}{Size}&amp;0&amp;0\<br>0&amp;0&amp;\cfrac{2}{Far - Near}&amp;-\cfrac{Far + Near}{Far - Near}\<br>0&amp;0&amp;0&amp;1\<br>\end{bmatrix}<br>$$</p><p>由于P矩阵是把顶点从观察空间(右手坐标系)转换到裁剪空间(左手坐标系)，因此要反转处理一下z轴：</p><p>$$<br>\begin{bmatrix}<br>\cfrac{1}{Aspect \cdot Size}&amp;0&amp;0&amp;0\<br>0&amp;\cfrac{1}{Size}&amp;0&amp;0\<br>0&amp;0&amp;-\cfrac{2}{Far - Near}&amp;-\cfrac{Far + Near}{Far - Near}\<br>0&amp;0&amp;0&amp;1\<br>\end{bmatrix}<br>$$</p><h4 id="2-透视投影">2. 透视投影</h4><p>我们还是看一下透视投影中的6个裁剪平面是如何定义的。和正交投影类似，在Unity中，它们也是由Camera组件中的参数和Game视图的纵横比共同决定。如下图所示。</p><p><img src="/posts_image/Clip_Space/Clip_Space_2_1.png" alt="透视摄像机的参数对透视投影视锥体的影响" title="透视摄像机的参数对透视投影视锥体的影响"></p><p>我们可以通过Camera组件的Field of View(简称FOV)属性来改变视锥体竖直方向的张开角度，而Clipping Planes中的Near和Far参数可以控制视锥体的近裁剪平面和远裁剪平面距离摄像机的远近。这样我们可以求出视锥体近裁剪平面和远裁剪平面的高度，也就是：<br>$$<br>nearClipPlaneHeight = 2 \cdot Near \cdot \tan\cfrac{FOV}{2}<br>$$<br>$$<br>farClipPlaneHeight = 2 \cdot Far \cdot \tan\cfrac{FOV}{2}<br>$$</p><p>现在我们还缺乏横向的信息。这可以通过摄像机的纵横比得到。假设，当前摄像机的纵横比为Aspect，那么：<br>$$<br>Aspect = \cfrac{nearClipPlaneWidth}{nearClipPlaneHeight}<br>$$<br>$$<br>Aspect = \cfrac{farClipPlaneWidth}{farClipPlaneHeight}<br>$$<br>现在我们可以根据已知的Near、Far、FOV和Aspect的值来确定透视投影的投影矩阵。<br>$$<br>M_{frustum} =<br>\begin{bmatrix}<br>\cfrac{\cot\cfrac{FOV}{2}}{Aspect}&amp;0&amp;0&amp;0\<br>0&amp;\cot\cfrac{FOV}{2}&amp;0&amp;0\<br>0&amp;0&amp;-\cfrac{Far + Near}{Far - Near}&amp;-\cfrac{2 \cdot Near \cdot Far}{Far - Near}\<br>0&amp;0&amp;-1&amp;0\<br>\end{bmatrix}<br>$$<br>同样，这里的投影矩阵是建立在Unity对坐标系的假定上面的。</p><p><strong>推导过程如下</strong></p><p>正交矩阵的P矩阵已经推导出来，那么如果摄像机是透视模式的话，视锥体是一个金字塔形状的锥体而不是立方体，显而易见的问题是：随着z轴的变化，xy轴分量的取值范围会变大：</p><p><img src="/posts_image/Clip_Space/Clip_Space_2_2.jpeg" alt="随着z变大，xy取值范围变大" title="随着z变大，xy取值范围变大"></p><p>因此我们首先要解决的问题是求出xy分量随着z分量的变化而变化的公式，即它们之间的关系：</p><p><img src="/posts_image/Clip_Space/Clip_Space_2_3.png" alt="xy分量随着z分量的变化而变化" title="xy分量随着z分量的变化而变化"></p><p>如图，在视锥体中，存在一个顶点P（x, y, z），我们先把视锥体的原点O（0，0，0）向视锥体中心发出一道射线穿过近裁剪平面和后面的远裁剪平面（图中未画出），把点P向射线做一条辅助线 BP、连接 OP 相交近截面于点D，点 D 向射线做一条垂直线 AD 得到上图。可以看出图中存在两个相似三角形 OAD 和 OBP，则可以推论：</p><p>$BP = \sqrt{x^2 + y^2}$</p><p>$AD = \sqrt{dx^2 + dy^2}$</p><p>$OA = n$</p><p>$OB = z$</p><p>由于相似三角形的特性，存在：</p><p>$\cfrac{BP}{AD} = \cfrac{OB}{OA} = \cfrac{z}{n}$</p><p>即：$AD = \cfrac{n \cdot BP}{z} = \cfrac{n}{z} \cdot \sqrt{x^2 + y^2}$</p><p>简化之后可以得到：</p><p>$\sqrt{dx^2 + dy^2} = \sqrt{(\cfrac{nx}{z})^2 + (\cfrac{ny}{z})^2}$</p><p>则：</p><p>$dx = \cfrac{nx}{z}$</p><p>$dy = \cfrac{ny}{z}$</p><p>因此可以得出：对于锥体里的任何一个点 (x, y, z) ，其中的 x，y 分量都可以通过上述的公式映射到近裁剪平面上，原本透视摄像机的视锥体是近裁剪平面小，远裁剪平面大的，现在通过上述公式就可以把所有顶点都映射到同一个近裁剪平面的取值范围了，即：left ≤ x ≤ right 、 bottom ≤ y ≤ top ，那么我们可以先把远平面压缩，把视锥体压缩成一个长方体，然后再通过利用正交投影矩阵得到透视投影矩阵。</p><p>在把视锥体压缩成长方体的过程中，我们规定三个原则</p><p>1.近平面的所有点坐标不变</p><p>2.远平面的所有点坐标 z 值不变，都是 f</p><p>3.远平面的中心点的坐标值不变，为 (0, 0, f)</p><p>对于 (x, y, z, 1)，它在视锥体被压缩以后坐标应该为 (nx/z, ny/z, unknown, 1)。我们需要找到一个矩阵 $ M_{persp -&gt; ortho} $，让 (x, y, z, 1) 在用矩阵变换后成为 (nx/z, ny/z, unknown, 1)。</p><h1>$$<br>M_{persp -&gt; ortho}<br>\begin{bmatrix}<br>x\<br>y\<br>z\<br>1\<br>\end{bmatrix}</h1><p>\begin{bmatrix}<br>nx\<br>ny\<br>unknown\<br>z\<br>\end{bmatrix}<br>$$</p><p>$$<br>m_{11}x + m_{12}y + m_{13}z + m_{14} = nx<br>$$</p><p>求出 $ m_{11} = n, m_{12} = m_{13} = m_{14} = 0 $</p><p>$$<br>m_{21}x + m_{22}y + m_{23}z + m_{24} = ny<br>$$</p><p>求出 $ m_{22} = n, m_{21} = m_{23} = m_{24} = 0 $</p><p>$$<br>m_{41}x + m_{42}y + m_{43}z + m_{44} = z<br>$$</p><p>求出 $ m_{43} = 1, m_{41} = m_{42} = m_{44} = 0 $</p><p>$$<br>M_{persp -&gt; ortho} =<br>\begin{bmatrix}<br>n&amp;0&amp;0&amp;0\<br>0&amp;n&amp;0&amp;0\<br>?&amp;?&amp;?&amp;?\<br>0&amp;0&amp;1&amp;0\<br>\end{bmatrix}<br>$$</p><p>我们求出了矩阵其中三行，只剩下第三行未知。然而因为我们规定近平面所有点坐标不变，也就是说 (x, y, z, 1) 经过 $ M_{persp -&gt; ortho} $变换后还是等于 (x, y, z, 1)。</p><h1>$$<br>\begin{bmatrix}<br>n&amp;0&amp;0&amp;0\<br>0&amp;n&amp;0&amp;0\<br>?&amp;?&amp;?&amp;?\<br>0&amp;0&amp;1&amp;0\<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\<br>y\<br>n\<br>1\<br>\end{bmatrix}</h1><h1>\begin{bmatrix}<br>x\<br>y\<br>n\<br>1\<br>\end{bmatrix}</h1><p>\begin{bmatrix}<br>nx\<br>ny\<br>n^2\<br>n\<br>\end{bmatrix}<br>$$</p><p>对于第一二四行，等式成立，第三行为</p><p>$$<br>m_{31}x + m_{32}y + m_{33}n + m_{34} = n^2<br>$$</p><p>明显 $ m_{31} = 0, m_{32} = 0, m_{33}n + m_{34} = n^2 $</p><p>又因为远平面中心点的坐标值不变，为 (0, 0, f)</p><h1>$$<br>\begin{bmatrix}<br>n&amp;0&amp;0&amp;0\<br>0&amp;n&amp;0&amp;0\<br>0&amp;0&amp;?&amp;?\<br>0&amp;0&amp;1&amp;0\<br>\end{bmatrix}<br>\begin{bmatrix}<br>0\<br>0\<br>f\<br>1\<br>\end{bmatrix}</h1><h1>\begin{bmatrix}<br>0\<br>0\<br>f\<br>1\<br>\end{bmatrix}</h1><p>\begin{bmatrix}<br>0\<br>0\<br>f^2\<br>f\<br>\end{bmatrix}<br>$$</p><p>$ m_{33}f + m_{34} = f^2 $</p><p>联立 $ m_{33}n + m_{34} = n^2 $ 和 $ m_{33}f + m_{34} = f^2 $，得 $ m_{33} = n + f, m_{34} = -nf $</p><p>终于我们求得</p><p>$$<br>M_{persp -&gt; ortho} =<br>\begin{bmatrix}<br>Near&amp;0&amp;0&amp;0\<br>0&amp;Near&amp;0&amp;0\<br>0&amp;0&amp;Near+Far&amp;-Near \cdot Far\<br>0&amp;0&amp;1&amp;0\<br>\end{bmatrix}<br>$$</p><p>通过此矩阵，我们可以把原来的透视投影的视锥体压缩为正交投影的长方体。</p><p>$$<br>M_{persp} = M_{ortho}M_{persp -&gt; ortho} =<br>\begin{bmatrix}<br>\cfrac{2Near}{Width}&amp;0&amp;0&amp;0\<br>0&amp;\cfrac{2Near}{Height}&amp;0&amp;0\<br>0&amp;0&amp;-\cfrac{Far+Near}{Far-Near}&amp;\cfrac{-2Near \cdot Far}{Far-Near}\<br>0&amp;0&amp;-1&amp;0\<br>\end{bmatrix}<br>$$</p><p>我们可以通过FOV和三角函数来求出Near的另一种表达方式</p><p><img src="/posts_image/Clip_Space/Clip_Space_2_4.jpeg" alt="透视摄像机" title="透视摄像机"></p><p>上图中，角a是FOV的一半，即 $\cfrac{FOV}{2}$ ，则：</p><p>$\cot{a} = \cot{\cfrac{FOV}{2}} = \cfrac{Near}{Height / 2} = \cfrac{2 \cdot Near}{Height}$</p><p>因此 $Near = \cfrac{Height + \cot{\cfrac{FOV}{2}}}{2}$，再结合 $Aspect = \cfrac{Width}{Height}$ 可以得到</p><p>$$<br>\begin{bmatrix}<br>\cfrac{\cot\cfrac{FOV}{2}}{Aspect}&amp;0&amp;0&amp;0\<br>0&amp;\cot\cfrac{FOV}{2}&amp;0&amp;0\<br>0&amp;0&amp;-\cfrac{Far + Near}{Far - Near}&amp;-\cfrac{2 \cdot Near \cdot Far}{Far - Near}\<br>0&amp;0&amp;-1&amp;0\<br>\end{bmatrix}<br>$$</p><p>平截头体压缩为长方体后，内部的点的z值是更偏向于远平面的。对于点 (x, y, z, 1)，我们通过 $ M_{persp -&gt; ortho} $ 计算第三行，可以得到 $ z’ = (n + f) \cdot z - nf $ ，计算第四行，可以得到 $ w’ = z $ ，所以 $ f(z) = z’/w’ = n + f - nf/z $ ，使用 z = n 和 z = f 的情况进行验算都符合近平面和远平面上的点 z 值不发生变化。</p><p>我们设 n、f 都是绝对值，视锥体内部的点满足 0 &lt; n &lt; z &lt; f，问题变成了，当 0 &lt; n &lt; z &lt; f 时，n + f - nf/z 与 z 的大小关系。</p><p><img src="/posts_image/Clip_Space/Clip_Space_2_5.png" alt="函数图像" title="函数图像"></p><p>可以看出 z 从 n 到 f 的变化过程中，f(z) 的变化率时逐渐变小的，在 n 到 f 这段区域中，f(z) 永远大于 g(z)，即，当 0 &lt; n &lt; z &lt; f 时，n + f -nf/z &gt; z。也就是说，视锥体内的点被挤压得更偏向远平面。</p><h2 id="屏幕映射阶段">屏幕映射阶段</h2><p>顶点转换到裁剪空间上，经裁剪步骤去掉多余的顶点后，接着就到屏幕映射阶段了，这一阶段要进行投影操作：把顶点映射到屏幕上的像素坐标上去，这个过程分成两步：先齐次除法后进行坐标缩放映射。</p><p>正交摄像机里一个顶点和上述正交投影矩阵相乘后的结果：</p><h1>$$<br>\begin{bmatrix}<br>\cfrac{1}{Aspect \cdot Size}&amp;0&amp;0&amp;0\<br>0&amp;\cfrac{1}{Size}&amp;0&amp;0\<br>0&amp;0&amp;-\cfrac{2}{Far - Near}&amp;-\cfrac{Far + Near}{Far - Near}\<br>0&amp;0&amp;0&amp;1\<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\<br>y\<br>z\<br>1\<br>\end{bmatrix}</h1><p>\begin{bmatrix}<br>\cfrac{x}{Aspect \cdot Size}\<br>\cfrac{y}{Size}\<br>-\cfrac{2z}{Far - Near} - \cfrac{Far + Near}{Far - Near}\<br>1\<br>\end{bmatrix}<br>$$<br>下图显示了经过上述投影矩阵后，正交投影的视锥体的变化：</p><p><img src="/posts_image/Clip_Space/Clip_Space_3_1.png" alt="正交投影的视锥体的变化" title="正交投影的视锥体的变化"></p><p>我们刚才说，透视摄像机里求的P矩阵是观察空间的点 (x, y, z, w) 转 (x’z, y’z, z’z, w’z) 的转换矩阵，对最后的结果并没有影响，这是因为投影矩阵只是为屏幕映射阶段中的投影操作做准备而已，依据上述的透视模式下的投影矩阵，假设存在一个观察空间中的顶点（x, y, z, 1），那么它与投影矩阵参与运算后，w 值将会变为-z：</p><h1>$$<br>\begin{bmatrix}<br>\cfrac{\cot\cfrac{FOV}{2}}{Aspect}&amp;0&amp;0&amp;0\<br>0&amp;\cot\cfrac{FOV}{2}&amp;0&amp;0\<br>0&amp;0&amp;-\cfrac{Far + Near}{Far - Near}&amp;-\cfrac{2 \cdot Near \cdot Far}{Far - Near}\<br>0&amp;0&amp;-1&amp;0\<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\<br>y\<br>z\<br>1\<br>\end{bmatrix}</h1><p>\begin{bmatrix}<br>x \cfrac{\cot{\cfrac{FOV}{2}}}{Aspect}\<br>y \cot{\cfrac{FOV}{2}}\<br>-z \cfrac{Far + Near}{Far - Near} - \cfrac{2 \cdot Near \cdot Far}{Far - Near}\<br>-z\<br>\end{bmatrix}<br>$$</p><p>可以看见转换后 w 分量的结果通常不会是 1，我们前面说过，只有 w = 1 的时候，齐次坐标才能和三维坐标等价，因此要把 x, y, z, w 分量都除以 w 分量，这样的话 w 分量就会变成 1，即：</p><p>$(x, y, z, w) \Rightarrow (\cfrac{x}{w}, \cfrac{y}{w}, \cfrac{z}{w}, 1)$</p><p>这个齐次除法操作对于(x’z, y’z, z’z, w’z)来说，结果是一样的</p><p>$(x’z, y’z, z’z, w’z) \Rightarrow (\cfrac{x’}{w’}, \cfrac{y’}{w’}, \cfrac{z’}{w’}, 1)$</p><p>所以说我们上面的投影矩阵对屏幕映射的过程是没有影响的，这个投影矩阵是正确的可用的。</p><p>对于正交摄像机来说，他的视锥体本身就是立方体，裁剪空间顶点的 w 分量也都是 1，所以这个步骤对它来说没什么变化。</p><p>以上就是齐次除法步骤，接下来，我们已经得到顶点的 x、y、z 在 NDC 空间中的值了，z 值将会在之后参与到深度测试中并有可能写入到深度缓冲里。xy 值则需要和屏幕的横纵像素进行映射计算得出顶点在屏幕上的像素坐标：</p><p>假设屏幕的横向像素数量pixelWidth = 400，纵向像素数量pixelHeight = 500</p><p>那么对于x坐标来说，它要从[-1, 1]映射到[0, 400],整个过程是：<br>$$<br>-1 \leq x \leq 1<br>$$<br>$$<br>-400 \leq 400x \leq 400<br>$$<br>$$<br>0 \leq 400x + 400 \leq 800<br>$$<br>$$<br>0 \leq (400 / 2)x + (400 / 2) \leq 400<br>$$<br>因此可以得出公式，x映射到屏幕上：<br>$$<br>X = \cfrac{x \times pixelWidth}{2} + \cfrac{pixelWidth}{2}<br>$$<br>注意这里的x是经过齐次除法的！像素坐标Y同理</p><p>上面的 pixelWidth 和 pixelHeight 可能不是整个屏幕的大小，而可能是游戏窗口的大小，比较有的游戏要窗口化运行，那么 pixelWidth 和 pixelHeight 指的就是游戏窗口的大小，当然窗口可以随意拖动，顶点也一直会跟随窗口映射到不同的屏幕像素上，不过这些都是Unity帮我们自动处理的了。</p><h2 id="参考">参考</h2><p>《Unity Shader入门精要》</p><p><a href="https://zhuanlan.zhihu.com/p/440717663">齐次坐标系与Unity投影矩阵的推导</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spatial Transform</title>
    <link href="/posts/Spatial-Transform/"/>
    <url>/posts/Spatial-Transform/</url>
    
    <content type="html"><![CDATA[<h2 id="坐标空间的变换">坐标空间的变换</h2><p>在渲染流水线中，我们往往需要把一个点或者方向矢量从一个坐标空间转换到另一个坐标空间，这个过程的是怎么实现的？<br>我们要想定义一个坐标空间，必须指明其原点位置和三个坐标轴的方向。而这些数值实际上是相对于另一个坐标空间的。也就是说坐标空间会形成一个层次结构——每个坐标空间都是另一个坐标空间的子空间，反过来说，每个空间都有一个父坐标空间。对坐标空间的变换实际上就是在父空间和子空间之间对点和矢量进行变换。<br>假设现在有父坐标空间<strong>P</strong>以及一个子坐标空间<strong>C</strong>，我们现在已知父坐标空间中子坐标空间的原点位置以及三个单位坐标轴。我们会有两种需求，一种需求是把子坐标空间下表示的点或矢量<strong>A</strong><sub><i>c</i></sub>转换到父坐标空间下的表示<strong>A</strong><sub><i>p</i></sub>，另一种需求是反过来，即把父坐标空间下表示的点或矢量<strong>B</strong><sub><i>p</i></sub>转换到子坐标空间下的表示<strong>B</strong><sub><i>c</i></sub>。我们可以用下面的公式来表示这两种需求：</p><p>$$<br>A_p = M_{c \rightarrow p}A_c<br>$$<br>$$<br>B_c = M_{p \rightarrow c}B_p<br>$$</p><p>其中，<b>M</b><sub><i>c-&gt;p</i></sub>表示的是从子坐标空间变换到父坐标空间的变换矩阵，<b>M</b><sub><i>p-&gt;c</i></sub>表示的是从父坐标空间变换到子坐标空间的变换矩阵，他俩互为逆矩阵。</p><p>下面我们就来讲解如何求出从子坐标空间到父坐标空间的变换矩阵<b>M</b><sub><i>c-&gt;p</i></sub>。</p><p>现在，我们已知子坐标空间<strong>C</strong>的3个坐标轴在父坐标空间<strong>P</strong>下的表示为：<b>x</b><sub><i>c</i></sub>、<b>y</b><sub><i>c</i></sub>、<b>z</b><sub><i>c</i></sub>，以及其原点位置<b>O</b><sub><i>c</i></sub>。当给定一个子坐标空间中的一个点<b>A</b><sub><i>c</i></sub> = (a,b,c)，我们可以用下面四个步骤来确定其在父坐标空间下的位置<b>A</b><sub><i>p</i></sub>：</p><p><strong>1. 从坐标空间的原点开始</strong><br>我们已经知道了子坐标空间的原点位置$O_c$。</p><p><strong>2. 向 x 轴方向移动 a 个单位</strong><br>我们已经知道了x轴的矢量表示，因此可以得到<br>$$<br>O_c + ax_c<br>$$</p><p><strong>3. 向 y 轴方向移动 b 个单位</strong><br>同样的道理，这一步就是：<br>$$<br>O_c + ax_c + by_c<br>$$</p><p><strong>4. 向 z 轴方向移动 c 个单位</strong><br>最后就可以得到<br>$$<br>O_c + ax_c + by_c + cz_c<br>$$</p><p>那么，</p><p>$$<br>\begin{aligned}<br>A_p<br>&amp;= O_c + ax_c + by_c + cz_c\<br>&amp;= (x_{O_c}, y_{O_c}, z_{O_c}) + a(x_{x_c}, y_{x_c}, z_{x_c}) + b(x_{y_c}, y_{y_c}, z_{y_c}) + c(x_{z_c}, y_{z_c}, z_{z_c})\<br>&amp;= (x_{O_c}, y_{O_c}, z_{O_c}) +<br>\begin{bmatrix}<br>x_{x_c}&amp;x_{y_c}&amp;x_{z_c}\<br>y_{x_c}&amp;y_{y_c}&amp;y_{z_c}\<br>z_{x_c}&amp;z_{y_c}&amp;z_{z_c}\<br>\end{bmatrix}<br>\begin{bmatrix}a\b\c\\end{bmatrix}\<br>&amp;= (x_{O_c}, y_{O_c}, z_{O_c}) +<br>\begin{bmatrix}<br>|&amp;|&amp;|\<br>x_c&amp;y_c&amp;z_c\<br>|&amp;|&amp;|\<br>\end{bmatrix}<br>\begin{bmatrix}a\b\c\\end{bmatrix}\<br>&amp;= O_c + \begin{bmatrix}x_c&amp;y_c&amp;z_c\\end{bmatrix}\begin{bmatrix}a\b\c\\end{bmatrix}<br>\end{aligned}<br>$$</p><p>由于3 $\times$ 3的矩阵无法表示平移变换，我们把上面的式子扩展到齐次坐标空间中，得<br>$$<br>\begin{aligned}<br>A_p<br>&amp;= (x_{O_c}, y_{O_c}, z_{O_c}, 1) +<br>\begin{bmatrix}<br>|&amp;|&amp;|&amp;0\<br>x_c&amp;y_c&amp;z_c&amp;0\<br>|&amp;|&amp;|&amp;0\<br>0&amp;0&amp;0&amp;1\<br>\end{bmatrix}<br>\begin{bmatrix}a\b\c\1\\end{bmatrix}\<br>&amp;=\begin{bmatrix}<br>1&amp;0&amp;0&amp;x_{O_c}\<br>0&amp;1&amp;0&amp;y_{O_c}\<br>0&amp;0&amp;1&amp;z_{O_c}\<br>0&amp;0&amp;0&amp;1\<br>\end{bmatrix}<br>\begin{bmatrix}<br>|&amp;|&amp;|&amp;0\<br>x_c&amp;y_c&amp;z_c&amp;0\<br>|&amp;|&amp;|&amp;0\<br>0&amp;0&amp;0&amp;1\<br>\end{bmatrix}<br>\begin{bmatrix}a\b\c\1\\end{bmatrix}\<br>&amp;= \begin{bmatrix}<br>|&amp;|&amp;|&amp;x_{O_c}\<br>x_c&amp;y_c&amp;z_c&amp;y_{O_c}\<br>|&amp;|&amp;|&amp;z_{O_c}\<br>0&amp;0&amp;0&amp;1\<br>\end{bmatrix}<br>\begin{bmatrix}a\b\c\1\\end{bmatrix}\<br>\end{aligned}<br>$$</p><p>所以，显而易见<br>$$<br>M_{c \rightarrow p} =<br>\begin{bmatrix}<br>|&amp;|&amp;|&amp;x_{O_c}\<br>x_c&amp;y_c&amp;z_c&amp;y_{O_c}\<br>|&amp;|&amp;|&amp;z_{O_c}\<br>0&amp;0&amp;0&amp;1\<br>\end{bmatrix}<br>$$</p><p>可以看出来，变换矩阵<b>M</b><sub><i>c-&gt;p</i></sub>实际上可以通过坐标空间<strong>C</strong>在坐标空间<strong>P</strong>中的原点和坐标轴的矢量表示来构建出来：把3个坐标轴依次放入矩阵的前三列，把原点矢量放到最后一列，再用0和1填充最后一行即可。</p><p>我们可以利用反向思维，从这个变换矩阵反推来获取子坐标空间的原点和坐标轴方向。例如，当我们已知从模型空间到世界空间的一个4 $\times$ 4的变换矩阵，可以提取它的第一列再进行归一化后（为了消除缩放的影响）来得到模型空间的x轴在世界空间下的单位矢量表示。同样的方法可以提取y轴和z轴。我们可以从另一个角度来理解这个提取过程。因为矩阵<b>M</b><sub><i>c-&gt;p</i></sub>可以把一个方向矢量从坐标空间<strong>C</strong>变换到坐标空间<strong>P</strong>中，那么，只需要用它来变换坐标空间<strong>C</strong>中的x轴(1,0,0,0),即使用矩阵乘法<br>$$<br>M_{c \rightarrow p}<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;0<br>\end{bmatrix}^T<br>$$<br>得到的结果正是<b>M</b><sub><i>c-&gt;p</i></sub>的第一列。</p><p>对矢量的坐标空间变换可以使用3 $\times$ 3的矩阵来表示，因为我们不需要表示平移变换，在Shader中，我们常常会看到截取变换矩阵的前3行前3列来对法线方向、光照方向来进行空间变换，这正是原因所在。</p><p>由于<b>M</b><sub><i>c-&gt;p</i></sub>和<b>M</b><sub><i>p-&gt;c</i></sub>互为逆矩阵，我们可以通过求<b>M</b><sub><i>c-&gt;p</i></sub>的逆矩阵的方式来求出<b>M</b><sub><i>p-&gt;c</i></sub>，但当<b>M</b><sub><i>c-&gt;p</i></sub>是一个正交矩阵时，<b>M</b><sub><i>c-&gt;p</i></sub>的逆矩阵就等于它的转置矩阵，也就是说，<br>$$<br>\begin{aligned}<br>M_{p \rightarrow c} &amp;=<br>\begin{bmatrix}<br>|&amp;|&amp;|\<br>x_p&amp;y_p&amp;z_p\<br>|&amp;|&amp;|\<br>\end{bmatrix}<br>= M_{c \rightarrow p}^{-1} = M_{c \rightarrow p}^T\<br>&amp;=<br>\begin{bmatrix}<br>-&amp;x_c&amp;-\<br>-&amp;y_c&amp;-\<br>-&amp;z_c&amp;-\<br>\end{bmatrix}<br>\end{aligned}<br>$$<br>现在，我们不仅可以根据变换矩阵<b>M</b><sub><i>c-&gt;p</i></sub>反推出子坐标空间的坐标轴方向在父坐标空间中的表示<b>x</b><sub><i>c</i></sub>、<b>y</b><sub><i>c</i></sub>和<b>z</b><sub><i>c</i></sub>，还可以反推出父坐标空间的坐标轴方向在子坐标空间中的表示<b>x</b><sub><i>p</i></sub>、<b>y</b><sub><i>p</i></sub>和<b>z</b><sub><i>p</i></sub></p><h2 id="顶点的坐标空间变换过程">顶点的坐标空间变换过程</h2><p><img src="/posts_image/Spatial_Transform/Spatial_Transform_1.png" alt="顶点的坐标空间变换过程" title="顶点的坐标空间变换过程"></p><h2 id="法线变换">法线变换</h2><p><strong>法线(normal)</strong>，也被称为<strong>法矢量(normal vector)</strong>。在上面我们已经看到如何使用变换矩阵来变换一个顶点或一个方向矢量，但法线是需要我们特殊处理的一种方向矢量。在游戏中，模型的一个顶点往往会携带额外的信息，而顶点法线就是其中一种信息。当我们变换一个模型的时候，不仅需要变换它的顶点，还需要变换顶点法线，以便在后续处理(如片元着色器)中计算光照等。</p><p>一般来说，点和绝大部分方向矢量都可以使用同一个4 $\times$ 4或3 $\times$ 3的变换矩阵<b>M</b><sub><i>A-&gt;B</i></sub>把其从坐标空间<strong>A</strong>变换到坐标空间<strong>B</strong>中。但在变换法线的时候，如果使用同一个变换矩阵，可能就无法确保维持法线的垂直性。下面就来了解一下为什么会出现这样的问题。</p><p>我们先来了解一下另一种方向矢量——<strong>切线(tangent)</strong>，也被称为<strong>切矢量(tangent vector)</strong>。与法线类似，切线往往也是模型顶点携带的一种信息。它通常与纹理空间对齐，且与法线方向垂直。<br><img src="/posts_image/Spatial_Transform/Spatial_Transform_2.png" alt="顶点的切线和法线" title="顶点的切线和法线"></p><p>由于切线是由两个顶点之间的差值计算得到的，因此我们可以直接使用用于变换顶点的变换矩阵来变换切线。假设，我们使用3 $\times$ 3的变换矩阵<b>M</b><sub><i>A-&gt;B</i></sub>来变换顶点(注意，这里涉及的变换矩阵都是3 $\times$ 3的矩阵，不考虑平移变换。这是因为切线和法线都是方向矢量，不会受平移的影响)，可以由下面的式子直接得到变换后的切线：<br>$$<br>T_B = M_{A \rightarrow B}T_A<br>$$<br>其中<b>T</b><sub><i>A</i></sub>和<b>T</b><sub><i>B</i></sub>分别表示在坐标空间<strong>A</strong>和坐标空间<strong>B</strong>下的切线方向。但如果直接使用<b>M</b><sub><i>A-&gt;B</i></sub>来变换法线，得到的新的法线方向可能就不会与表面垂直了。<br><img src="/posts_image/Spatial_Transform/Spatial_Transform_3.png" alt="进行非统一缩放变换法线会出现错误" title="进行非统一缩放变换法线会出现错误"></p><p>我们可以由数学约束条件来推出正确变换法线的矩阵。我们知道同一个顶点的切线<b>T</b><sub><i>A</i></sub>和法线<b>N</b><sub><i>A</i></sub>必须满足垂直条件，即 $T_A \cdot N_A = 0$。给定变换矩阵<b>M</b><sub><i>A-&gt;B</i></sub>，我们已经知道 $T_B = M_{A \rightarrow B}T_A$。我们现在想要找到一个矩阵<strong>G</strong>来变换法线<b>N</b><sub><i>A</i></sub>，使得变换后的法线仍然与切线垂直。即<br>$$<br>T_B \cdot N_B = (M_{A \rightarrow B}T_A) \cdot (GN_A) = 0<br>$$</p><p>对上式进行一些推导后可得<br>$$<br>(M_{A \rightarrow B}T_A) \cdot (GN_A) = (M_{A \rightarrow B}T_A)^T(GN_A) = T_A^TM_{A \rightarrow B}^TGN_A = T_A^T(M_{A \rightarrow B}^TG)N_A = 0<br>$$</p><p>由于 $T_A \cdot N_A = 0$，因此如果$M_{A \rightarrow B}^TG = I$，那么上式即可成立。也就是说，如果 $G = (M_{A \rightarrow B}^T)^{-1} = (M_{A \rightarrow B}^{-1})^T$，即使用原变换矩阵的逆转置矩阵来变换法线就可以得到正确的结果。</p><p>值得注意的是，如果变换矩阵<b>M</b><sub><i>A-&gt;B</i></sub>是正交矩阵，那么 $M_{A \rightarrow B}^{-1} = M_{A \rightarrow B}^T$，因此$(M_{A \rightarrow B}^T)^{-1} = M_{A \rightarrow B}$，也就是说我们可以使用用于变换顶点的变换矩阵来直接变换法线。如果变换只包括旋转变换，那么这个变换矩阵就是正交矩阵。而如果变换只包含旋转和统一缩放，而不包含非统一缩放，我们利用统一缩放系数<em>k</em>来得到变换矩阵<b>M</b><sub><i>A-&gt;B</i></sub>的逆转置矩阵<br>$(M_{A \rightarrow B}^T)^{-1} = \frac {1} {k} M_{A \rightarrow B}$。这样就可以避免计算逆矩阵的过程。如果变换中包含了非统一变换，那么我们就必须要求解逆矩阵来得到变换法线的矩阵。</p><h2 id="参考">参考</h2><p>《Unity Shader入门精要》</p>]]></content>
    
    
    <categories>
      
      <category>Unity Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
