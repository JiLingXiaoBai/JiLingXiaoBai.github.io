---
title: 透明效果(一)
date: 2022-01-25 22:26:13
tags: Alpha
categories: Unity Shader
---

## 透明效果 ##

在实时渲染中要实现透明效果，通常会在渲染模型时控制它的**透明通道(Alpha Channel)**。当开启透明混合后，当一个物体被渲染到屏幕上时，每个片元除了颜色值和深度值之外，它还有另一个属性——透明度。当透明度为 1 时，表示该像素是完全不透明的，而当其为 0 时，则表示该像素完全不会显示。

在 Unity 中，我们通常使用两种方法来实现透明效果：第一种是使用**透明度测试(Alpha Test)**，这种方法其实无法得到真正的半透明效果；另一种是**透明度混合(Alpha Blending)**。

对于不透明(opaque)物体，不考虑它们的渲染顺序也能得到正确的排序效果，这是由于强大的深度缓冲(depth buffer，也被称为 z-buffer)的存在。在实时渲染中，深度缓冲是用于解决可见性(visibility)问题的，它可以决定哪个物体的哪些部分会被渲染在前面，而哪些部分会被其他物体遮挡。它的基本思想是：根据深度缓存中的值来判断该片元距离摄像机的距离，当渲染一个片元时，需要把它的深度值和已经存在于深度缓冲中的值进行比较(如果开启了深度测试)，如果它的值距离摄像机更远，那么说明这个片元不应该被渲染到屏幕上(有物体挡住了它)；否则，这个片元应该覆盖掉此时颜色缓冲中的像素值，并把它的深度值更新到深度缓冲中(如果开启了深度写入)。

使用深度缓冲，可以让我们不用关心不透明物体的渲染顺序，例如 A 挡住 B，即便我们先渲染 A 再渲染 B，也不用担心 B 会遮盖掉 A，因为在进行深度测试时会判断出 B 距离摄像机更远，也就不会写入到颜色缓冲中。但如果想要实现透明效果，事情就不那么简单了，这是因为，当使用透明度混合时，我们关闭了深度写入(ZWrite)。

简单来说，透明度测试和透明度混合的基本原理如下。

* **透明度测试**：它采用一种“霸道极端”的机制，只要一个片元的透明度不满足条件(通常是小于某个阈值)，那么它对应的片元就会被舍弃。被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲产生任何影响；否则，就会按照普通的不透明物体的处理方式来处理它，即进行深度测试、深度写入等。也就是说，透明度测试是不需要关闭深度写入的，它和其他不透明物体最大的不同就是它会根据透明度来舍弃一些片元。虽然简单，但是它产生的效果也很极端，要么完全透明，即看不到，要么完全不透明，就像不透明物体那样。

* **透明度混合**：这种方法可以得到真正的半透明效果。它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。但是，透明度混合需要关闭深度写入，这使得我们要非常小心物体的渲染顺序。需要注意的是，透明度混合只关闭了深度写入，但没有关闭深度测试。这意味着，当使用透明度混合渲染一个片元时，还是会比较它的深度值与当前深度缓冲中的深度值，如果它的深度值距离摄像机更远，那么就不会再进行混合操作。这一点决定了，当一个不透明物体出现在一个透明物体的前面，而我们先渲染了不透明物体，它仍然可以正常地遮挡住透明物体。也就是说，对于透明度混合来说，深度缓冲是只读的。
  
## 为什么渲染顺序很重要 ##

使用透明度混合技术时，为什么要关闭深度写入呢？如果不关闭深度写入，一个半透明表面背后的表面本来是可以透过它被我们看到的，但由于深度测试时判断结果是该半透明表面距离摄像机更近，导致后面的表面将会被剔除，我们也就无法透过半透明表面看到后面的物体了。但是，我们由此就破坏了深度缓冲的工作机制，而这是一个**非常非常非常**糟糕的事情，尽管我们不得不这样做。关闭深度写入导致渲染顺序将变得非常重要。

我们来考虑最简单的情况。假设场景里有两个物体 A 和 B，如下图所示，其中 A 是半透明物体，而 B 是不透明物体。

![A半透明，B不透明](/posts_image/Transparent/Transparent_1.png "A半透明，B不透明")

我们来考虑不同的渲染顺序会有什么结果。

* 第一种情况，我们先渲染 B，再渲染 A。那么由于不透明物体开启了深度测试和深度检验，而此时深度缓冲中没有任何有效数据，因此 B 首先会写入颜色缓冲和深度缓冲。随后我们渲染 A，透明物体仍然会进行深度测试，因此我们发现和 B 相比，A 距离摄像机更近，因此，我们会使用 A 的透明度来和颜色缓冲中的 B 颜色进行混合，得到正确的半透明效果。

* 第二种情况，我们先渲染 A，再渲染 B。渲染 A 时，深度缓冲区中没有任何有效数据，因此 A 直接写入颜色缓冲，但由于对半透明物体关闭了深度写入，因此 A 不会修改深度缓冲。等到渲染 B 时，B 会进行深度测试，它发现深度缓存中还没有数据，那么它就写入颜色缓冲了，结果就是 B 会直接覆盖 A 的颜色。从视觉上来看，B 就出现在了 A 的前面，而这是错误的。

从这个例子可以看出，当关闭了深度写入后，渲染顺序多么重要。由此我们知道，我们应该在不透明物体渲染完之后再渲染半透明物体。如果都是半透明物体，渲染顺序依然重要。还是假设场景里有两个物体 A 和 B，如下图所示，其中 A 和 B 都是半透明物体。

![A、B都是半透明](/posts_image/Transparent/Transparent_2.png "A、B都是半透明")

我们还是考虑不同的渲染顺序有什么不同结果。

* 第一种情况，我们先渲染 B，再渲染 A。那么 B 会正常写入颜色缓冲，然后 A 会和颜色缓冲中的 B 颜色进行混合，得到正确的半透明效果。

* 第二种情况，我们先渲染 A，再渲染 B。那么 A 会先写入颜色缓冲，随后 B 会和颜色缓冲中的 A 进行混合，这样混合结果会完全反过来，看起来就好像 B 在 A 的前面，得到的就是错误的半透明结构。

从这个例子可以看出，半透明物体之间也是要符合一定的渲染顺序的。

