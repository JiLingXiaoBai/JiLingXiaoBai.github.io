---
title: 画线和画三角形方法
date: 2022-09-04 11:13:32
tags: Math
categories: Computer Graphics
math: true
---
## 画线算法

### DDA画线
直线方程表示为 $y = kx + b$

当 $\lVert k \rVert <= 1$时，$x$ 每递增$1$，$y$ 递增$k$。

![](/posts_image/DrawLineAndFace/DrawLineAndFace_1.png)

当 $\lVert k \rVert >= 1$时，$x$ 每递增$1/k$，$y$ 递增$1$。

![](/posts_image/DrawLineAndFace/DrawLineAndFace_2.png)

因为光栅化不能绘制半个像素点，所以求出的值需要进行四舍五入即加 0.5 后再进行取整。

![](/posts_image/DrawLineAndFace/DrawLineAndFace_3.png)

DDA 算法是一个增量算法，它直观且容易实现，然而 $x$ 和 $y$ 都必须用浮点值表示，而且每一步都需要对 $y$ 进行舍入取整，不利于硬件实现。

```csharp
void DrawLine_DDA(int x1,int y1,int x2,int y2){
    int dx = x2 - x1;
    int dy = y2 - y1;

    int step = 0;
    if(Math.Abs(dy) > Math.Abs(dx)){
        step = Math.Abs(dy);
    }
    else{
        step = Math.Abs(dx);
    }

    float stepX = 1.0f * dx / step;
    float stepY = 1.0f * dy / step;

    int i = 0;
    float x = x1;
    float y = y1;
    DrawPoint((int)x, (int)y);
    while ((i++)<step){
        x += stepX;
        y += stepY;
        DrawPoint((int)x, (int)(y+0.5f));
    }
}
```

### Bresenham画线

Bresenham 算法只用 int 类型的加减和比较来绘制直线，大大降低了需要的计算资源。

它的思路是：水平直线、竖直直线单独处理，剩余的部分等分为 8 个区域，然后从最简单的斜率大于 0 小于 1 的部分开始，剩下的 7 个部分稍作修改即可。

![](/posts_image/DrawLineAndFace/DrawLineAndFace_4.png)

当斜率大于 0 小于 1 时，起始点为 ($x_0$, $y_0$)，终点为 ($x_1$, $y_1$)，我们遍历横坐标，找出每个横坐标对应的纵坐标。$x_{0+i}$ 对应的纵坐标应该为 $y_0 + i \times slope$，四舍五入获得的像素坐标为：int($y_0 + i \times slope + 0.5$)

![](/posts_image/DrawLineAndFace/DrawLineAndFace_5.png)

由于斜率大于 0 小于 1，相邻横坐标对应的纵坐标最多加 1。比如 $x_{0+1}$ 处的纵坐标要么还是 $y_0$，要么是 $y_{0+1}$。绝不可能是 $y_{0+2}$

然而 Bresenham 算法是想避免 float 类型的运算和比较。以 $x_{0+1}$ 为例：

$1 \times slope < 0.5$ 则四舍，$1 \times slope >= 0.5$ 则五入。然而实际判断 $1 \times slope < 0.5$ 等价于 $2 \times slope < 1$，等价于 $2 \times \Delta y < \Delta x$，等价于 $2 \times \Delta y - \Delta x < 0$，这时则完全没有 float 类型计算和比较了。($\Delta y = y_1 - y_0, \Delta x = x_1 - x_0$)。

若 $2 \times \Delta y - \Delta x < 0$，则 $y(x_{0+1}) = y_0$，

![](/posts_image/DrawLineAndFace/DrawLineAndFace_6.png)

否则 $y(x_{0+1}) = y_{0+1}$

![](/posts_image/DrawLineAndFace/DrawLineAndFace_7.png)

接着再考虑 $x_{0+2}$ 处，

![](/posts_image/DrawLineAndFace/DrawLineAndFace_8.png)

若前一个像素自右上方衍生出，需要比较 $2 \times slope < 1.5$，等价于 $4 \times \Delta y - 3 \times \Delta x < 0$，注意 $4 \times \Delta y - 3 \times \Delta x = 2 \times \Delta y - \Delta x + (2 \times \Delta y - 2 \times \Delta x)$

若前一个像素自右方衍生出，需要比较 $2 \times slope < 0.5$，等价于 $4 \times \Delta y - \Delta x < 0$，注意 $4 \times \Delta y - \Delta x = 2 \times \Delta y - \Delta x + (2 \times \Delta y)$

同样的思路可以一直推下去直到线段的末尾。

![](/posts_image/DrawLineAndFace/DrawLineAndFace_9.png)

```csharp
public void DrawLine_Bresenham(int x0, int x1, int y0, int y1)
{
    bool steep = false;
    if(Math.Abs(x0 - x1) < Math.Abs(y0 - y1))
    {
        TempSwap(ref x0, ref y0);
        TempSwap(ref x1, ref y1);
        steep = true;
    }

    if(x0 > x1)
    {
        TempSwap(ref x0, ref x1);
        TempSwap(ref y0, ref y1);
    }

    int dx = x1 - x0;
    int dy = y1 - y0;

    int derror = Math.Abs(dy) * 2;
    int error = 0;
    int y = y0;

    for(int x = x0; x <= x1; x++)
    {
        if (steep)
        {
            DrawPoint(y, x);
        }
        else
        {
            DrawPoint(x, y);
        }

        error += derror;
        
        if (error > dx)
        {
            y += (y1 > y0 ? 1 : -1);
            error -= dx * 2;
        }
    }
}
```

### 中点画线

如下图

![](/posts_image/DrawLineAndFace/DrawLineAndFace_10.png)

其中，
$$
\begin{aligned}
P &= p_0 + (P_1 - P_0)t\\
&= P_0 - tP_0 + tP_1\\
&= (1 - t)P_0 + tP_1
\end{aligned}
$$

那么
$$
f(x) = (1 - t) \times f(x_0) + t \times f(x_1)
$$

直线隐函数方程为：
$$
F(x, y) = y - kx - b = 0
$$

![](/posts_image/DrawLineAndFace/DrawLineAndFace_11.png)

假设已经确定了要显示的点 ($x_i$, $y_i$)，那么需要确定下一个点绘制的位置，这里需要用到中点误差项。

$$
d_i = F(x_i + 1, y_i + 0.5) = y_i + 0.5 - k(x_i + 1) - b
$$

![](/posts_image/DrawLineAndFace/DrawLineAndFace_12.png)

$$
y_{i+1} = \begin{cases}
    y_i + 1, (d_i < 0)\\
    y_i,\quad(d_i >= 0)
\end{cases}
$$

当 $d_i < 0$ 时，
$$
\begin{aligned}
d_{i+1} &= F(x_i + 2, y_i + 1.5)\\
&= y_i + 1.5 - k(x_i + 2) - b\\
&= y_i + 0.5 - k(x_i + 1) - b + 1 - k\\
&= d_i + 1 - k 
\end{aligned}
$$

![](/posts_image/DrawLineAndFace/DrawLineAndFace_13.png)

当 $d_i >= 0$ 时，
$$
\begin{aligned}
d_{i+1} &= F(x_i + 2, y_i + 0.5)\\
&= y_i + 0.5 - k(x_i + 2) - b\\
&= y_i + 0.5 - k(x_i + 1) - b - k\\
&= d_i - k 
\end{aligned}
$$

![](/posts_image/DrawLineAndFace/DrawLineAndFace_14.png)

当 $d_i < 0$ 时，$d_{i+1} = d_i + 1 - k$，当 $d_i >= 0$ 时，$d_{i+1} = d_i - k$

中点误差项初始值为：
$$
\begin{aligned}
d_0 &= F(x_0 + 1, y_0 + 0.5)\\
&= y_0 + 0.5 - k(x_0 + 1) - b\\
&= y_0 - kx - b - k + 0.5\\
&= 0.5 - k 
\end{aligned}
$$

接下来，我们需要进行整数化处理：

令 $d$ 乘以 $2\Delta x$ 得到 $e$，误差项正负值不变，不会影响 $y$ 的增量
$$
e = 2d\Delta x
$$
此时误差项初始值为：
$$
e_0 = 2d_0\Delta x = 2(0.5 - k)\Delta x = \Delta x - 2\Delta y
$$

此时误差项的递推公式为：
$$
e < 0, e = 2(d + 1 - k)\Delta x = 2d\Delta x + 2\Delta x - 2k\Delta x = e + 2\Delta x - 2\Delta y\\
e >= 0, e = 2(d - k)\Delta x = 2d\Delta x - 2k\Delta x = e - 2\Delta y
$$

$$
e_{i+1} = \begin{cases}
    e_i + 2\Delta x - 2\Delta y, (e < 0)\\
    e_i - 2\Delta y,\quad(e >= 0)
\end{cases}
$$

那么此时进行画线操作，从 $P_0$ 开始到 $P_1$ 点沿 $x$ 轴方向，判断 $e$ 的符号来绘制点 ($x$, $y$)，若 $e < 0$，将点更新为 ($x+1$, $y+1$)，$e = e + 2\Delta x - 2\Delta y$；否则将点更新为 ($x+1$, $y$)，$e = e - 2\Delta y$

```csharp
void DrawLine_MidPoint(int x0,int y0,int x1,int y1)
{
    bool bInterchange = false;

	int dx = abs(x1 - x0);
    int dy = abs(y1 - y0);
    int signx = x0 < x1 ? 1: -1;
    int signy = y0 < y1 ? 1: -1;

    if(dy > dx){
        int temp = dy;
        dy = dx;
        dx = temp;
        bInterchange = true;
    }
	
    int e = dx - 2 * dy;
    int x = x0;
    int y = y0;
    for(int i = 1; i <= dx; i++){
        DrawPoint(x, y);
        if(bInterchange){
            y += signy;
        }else{
            x += signx;
        }

        if(e < 0){
            if(bInterchange){
                x += signx;
            }else{
                y += signy;
            }
            e += 2 * dx - 2 * dy;
        }else{
            e -= 2 * dy;
        }
    }
	 
}

```

## 画三角形方法

### 利用线性插值画三角形

让我们假设三角形的三个点 t0，t1, t2，通过 y 坐标的大小排序成升序。 那么，边界 A 在是 t0 和 t2 之间的线段，边界 B 是 t0 和 t1 之间线段，最后的在 t1 和 t2 之间的线段。以高度差作为循环控制变量，

### 利用叉乘画三角形



### 利用三角形重心画三角形