<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白的笔记本</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-05-30T12:26:43.668Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>祭零小白</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WorkFlow</title>
    <link href="http://example.com/posts/WorkFlow/"/>
    <id>http://example.com/posts/WorkFlow/</id>
    <published>2025-05-29T17:12:52.000Z</published>
    <updated>2025-05-30T12:26:43.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Upgrade-PowerShell">Upgrade PowerShell</h2><p>Execute the following command in PowerShell</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">winget search Microsoft.PowerShell<br></code></pre></td></tr></table></figure><p>get the output like this</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">Name               Id                           Version Source<br>---------------------------------------------------------------<br>PowerShell         Microsoft.PowerShell         7.5.1.0 winget<br>PowerShell Preview Microsoft.PowerShell.Preview 7.6.0.4 winget<br></code></pre></td></tr></table></figure><p>then execute the following command</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">winget install --<span class="hljs-built_in">id</span> Microsoft.PowerShell --<span class="hljs-built_in">source</span> winget<br></code></pre></td></tr></table></figure><p>or just goto <a href="https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows">official website</a> to get the latest version</p><h2 id="Scoop">Scoop</h2><p>Execute the following commands in PowerShell as Administrator</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser<br><br>Invoke-RestMethod -Uri https://get.scoop.sh | Invoke-Expression<br></code></pre></td></tr></table></figure><p>then install git with scoop</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">scoop install git<br></code></pre></td></tr></table></figure><p>setup git <a href="http://user.name">user.name</a> and user.email</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global user.name <span class="hljs-string">&quot;your name&quot;</span><br>git config --global user.email <span class="hljs-built_in">test</span>@youremail.com<br></code></pre></td></tr></table></figure><h2 id="Yazi">Yazi</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">scoop install ffmpeg 7zip jq poppler fd ripgrep fzf zoxide resvg imagemagick ghostscript yazi<br></code></pre></td></tr></table></figure><p>goto <code>C:\Users\&lt;Username&gt;\Documents\PowerShell\Microsoft.PowerShell_profile.ps1</code>, if  it doesn’t exist, create it</p><p>append the following lines to the file</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-keyword">function</span> y &#123;<br>    <span class="hljs-variable">$tmp</span> = [System.IO.Path]::GetTempFileName()<br>    yazi <span class="hljs-variable">$args</span> --cwd-file=<span class="hljs-string">&quot;<span class="hljs-variable">$tmp</span>&quot;</span><br>    <span class="hljs-variable">$cwd</span> = Get-Content -Path <span class="hljs-variable">$tmp</span> -Encoding UTF8<br>    <span class="hljs-keyword">if</span> (-not [String]::IsNullOrEmpty(<span class="hljs-variable">$cwd</span>) -and <span class="hljs-variable">$cwd</span> -ne <span class="hljs-variable">$PWD</span>.Path) &#123;<br>        Set-Location -LiteralPath ([System.IO.Path]::GetFullPath(<span class="hljs-variable">$cwd</span>))<br>    &#125;<br>    Remove-Item -Path <span class="hljs-variable">$tmp</span><br>&#125;<br></code></pre></td></tr></table></figure><p>goto <code>C:\Users\&lt;Username&gt;\AppData\Roaming\yazi\config\yazi.toml</code>, if  it doesn’t exist, create it</p><p>append the following lines to the file</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[manager]</span><br><span class="hljs-attr">show_hidden</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[opener]</span><br><span class="hljs-attr">edit</span> = [<br>&#123;run = <span class="hljs-string">&#x27;nvim %*&#x27;</span>, block = <span class="hljs-literal">true</span>, desc = <span class="hljs-string">&quot;nvim&quot;</span>, for = <span class="hljs-string">&quot;windows&quot;</span> &#125;,<br>]<br><br><span class="hljs-section">[open]</span><br><span class="hljs-attr">prepend_rules</span> = [<br>&#123; name = <span class="hljs-string">&quot;*.json&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>&#123; name = <span class="hljs-string">&quot;*.toml&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>&#123; name = <span class="hljs-string">&quot;*.html&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>&#123; name = <span class="hljs-string">&quot;*.c&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>&#123; name = <span class="hljs-string">&quot;*.cpp&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>&#123; name = <span class="hljs-string">&quot;*.h&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>&#123; name = <span class="hljs-string">&quot;*.cs&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>&#123; name = <span class="hljs-string">&quot;*.md&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>&#123; name = <span class="hljs-string">&quot;*.lua&quot;</span>, use = [ <span class="hljs-string">&quot;edit&quot;</span>, <span class="hljs-string">&quot;open&quot;</span> ] &#125;,<br>]<br><span class="hljs-attr">append_rules</span> = [<br>&#123; name = <span class="hljs-string">&quot;*&quot;</span>, use = [ <span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-string">&quot;reveal&quot;</span> ] &#125;,<br>]<br></code></pre></td></tr></table></figure><p>Yazi relies on <code>file(1)</code> to detect the mime-type of the file, and the easiest and most reliable way to get it on Windows<br>is to install Git for Windows and use the <code>file.exe</code> that comes with it.</p><ol><li>Install Git for Windows by running <a href="https://git-scm.com/downloads/win">the official installer</a>, or through your package manager of choice.</li><li>To allow Yazi to use <code>file(1)</code>, add &lt;Git_Installed_Directory&gt;\usr\bin\file.exe to your <code>YAZI_FILE_ONE</code> environment variable,<br>which differs depending on how you installed Git:</li></ol><ul><li>If you installed Git with the installer, it would be <code>C:\Program Files\Git\usr\bin\file.exe</code>.</li><li>If you installed Git with Scoop, it would be <code>C:\Users\&lt;Username&gt;\scoop\apps\git\current\usr\bin\file.exe</code>.</li></ul><ol start="3"><li>Restart your terminal.</li></ol><h2 id="Neovim">Neovim</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">scoop bucket add nerd-fonts<br>scoop install Hack-NF-Mono<br>scoop install make unzip gcc <br></code></pre></td></tr></table></figure><p>Goto <code>C:\Users\&lt;Username&gt;\AppData\Local</code>, clone the repo here</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/JiLingXiaoBai/nvim.git<br></code></pre></td></tr></table></figure><h2 id="Windows-Terminal">Windows Terminal</h2><p>Modify <code>settings.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;$help&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://aka.ms/terminal-documentation&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;$schema&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://aka.ms/terminal-profiles-schema&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;actions&quot;</span><span class="hljs-punctuation">:</span> <br>    <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;copy&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;singleLine&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User.copy.644BA8F2&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;paste&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User.paste&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;find&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User.find&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;splitPane&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;split&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;auto&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;splitMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;duplicate&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User.splitPane.A6751878&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;alwaysShowTabs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;copyFormatting&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;none&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;copyOnSelect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;defaultProfile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;&lt;your default profile&gt;&#125;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keybindings&quot;</span><span class="hljs-punctuation">:</span> <br>    <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User.copy.644BA8F2&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;keys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ctrl+c&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User.find&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;keys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ctrl+shift+f&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User.paste&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;keys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ctrl+v&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;User.splitPane.A6751878&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;keys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;alt+shift+d&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;newTabMenu&quot;</span><span class="hljs-punctuation">:</span> <br>    <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;remainingProfiles&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;profiles&quot;</span><span class="hljs-punctuation">:</span> <br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;defaults&quot;</span><span class="hljs-punctuation">:</span> <br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;colorScheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arcoiris&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cursorShape&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;filledBox&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;font&quot;</span><span class="hljs-punctuation">:</span> <br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;face&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Hack Nerd Font Mono&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;opacity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">37</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;padding&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;scrollbarState&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hidden&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;useAcrylic&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;list&quot;</span><span class="hljs-punctuation">:</span> <br>        <span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span>&lt;your profile lists&gt;<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;schemes&quot;</span><span class="hljs-punctuation">:</span> <br>    <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;background&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#201F1E&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;black&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#333333&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;blue&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#518BFC&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;brightBlack&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#777777&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;brightBlue&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#B3E8F3&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;brightCyan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#BCFFC7&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;brightGreen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#E3F6AA&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;brightPurple&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#CBBAF9&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;brightRed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#FFB9B9&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;brightWhite&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#EFEFEF&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;brightYellow&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#FFDDAA&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cursorColor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#4FBD04&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cyan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#63FAD5&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;foreground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#EEE4D9&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;green&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#12C258&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arcoiris&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;purple&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#E37BD9&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;red&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#DA2700&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;selectionBackground&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#25524A&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;white&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#BAB2B2&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;yellow&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;#FFC656&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;showTabsInTitlebar&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;theme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dark&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;themes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;useAcrylicInTabRow&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Upgrade-PowerShell&quot;&gt;Upgrade PowerShell&lt;/h2&gt;
&lt;p&gt;Execute the following command in PowerShell&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;</summary>
      
    
    
    
    <category term="Workflow" scheme="http://example.com/categories/Workflow/"/>
    
    
    <category term="Workflow" scheme="http://example.com/tags/Workflow/"/>
    
  </entry>
  
  <entry>
    <title>Delaunay-Triangulation</title>
    <link href="http://example.com/posts/Delaunay-Triangulation/"/>
    <id>http://example.com/posts/Delaunay-Triangulation/</id>
    <published>2025-04-18T02:41:24.000Z</published>
    <updated>2025-05-29T18:12:59.616Z</updated>
    
    <content type="html"><![CDATA[<h1>Delaunay 三角形化</h1><p>Delaunay三角形化，也叫Delaunay三角剖分，是一种三角剖分算法，它的作用是把一个平面上的点集，按照一定的规则，分成若干个三角形。这些三角形有以下特点：</p><ul><li>这些三角形互不重叠</li><li>这些三角形可以覆盖整个平面</li><li>每个点均不位于不包含该点的三角形的外接圆内（即：在某个三角形的外接圆内，只包含在外接圆上的三个点，不包含其他点）</li></ul><p>Delaunay 三角形化的优点：</p><ul><li>最小角的最大化（所形成的最小角是所有连接方式形成的最小角中的最大者）</li><li>生成的三角形边长的均匀性最好，最接近正三角形</li></ul><h2 id="Delaunay-三角形化方法">Delaunay 三角形化方法</h2><p><img src="/posts_image/DelaunayTriangulation/DelaunayTriangulation_1.png" alt=""></p><p>如上图所示的求解区域为例，1~5是边界点，6为内部点，其初始化 Delaunay 三角形的过程如下：</p><ol><li>包围该求解区域的各边界点做一个辅助正四边形及两个三角形 $\triangle{790}$，$\triangle{789}$，显然这两个三角形为 Delaunay 三角形；</li><li>首先考虑节点1，它位于$\triangle{790}$和$\triangle{789}$的外接圆内；</li><li>消去公共线79，连接点1与四个顶点（0，7，8，9）；</li><li>考虑点2，它位于$\triangle{178}$和$\triangle{189}$的外接圆内；</li><li>消去公共线18，连接点2与四个顶点（1，7，8，9）；</li><li>采用同样的方法依次考虑点3、4、5，最后形成图（f）所示情况，注意不一定位于两个外接圆内，可能更多，即公共线也更多</li></ol><p><img src="/posts_image/DelaunayTriangulation/DelaunayTriangulation_2.png" alt=""></p><ol start="7"><li>删除所有重心不在求解区域的三角形得到图（g）所示的初始化 Delaunay 三角形；</li><li>由于点6为内部点，它位于$\triangle{145}$、$\triangle{142}$ 和 $\triangle{234}$ 外接圆内，因此需要消去公共线14、24，连接点6与五个顶点（1，2，3，4，5）；</li></ol><h2 id="如何向求解区域内设点">如何向求解区域内设点</h2><p>为了能方便控制区域内点附近网格的疏密，引入两个几何参数</p><ol><li>长度标尺，长度标尺的大小代表边界上网格疏密的程度，网格点越稠密的地方，长度标尺越小，网格点越稀疏的地方，长度标尺越大；</li><li>三角形外接圆无量纲半径，判断三角形偏离正三角形的严重程度，$R(k)$越大偏离越严重，首先应该往$R(k)$较大的三角形中添加点以改善网格质量；</li></ol><h4 id="长度标尺">长度标尺</h4><p>长度标尺是赋予网格点的一个几何参数<br><img src="/posts_image/DelaunayTriangulation/DelaunayTriangulation_3.png" alt=""><br>边界网格点的长度标尺定义为：该点到边界上相邻两个边界网格点的距离的平均值的 $\sqrt{3}/2$ 倍；如点1的长度标尺为：(点1到点2的距离 + 点1到点5的距离)/2 * $\sqrt{3}/2$</p><p>内部网格点的长度标尺采用下列倒数原则，由边界网格点的长度标尺插值而得；设Q点是要插入到$\triangle{145}$中的一点，则：<br>$$<br>L(Q) = \frac{L(1)/l_1 + L(4)/l_4 + L(5)/l_5}{1/l_1 + 1/l_4 + 1/l_5}<br>$$<br>式中，$L(1)$，$L(4)$，$L(5)$ 分别为点1，点4，点5的长度标尺，$l_1$, $l_4$, $l_5$ 分别为点Q到点1，点4，点5的距离；</p><h4 id="三角形外接圆无量纲半径">三角形外接圆无量纲半径</h4><p>设任意一个 Delaunay 三角形为 $\triangle{k}$，其外接圆的半径为 $r(k)$，其外接圆的圆心长度标尺为 $L(k)$，则其外接圆无量纲半径 $R(k)$ 为：<br>$$<br>R(k) = \frac{r(k)}{L(k)}<br>$$<br>正三角形的外接圆无量纲半径最小，值为2/3</p><h4 id="步骤">步骤</h4><ol><li>计算所有已生成的 Delaunay 三角形的外接圆圆心的长度标尺 $L(k)$ 以及外接圆半径 $r(k)$；</li><li>计算所有三角形的外接圆无量纲半径 $R(k)$；</li><li>对所有现存三角形按 $R(k)$ 从大到小排序；</li><li>在 $R(k)$ 最大的三角形的外接圆圆心处添加新的点Q；</li><li>利用 Delaunay 三角形化方法，生成一组新的 Delaunay 三角形；</li><li>返回第一步，重复加点动作，直到满足要求；</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Delaunay 三角形化&lt;/h1&gt;
&lt;p&gt;Delaunay三角形化，也叫Delaunay三角剖分，是一种三角剖分算法，它的作用是把一个平面上的点集，按照一定的规则，分成若干个三角形。这些三角形有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这些三角形互不重叠&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Math" scheme="http://example.com/categories/Math/"/>
    
    
    <category term="Math" scheme="http://example.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>C# List&lt;T&gt;</title>
    <link href="http://example.com/posts/CSharpList/"/>
    <id>http://example.com/posts/CSharpList/</id>
    <published>2023-04-27T09:13:22.000Z</published>
    <updated>2025-04-17T12:55:15.930Z</updated>
    
    <content type="html"><![CDATA[<h1>List&lt;T&gt;</h1><p>泛型 List 在底层实现中是由数组来承载数据，所以又被称为“动态数组”。数组的大小即为容量(capacity)，可以手动或自动地调整。当容量不足时，会自动创建一个更长的数组，将原数组中的内容复制到新的数组中实现扩容。默认新创建的不含任何元素的 List 容量为 0，加入一个元素后容量为 4，容量不足时进行二倍扩容，即容量变为 8、16、32… 当 List 调用 Clear 方法后，其数组长度即容量不变。泛型 List 与非泛型的 ArrayList 相对应，后者元素都为 object 类型。</p><style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><div class="center"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Category</th><th style="text-align:left">Member</th></tr></thead><tbody><tr><td style="text-align:left">Create</td><td style="text-align:left">Constructor</td><td style="text-align:left">List&lt;T&gt;()</td></tr><tr><td style="text-align:left">Create</td><td style="text-align:left">Constructor</td><td style="text-align:left">List&lt;T&gt;(IEnumerable&lt;T&gt;)</td></tr><tr><td style="text-align:left">Create</td><td style="text-align:left">Constructor</td><td style="text-align:left">List&lt;T&gt;(Int32)</td></tr><tr><td style="text-align:left">Create</td><td style="text-align:left"></td><td style="text-align:left">Add(T)</td></tr><tr><td style="text-align:left">Create</td><td style="text-align:left"></td><td style="text-align:left">AddRange(IEnumerable&lt;T&gt;)</td></tr><tr><td style="text-align:left">Create</td><td style="text-align:left"></td><td style="text-align:left">Insert(Int32, T)</td></tr><tr><td style="text-align:left">Create</td><td style="text-align:left"></td><td style="text-align:left">InsertRange(Int32, IEnumerable&lt;T&gt;)</td></tr><tr><td style="text-align:left">Delete</td><td style="text-align:left"></td><td style="text-align:left">Clear()</td></tr><tr><td style="text-align:left">Delete</td><td style="text-align:left"></td><td style="text-align:left">RemoveAt(Int32)</td></tr><tr><td style="text-align:left">Delete</td><td style="text-align:left"></td><td style="text-align:left">RemoveRange(Int32, Int32)</td></tr><tr><td style="text-align:left">Delete</td><td style="text-align:left"></td><td style="text-align:left">Remove(T)</td></tr><tr><td style="text-align:left">Delete</td><td style="text-align:left"></td><td style="text-align:left">RemoveAll(Predicate&lt;T&gt;)</td></tr></tbody></table></div><ul><li>Add(T) 和 AddRange(IEnumerable&lt;T&gt;) 是在 List 最后添加新的元素。</li><li>Insert(Int32, T) 和 InsertRange(Int32, IEnumerable&lt;T&gt;) 是在指定位置插入元素，会造成被插入位置和其后的所有元素整体后移。</li><li>RemoveAt(Int32) 和 RemoveRange(Int32, Int32) 是移除指定位置的元素，会造成被移除元素位置之后的所有元素整体前移。</li><li>Remove(T) 是移除特定对象的第一个匹配项，RemoveAll(Predicate&lt;T&gt;) 的参数是一个参数为 T，返回值为 bool 类型的委托，它会移除与指定的委托所定义的条件相匹配的所有元素。也会造成被移除元素位置之后的所有元素整体前移。</li></ul><div class="center"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Category</th><th style="text-align:left">Member</th></tr></thead><tbody><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">Count</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">Capacity</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">Item[Int32]</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">GetRange(Int32, Int32)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left">Iterate</td><td style="text-align:left">GetEnumerator()</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left">Iterate</td><td style="text-align:left">ForEach(Action&lt;T&gt;)</td></tr></tbody></table></div><ul><li>Count 是当前列表中元素的个数，Capacity 是列表容量，即数组的长度，Item[Int32] 是索引器，即可以使用数组下标访问元素。</li><li>GetRange(Int32, Int32) 参数分别为起始索引和终止索引，将当前列表中从起始索引到终止索引的元素加入子列表，将子列表返回。</li><li>GetEnumerator() 拿到迭代器，调用返回值为 bool 类型的 MoveNext() 方法进行遍历，迭代器的指针默认指向的并不是 list 中的第一个元素，而是第一个元素之前的位置，遍历所有元素后会指向 list 之外的位置，所以遍历 list 最好使用 foreach。</li><li>使用 foreach 进行遍历时不可以添加或者删除元素，可以修改元素内部的属性值，但是不可以修改元素本身的值。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;&#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">400</span>&#125;;<br><span class="hljs-keyword">var</span> e = intList.GetEnumerator();<br>Console.WriteLine(e.Current);<br><span class="hljs-keyword">while</span>(e.MoveNext())&#123;<br>    Console.WriteLine(e.Current);<br>&#125;<br>Console.WriteLine(e.Current);<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//100</span><br><span class="hljs-comment">//200</span><br><span class="hljs-comment">//300</span><br><span class="hljs-comment">//400</span><br><span class="hljs-comment">//0</span><br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">var</span> val <span class="hljs-keyword">in</span> intList)&#123;<br>    Console.WriteLine(val);<br>    <span class="hljs-comment">//val++; //invalid 不可以修改元素本身的值</span><br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//100</span><br><span class="hljs-comment">//200</span><br><span class="hljs-comment">//300</span><br><span class="hljs-comment">//400</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id&#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name&#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> Price&#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;<br>&#125;<br>List&lt;Book&gt; bookList = <span class="hljs-keyword">new</span> List&lt;Book&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++;)<br>    bookList.Add(<span class="hljs-keyword">new</span> Book&#123;Id = i, Name = <span class="hljs-string">$&quot;Book-<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>, Price = <span class="hljs-number">10</span> * i&#125;);<br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">var</span> val <span class="hljs-keyword">in</span> bookList)&#123;<br>    val.Price++; <span class="hljs-comment">//valid 可以修改元素的属性的值 </span><br>&#125;<br></code></pre></td></tr></table></figure><div class="center"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Category</th><th style="text-align:left">Member</th></tr></thead><tbody><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">Contains(T)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">Exists(Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">TrueForAll(Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">IndexOf(T)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">IndexOf(T, Int32)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">IndexOf(T, Int32, Int32)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">LastIndexOf(T)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">LastIndexOf(T, Int32)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">LastIndexOf(T, Int32, Int32)</td></tr></tbody></table></div><ul><li>Contains(T) 确定某元素是否在列表中，返回一个 bool 值，如果 T 是引用类型，那么参数可以为 null。这里判断相等的方法是调用底层的 Equals 方法，我们可以重写 Equals 方法来改变判断的结果，从而影响 Contains 方法返回的值。</li><li>Exists(Predicate&lt;T&gt;) 确定是否含有与指定的委托所定义的条件相匹配的元素。</li><li>TrueForAll(Predicate&lt;T&gt;) 确定所有元素是否与指定的委托所定义的条件相匹配。</li><li>IndexOf(T) 返回整个列表中第一个与参数相等的元素的从零开始的索引。IndexOf(T, Int32) 返回整个列表中第一个与参数相等的元素的从指定位置开始的索引。IndexOf(T, Int32, Int32) 第二个参数为搜索开始的索引，第三个参数为要搜索的索引数。IndexOf(Item, 2, 3) 即表示从索引为 2 的位置开始向后搜索三个元素，并返回第一个与 Item 相等的元素的索引值。如果没有相等的元素，那么返回 -1，这里判断相等的方法也是调用底层的 Equals 方法。</li><li>LastIndexOf 方法和 IndexOf 方法相似，区别是 IndexOf 方法是从前往后找，LastIndexOf 方法是从后往前找。</li></ul><div class="center"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Category</th><th style="text-align:left">Member</th></tr></thead><tbody><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">Find(Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">FindLast(Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">FindAll(Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">FindIndex(Int32, Int32, Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">FindIndex(Int32, Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">FindIndex(Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">FindLastIndex(Int32, Int32, Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">FindLastIndex(Int32, Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left"></td><td style="text-align:left">FindLastIndex(Predicate&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left">Algorithm</td><td style="text-align:left">BinarySearch(Int32, Int32, T, IComparer&lt;T&gt;)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left">Algorithm</td><td style="text-align:left">BinarySearch(T)</td></tr><tr><td style="text-align:left">Read</td><td style="text-align:left">Algorithm</td><td style="text-align:left">BinarySearch(T, IComparer&lt;T&gt;)</td></tr></tbody></table></div><ul><li>Find(Predicate&lt;T&gt;) 方法返回与指定的委托所定义的条件相匹配的元素，如果没有相匹配的元素，则返回类型 T 的默认值。</li><li>FindLast(Predicate&lt;T&gt;) 与 Find(Predicate&lt;T&gt;) 相似，区别是 Find 方法是从前往后找，FindLast 方法是从后往前找。</li><li>FindAll(Predicate&lt;T&gt;) 方法返回一个新的列表，其元素为与指定的委托所定义的条件相匹配的所有元素。</li><li>FindIndex(Int32, Int32, Predicate&lt;T&gt;) 搜索与指定委托所定义的条件相匹配的一个元素，并返回列表中从指定的索引开始、包含指定元素个数的元素范围内第一个匹配项的从零开始的索引。</li><li>FindIndex(Int32, Predicate&lt;T&gt;) 搜索与指定委托所定义的条件相匹配的元素，并返回列表中从指定索引到最后一个元素的元素范围内第一个匹配项的从零开始的索引。</li><li>FindIndex(Predicate&lt;T&gt;) 搜索与指定委托所定义的条件相匹配的元素，并返回整个列表中第一个匹配元素的从零开始的索引。</li><li>FindLastIndex 方法与 FindIndex 方法相似，区别是 FindIndex 方法是从前往后找，FindLastIndex 方法是从后往前找。</li><li>BinarySearch 二分查找，调用者需为有序列表，即二分查找前要么使用 Sort() 方法排序，这时排序的对象需要实现 IComparable 泛型接口，即实现 CompareTo 方法；要么使用带 IComparer&lt;T&gt; 参数的重载，使用此比较器进行排序。而二分查找时需调用底层的 Equals 方法来判定是否相等。BinarySearch 方法返回的是已经排好序的列表中相等元素的索引值。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;List&amp;lt;T&amp;gt;&lt;/h1&gt;
&lt;p&gt;泛型 List 在底层实现中是由数组来承载数据，所以又被称为“动态数组”。数组的大小即为容量(capacity)，可以手动或自动地调整。当容量不足时，会自动创建一个更长的数组，将原数组中的内容复制到新的数组中实现扩容。默认新创建</summary>
      
    
    
    
    <category term="Languages" scheme="http://example.com/categories/Languages/"/>
    
    
    <category term="CSharp" scheme="http://example.com/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>C# 模式匹配、析构元组和弃元</title>
    <link href="http://example.com/posts/CSharp%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-%E6%9E%90%E6%9E%84%E5%85%83%E7%BB%84-%E5%BC%83%E5%85%83/"/>
    <id>http://example.com/posts/CSharp%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-%E6%9E%90%E6%9E%84%E5%85%83%E7%BB%84-%E5%BC%83%E5%85%83/</id>
    <published>2023-04-26T02:24:57.000Z</published>
    <updated>2025-04-17T12:55:15.930Z</updated>
    
    <content type="html"><![CDATA[<h1>模式匹配</h1><p>“模式匹配”是一种测试表达式是否具有特定特征的方法。 C# 模式匹配提供更简洁的语法，用于测试表达式并在表达式匹配时采取措施。 “is 表达式”目前支持通过模式匹配测试表达式并有条件地声明该表达式结果。 “switch 表达式”允许你根据表达式的首次匹配模式执行操作。 这两个表达式支持丰富的模式词汇。</p><h2 id="Null-检查">Null 检查</h2><p>模式匹配最常见的方案之一是确保值不是 null。 使用以下示例进行 null 测试时，可以测试可为 null 的值类型并将其转换为其基础类型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span>? maybe = <span class="hljs-number">12</span>;<br><br><span class="hljs-keyword">if</span> (maybe <span class="hljs-keyword">is</span> <span class="hljs-built_in">int</span> number)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">$&quot;The nullable int &#x27;maybe&#x27; has the value <span class="hljs-subst">&#123;number&#125;</span>&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The nullable int &#x27;maybe&#x27; doesn&#x27;t hold a value&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>只判断是否为 null 值可以使用 not 模式</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span>? message = <span class="hljs-string">&quot;This is not the null string&quot;</span>;<br><br><span class="hljs-keyword">if</span> (message <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>)<br>&#123;<br>    Console.WriteLine(message);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类型测试">类型测试</h2><p>以下代码测试实现 IEnumerable 泛型接口的参数是否为 null 值，如果不是 null 值那么测试它是否也实现了 IList 泛型接口，并根据是否实现 IList 接口来查找中间索引。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">MidPoint</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">IEnumerable&lt;T&gt; sequence</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (sequence <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(sequence), <span class="hljs-string">&quot;Sequence can&#x27;t be null.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sequence <span class="hljs-keyword">is</span> IList&lt;T&gt; list)<br>    &#123;<br>        <span class="hljs-keyword">return</span> list[list.Count / <span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> halfLength = sequence.Count() / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (halfLength &lt; <span class="hljs-number">0</span>) halfLength = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> sequence.Skip(halfLength).First();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="比较离散值">比较离散值</h2><p>可以代替 switch 来对枚举中声明的所有可能值进行数值测试：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> State<br>&#123;<br>    Run,<br>    Idle,<br>    Jump<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">PerformState</span>(<span class="hljs-params">State state</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> state <span class="hljs-keyword">switch</span><br>    &#123;<br>        State.Idle =&gt; <span class="hljs-string">&quot;Idle&quot;</span>,<br>        State.Run =&gt; <span class="hljs-string">&quot;Run&quot;</span>,<br>        State.Jump =&gt; <span class="hljs-string">&quot;Jump&quot;</span>,<br>        _ =&gt; <span class="hljs-string">&quot;Invalid enum value for State&quot;</span><br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>_ 案例为与所有数值匹配的弃元模式。 它处理值与定义的 enum 值之一不匹配的任何错误条件。</p><div class="note note-warning">            <p>switch表达式是输出语句！</p>          </div><h2 id="关系模式">关系模式</h2><p>你可以使用关系模式测试如何将数值与常量进行比较。 例如，以下代码基于华氏温度返回水源状态：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">WaterState</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> tempInFahrenheit</span>)</span> =&gt;<br>    tempInFahrenheit <span class="hljs-keyword">switch</span><br>    &#123;<br>        (&gt; <span class="hljs-number">32</span>) <span class="hljs-keyword">and</span> (&lt; <span class="hljs-number">212</span>) =&gt; <span class="hljs-string">&quot;liquid&quot;</span>,<br>        &lt; <span class="hljs-number">32</span> =&gt; <span class="hljs-string">&quot;solid&quot;</span>,<br>        &gt; <span class="hljs-number">212</span> =&gt; <span class="hljs-string">&quot;gas&quot;</span>,<br>        <span class="hljs-number">32</span> =&gt; <span class="hljs-string">&quot;solid/liquid transition&quot;</span>,<br>        <span class="hljs-number">212</span> =&gt; <span class="hljs-string">&quot;liquid / gas transition&quot;</span>,<br>    &#125;;<br></code></pre></td></tr></table></figure><h2 id="多个输入">多个输入</h2><p>可以写入检查一个对象的多个属性的模式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Items;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Cost;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">decimal</span> <span class="hljs-title">CalculateDiscount</span>(<span class="hljs-params">Order order</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> order <span class="hljs-keyword">switch</span><br>    &#123;<br>        &#123; Items: &gt; <span class="hljs-number">10</span>, Cost: &gt; <span class="hljs-number">1000.00</span>m &#125; =&gt; <span class="hljs-number">0.10</span>m,<br>        &#123; Items: &gt; <span class="hljs-number">5</span>, Cost: &gt; <span class="hljs-number">500.00</span>m &#125; =&gt; <span class="hljs-number">0.05</span>m,<br>        &#123; Cost: &gt; <span class="hljs-number">250.00</span>m &#125; =&gt; <span class="hljs-number">0.02</span>m,<br>        <span class="hljs-literal">null</span> =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(order), <span class="hljs-string">&quot;Can&#x27;t calculate discount on null order&quot;</span>),<br>        <span class="hljs-keyword">var</span> someObject =&gt; <span class="hljs-number">0</span>m,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="列表模式">列表模式</h2><p>可以使用列表模式检查列表或数组中的元素。 列表模式提供了一种方法，将模式应用于序列的任何元素。 此外，还可以应用弃元模式 (_) 来匹配任何元素，或者应用切片模式来匹配零个或多个元素。</p><p>当数据不遵循常规结构时，列表模式是一个有价值的工具。 可以使用模式匹配来测试数据的形状和值，而不是将其转换为一组对象。</p><p>看看下面的内容，它摘录自一个包含银行交易信息的文本文件：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">04</span>-<span class="hljs-number">01</span>-<span class="hljs-number">2020</span>, DEPOSIT,    Initial deposit,            <span class="hljs-number">2250</span>.<span class="hljs-number">00</span><br><span class="hljs-attribute">04</span>-<span class="hljs-number">15</span>-<span class="hljs-number">2020</span>, DEPOSIT,    Refund,                      <span class="hljs-number">125</span>.<span class="hljs-number">65</span><br><span class="hljs-attribute">04</span>-<span class="hljs-number">18</span>-<span class="hljs-number">2020</span>, DEPOSIT,    Paycheck,                    <span class="hljs-number">825</span>.<span class="hljs-number">65</span><br><span class="hljs-attribute">04</span>-<span class="hljs-number">22</span>-<span class="hljs-number">2020</span>, WITHDRAWAL, Debit,           Groceries,  <span class="hljs-number">255</span>.<span class="hljs-number">73</span><br><span class="hljs-attribute">05</span>-<span class="hljs-number">01</span>-<span class="hljs-number">2020</span>, WITHDRAWAL, #<span class="hljs-number">1102</span>,           Rent, apt, <span class="hljs-number">2100</span>.<span class="hljs-number">00</span><br><span class="hljs-attribute">05</span>-<span class="hljs-number">02</span>-<span class="hljs-number">2020</span>, INTEREST,                                  <span class="hljs-number">0</span>.<span class="hljs-number">65</span><br><span class="hljs-attribute">05</span>-<span class="hljs-number">07</span>-<span class="hljs-number">2020</span>, WITHDRAWAL, Debit,           Movies,      <span class="hljs-number">12</span>.<span class="hljs-number">57</span><br><span class="hljs-attribute">04</span>-<span class="hljs-number">15</span>-<span class="hljs-number">2020</span>, FEE,                                       <span class="hljs-number">5</span>.<span class="hljs-number">55</span><br></code></pre></td></tr></table></figure><p>它是 CSV 格式，但某些行的列数比其他行要多。 对处理来说更糟糕的是，WITHDRAWAL 类型中的一列具有用户生成的文本，并且可以在文本中包含逗号。 一个包含弃元模式、常量模式和 var 模式的列表模式用于捕获这种格式的值处理数据：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">decimal</span> balance = <span class="hljs-number">0</span>m;<br><span class="hljs-keyword">foreach</span> (<span class="hljs-function"><span class="hljs-built_in">string</span>[] transaction <span class="hljs-keyword">in</span> <span class="hljs-title">ReadRecords</span>())</span><br>&#123;<br>    balance += transaction <span class="hljs-keyword">switch</span><br>    &#123;<br>        [<span class="hljs-meta">_, <span class="hljs-string">&quot;DEPOSIT&quot;</span>, _, var amount</span>]     =&gt; <span class="hljs-built_in">decimal</span>.Parse(amount),<br>        [<span class="hljs-meta">_, <span class="hljs-string">&quot;WITHDRAWAL&quot;</span>, .., var amount</span>] =&gt; -<span class="hljs-built_in">decimal</span>.Parse(amount),<br>        [<span class="hljs-meta">_, <span class="hljs-string">&quot;INTEREST&quot;</span>, var amount</span>]       =&gt; <span class="hljs-built_in">decimal</span>.Parse(amount),<br>        [<span class="hljs-meta">_, <span class="hljs-string">&quot;FEE&quot;</span>, var fee</span>]               =&gt; -<span class="hljs-built_in">decimal</span>.Parse(fee),<br>        _                                 =&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(<span class="hljs-string">$&quot;Record <span class="hljs-subst">&#123;<span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot;, &quot;</span>, transaction)&#125;</span> is not in the expected format!&quot;</span>),<br>    &#125;;<br>    Console.WriteLine(<span class="hljs-string">$&quot;Record: <span class="hljs-subst">&#123;<span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot;, &quot;</span>, transaction)&#125;</span>, New balance: <span class="hljs-subst">&#123;balance:C&#125;</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>前面的示例采用了字符串数组，其中每个元素都是行中的一个字段。 第二个字段的 switch 表达式键，用于确定交易的类型和剩余列数。 每一行都确保数据的格式正确。 弃元模式 (_) 跳过第一个字段，以及交易的日期。 第二个字段与交易的类型匹配。 其余元素匹配跳过包含金额的字段。 最终匹配使用 var 模式来捕获金额的字符串表示形式。 表达式计算要从余额中加上或减去的金额。</p><h1>析构元组</h1><h2 id="元组">元组</h2><p>元组提供一种从方法调用中检索多个值的轻量级方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> (<span class="hljs-params"><span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">double</span></span>) <span class="hljs-title">QueryCityData</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (name == <span class="hljs-string">&quot;New York City&quot;</span>)<br>            <span class="hljs-keyword">return</span> (name, <span class="hljs-number">8175133</span>, <span class="hljs-number">468.48</span>);<br><br>        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> result = QueryCityData(<span class="hljs-string">&quot;New York City&quot;</span>);<br><br>        <span class="hljs-comment">//一旦检索到元组，就必须处理它的各个元素。 按元素逐个操作比较麻烦</span><br>        <span class="hljs-keyword">var</span> city1 = result.Item1;<br>        <span class="hljs-keyword">var</span> pop1 = result.Item2;<br>        <span class="hljs-keyword">var</span> size1 = result.Item3;<br><br>        <span class="hljs-comment">//可以在括号内显式声明每个字段的类型。</span><br>        (<span class="hljs-built_in">string</span> city2, <span class="hljs-built_in">int</span> population2, <span class="hljs-built_in">double</span> area2) = QueryCityData(<span class="hljs-string">&quot;New York City&quot;</span>);<br>         <br>        <span class="hljs-comment">//可使用 var 关键字，以便 C# 推断每个变量的类型。 将 var 关键字放在括号外。</span><br>        <span class="hljs-keyword">var</span> (city3, population3, area3) = QueryCityData(<span class="hljs-string">&quot;New York City&quot;</span>);<br><br>        <span class="hljs-comment">//还可在括号内将 var 关键字单独与任一或全部变量声明结合使用。</span><br>        (<span class="hljs-built_in">string</span> city4, <span class="hljs-keyword">var</span> population4, <span class="hljs-keyword">var</span> area4) = QueryCityData(<span class="hljs-string">&quot;New York City&quot;</span>);<br><br>        <span class="hljs-comment">//可将元组析构到已声明的变量中。</span><br>        <span class="hljs-built_in">string</span> city5 = <span class="hljs-string">&quot;Raleigh&quot;</span>;<br>        <span class="hljs-built_in">int</span> population5 = <span class="hljs-number">458880</span>;<br>        <span class="hljs-built_in">double</span> area5 = <span class="hljs-number">144.8</span>;<br><br>        (city5, population5, area5) = QueryCityData(<span class="hljs-string">&quot;New York City&quot;</span>);<br><br>        <span class="hljs-comment">//从 C# 10 开始，可在析构中混合使用变量声明和赋值。</span><br>        <span class="hljs-built_in">string</span> city = <span class="hljs-string">&quot;Raleigh&quot;</span>;<br>        <span class="hljs-built_in">int</span> population = <span class="hljs-number">458880</span>;<br><br>        (city, population, <span class="hljs-built_in">double</span> area) = QueryCityData(<span class="hljs-string">&quot;New York City&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用弃元的元组元素">使用弃元的元组元素</h2><p>析构元组时，通常只需要关注某些元素的值。 可以利用 C# 对弃元的支持，弃元是一种仅能写入的变量，且其值将被忽略。 在赋值中，通过下划线字符 (_) 指定弃元。 可弃元任意数量的值，且均由单个弃元 _ 表示。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> (_, _, area3) = QueryCityData(<span class="hljs-string">&quot;New York City&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="用户定义类型">用户定义类型</h2><p>用户作为类、结构或接口的创建者，可通过实现一个或多个 Deconstruct 方法来析构该类型的实例。 该方法返回 void，且要析构的每个值由方法签名中的 out 参数指示。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> MiddleName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> City &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> State &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> fname, <span class="hljs-built_in">string</span> mname, <span class="hljs-built_in">string</span> lname,</span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-built_in">string</span> cityName, <span class="hljs-built_in">string</span> stateName</span>)</span><br>    &#123;<br>        FirstName = fname;<br>        MiddleName = mname;<br>        LastName = lname;<br>        City = cityName;<br>        State = stateName;<br>    &#125;<br><br>    <span class="hljs-comment">// Return the first and last name.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deconstruct</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> fname, <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> lname</span>)</span><br>    &#123;<br>        fname = FirstName;<br>        lname = LastName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deconstruct</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> fname, <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> mname, <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> lname</span>)</span><br>    &#123;<br>        fname = FirstName;<br>        mname = MiddleName;<br>        lname = LastName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deconstruct</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> fname, <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> lname,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> city, <span class="hljs-keyword">out</span> <span class="hljs-built_in">string</span> state</span>)</span><br>    &#123;<br>        fname = FirstName;<br>        lname = LastName;<br>        city = City;<br>        state = State;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExampleClassDeconstruction</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Quincy&quot;</span>, <span class="hljs-string">&quot;Adams&quot;</span>, <span class="hljs-string">&quot;Boston&quot;</span>, <span class="hljs-string">&quot;MA&quot;</span>);<br><br>        <span class="hljs-comment">// Deconstruct the person object.</span><br>        <span class="hljs-keyword">var</span> (fName, lName, city, state) = p;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Hello <span class="hljs-subst">&#123;fName&#125;</span> <span class="hljs-subst">&#123;lName&#125;</span> of <span class="hljs-subst">&#123;city&#125;</span>, <span class="hljs-subst">&#123;state&#125;</span>!&quot;</span>);<br><br><br>        <span class="hljs-keyword">var</span> (fName2, _, city2, _) = p;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Hello <span class="hljs-subst">&#123;fName2&#125;</span> of <span class="hljs-subst">&#123;city2&#125;</span>!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>弃元</h1><p>可使用独立弃元来指示要忽略的任何变量。 一种典型的用法是使用赋值来确保一个参数不为 null。 下面的代码使用弃元来强制赋值。 赋值的右侧使用 Null 合并操作符，用于在参数为 null 时引发 System.ArgumentNullException。 此代码不需要赋值结果，因此将对其使用弃元。 该表达式强制执行 null 检查。 弃元说明你的意图：不需要或不使用赋值结果。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> arg</span>)</span><br>&#123;<br>    _ = arg ?? <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(paramName: <span class="hljs-keyword">nameof</span>(arg), message: <span class="hljs-string">&quot;arg can&#x27;t be null&quot;</span>);<br><br>    <span class="hljs-comment">// Do work with arg.</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><code>?? 操作符和 ??= 操作符</code></p><p>如果左操作数的值不为 null，则 null 合并运算符 ?? 返回该值；否则，它会计算右操作数并返回其结果。 如果左操作数的计算结果为非 null，则 ?? 运算符不会计算其右操作数。 仅当左操作数的计算结果为 null 时，Null 合并赋值运算符 ??= 才会将其右操作数的值赋值给其左操作数。 如果左操作数的计算结果为非 null，则 ??= 运算符不会计算其右操作数。</p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;模式匹配&lt;/h1&gt;
&lt;p&gt;“模式匹配”是一种测试表达式是否具有特定特征的方法。 C# 模式匹配提供更简洁的语法，用于测试表达式并在表达式匹配时采取措施。 “is 表达式”目前支持通过模式匹配测试表达式并有条件地声明该表达式结果。 “switch 表达式”允许你根据表达式的</summary>
      
    
    
    
    <category term="Languages" scheme="http://example.com/categories/Languages/"/>
    
    
    <category term="CSharp" scheme="http://example.com/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>C# 类和接口</title>
    <link href="http://example.com/posts/CSharp%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>http://example.com/posts/CSharp%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</id>
    <published>2023-04-24T07:30:32.000Z</published>
    <updated>2025-04-17T12:55:15.930Z</updated>
    
    <content type="html"><![CDATA[<h1>类(Class)</h1><h2 id="什么是类">什么是类</h2><ul><li><p>一种数据结构</p></li><li><p>一种数据类型</p></li><li><p>代表现实世界中的种类</p></li></ul><h2 id="构造函数和析构函数">构造函数和析构函数</h2><h3 id="构造函数">构造函数</h3><p>public ClassName(){}<br>在被new实例化时自动调用此构造器</p><p>private ClassName(){}<br>用于防止类被new ClassName()实例化</p><p>static ClassName(){}<br>只用于构造静态成员，不能用于构造实例成员</p><h3 id="析构函数">析构函数</h3><p>~ClassName(){}<br>在被GC回收托管资源时调用此析构器</p><h2 id="抽象类">抽象类</h2><ul><li><p>不能被实例化，但是有构造函数</p></li><li><p>抽象成员必须包含在抽象类中</p></li><li><p>抽象类除了抽象成员外，还可以包含别的成员(不用关键字 abstract)</p></li><li><p>子类继承抽象父类后，必须把父类中所有抽象成员都重写(非抽象成员不必重写)。除非子类也是个抽象类</p></li><li><p>抽象成员的访问修饰符不能是private</p></li><li><p>abstract关键字不能用于字段成员，但是可以用于属性</p></li><li><p>abstract关键字用于方法时，方法不能定义主体</p></li><li><p>抽象类也可实现接口，但要将接口的成员用abstract修饰</p></li></ul><h2 id="修饰符">修饰符</h2><h3 id="访问限制">访问限制</h3><ul><li><p>private：访问级别为类的成员，不能直接修饰类，仅当该类是其他类的成员的时候可以修饰。</p></li><li><p>public：访问没有限制，所有的本程序集以及其他的程序集都能够访问。</p></li><li><p>internal：本程序集内的成员可以访问，是默认的访问级别。</p></li></ul><h3 id="继承相关">继承相关</h3><ul><li><p>sealed：封闭类，修饰类时表示该类不能够被继承。</p></li><li><p>protected：类的访问级别被限制在类成员之间，例如当父类成员被protect修饰，子类成员可以访问，其他类不能访问。可以跨程序集。</p></li><li><p>abstract：修饰类的时候表示该类为抽象类，不能创建该类的实例。修饰方法的时候表示该方法需要由子类来实现，如果子类没有实现该方法那么子类同样是抽象类；且含有抽象方法的类一定是抽象类。</p></li><li><p>new：只能用于嵌套的类，表示对继承父类同名类型的隐藏。</p></li></ul><h3 id="其他">其他</h3><ul><li><p>static：修饰类时表示该类为静态类，不能实例化该类的对象，这个类也不能含有对象成员，即该类的所有成员为静态。</p></li><li><p>partial：部分类，可以将一个类分成几部分写在不同的文件中，最终编译时将合并成一个文件，且各个部分不能分散在不同程序集中。</p></li></ul><h2 id="其他补充">其他补充</h2><ul><li>父类构造器不能直接被子类全盘继承，调用时先调用父类的构造器再调用子类的构造器</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vehicle</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> owner</span>)</span>&#123;<br>        <span class="hljs-keyword">this</span>.Owner = owner;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Owner &#123;<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> : <span class="hljs-title">Vehicle</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> owner</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">owner</span>)</span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowOwner</span>()</span>&#123;<br>        Console.WriteLine(Owner);<br>    &#125;<br>&#125;<br>\\<span class="hljs-keyword">new</span> 一个新 Car 对象时先执行 Vehicle 的构造函数，再执行 Car 的构造函数<br></code></pre></td></tr></table></figure><ul><li><p>子类的访问级别不能超越父类的访问级别</p></li><li><p>父类中的虚函数(virtual)可以有方法体，被子类继承后可以重写(override)。而抽象(abstract)方法无函数体，含有抽象方法的类一定是抽象类，继承抽象类的子类必须把抽象父类中的所有抽象方法都重写，除非子类也是个抽象类。</p></li><li><p>不通过构造器创建实例的方法：</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Type t = <span class="hljs-keyword">typeof</span>(ClassName);<br><span class="hljs-built_in">object</span> o = Activator.CreateInstance(t);<br>ClassName className = o <span class="hljs-keyword">as</span> ClassName;<br></code></pre></td></tr></table></figure><h1>接口(Interface)</h1><ul><li><p>接口中只能包含方法(方法、属性、索引器、事件)，且接口中的方法不能有任何实现。</p></li><li><p>接口中的成员不能有任何访问修饰符，默认为public的</p></li><li><p>接口不能被实例化</p></li><li><p>实现接口的类，必须实现接口的所有成员，而且没有 override 关键字。</p></li><li><p>一个接口可以继承多个接口</p></li><li><p>一个类可以实现多个接口，但是只能继承一个类</p></li><li><p>如果一个类同时继承了父类并实现接口的时候，要把父类写在最前面</p></li><li><p>当父类实现了接口，子类继承父类后，则可以使用接口引用子类</p></li><li><p>接口方法的显示实现：如果多个接口里有相同的方法名，那么第一个方法名默认的引用的是排在最前面的接口，如果要使用后面接口的方法，就要显示实现：接口名.方法名。访问修饰符是private</p></li></ul><h1>其他</h1><ul><li><p>结构体可以实现接口，但是不能继承其他类或者其他结构体；结构体不能有显式的无参构造器，但是可以有显式的有参构造器。</p></li><li><p>枚举成员默认类型是 int 类型，通过继承可以声明枚举成员为其他类型，枚举类型一定是继承自 byte、sbyte、short、ushort、int、uint、long 和 ulong 中的一种，不能是其它类型。比如：</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Days : <span class="hljs-built_in">byte</span><br>&#123;<br>    Monday = <span class="hljs-number">1</span>,<br>    Tuesday = <span class="hljs-number">2</span>,<br>    Wednesday = <span class="hljs-number">3</span>,<br>    Thursday = <span class="hljs-number">4</span>,<br>    Friday = <span class="hljs-number">5</span>,<br>    Saturday = <span class="hljs-number">6</span>,<br>    Sunday = <span class="hljs-number">7</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>枚举成员如果没有手动指定成员的值的话，就是一个从 0 开始，步长为 1 的等差数列，即 1，2，3，4，5…</p></li><li><p>枚举成员如果被手动赋值的话，那么被赋值的成员的值即为所指定的值，但是其递增步长不会变，总是为 1：</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> DriveType : <span class="hljs-built_in">sbyte</span> <br>&#123;     <br>    CDRom,                                  <span class="hljs-comment">//值为0</span><br>    Fixed = <span class="hljs-number">-2</span>,                             <span class="hljs-comment">//值为-2</span><br>    Network,                                <span class="hljs-comment">//值为-1</span><br>    NoRootDirectory = <span class="hljs-number">-1</span>,                   <span class="hljs-comment">//值为-1</span><br>    Ram,                                    <span class="hljs-comment">//值为0</span><br>    Removable = Network * NoRootDirectory,  <span class="hljs-comment">//值为1</span><br>    Unknown                                 <span class="hljs-comment">//值为2</span><br>&#125;  <br></code></pre></td></tr></table></figure><ul><li>Flags关键字允许我们在使用枚举变量时,可以使用多个组合值。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Flags</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Options : <span class="hljs-built_in">byte</span><br>&#123;<br>    None    = <span class="hljs-number">0</span>,<br>    One     = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>,   <span class="hljs-comment">// 1 0b1</span><br>    Two     = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>,   <span class="hljs-comment">// 2 0b10</span><br>    Three   = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>,   <span class="hljs-comment">// 4 0b100</span><br>    Four    = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>,   <span class="hljs-comment">// 8 0b1000</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>&#123;<br>    Options option = Options.None | Options.One | Options.Two | Options.Three | Options.Four;<br>    Console.WriteLine(option.ToString());<br>    <span class="hljs-comment">//输出：One, Two, Three, Four  如果不加 Flags 的特性，输出：15</span><br>    Console.WriteLine((<span class="hljs-built_in">int</span>)option);<br>    <span class="hljs-comment">//输出：15</span><br>    Console.WriteLine(option.HasFlag(Options.None));<br>    <span class="hljs-comment">//输出：True</span><br>    Console.WriteLine(option.HasFlag(Options.One));<br>    <span class="hljs-comment">//输出：True</span><br><br>    option = Options.One | Options.Two;<br>    Console.WriteLine(option.ToString());<br>    <span class="hljs-comment">//输出：One, Two  如果不加 Flags 的特性，输出：3</span><br>    Console.WriteLine((<span class="hljs-built_in">int</span>)option)<br>    <span class="hljs-comment">//输出：3</span><br>    Console.WriteLine(option.HasFlag(Options.None));<br>    <span class="hljs-comment">//输出：True</span><br>    Console.WriteLine(option.HasFlag(Options.One));<br>    <span class="hljs-comment">//输出：True</span><br>     Console.WriteLine(option.HasFlag(Options.Three));<br>    <span class="hljs-comment">//输出：False</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以有 [Flags] 特性时尽量不要将成员的值设为 0。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;类(Class)&lt;/h1&gt;
&lt;h2 id=&quot;什么是类&quot;&gt;什么是类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一种数据结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一种数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代表现实世界中的种类&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="Languages" scheme="http://example.com/categories/Languages/"/>
    
    
    <category term="CSharp" scheme="http://example.com/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>LearnVim</title>
    <link href="http://example.com/posts/LearnVim/"/>
    <id>http://example.com/posts/LearnVim/</id>
    <published>2022-09-14T08:50:13.000Z</published>
    <updated>2025-04-17T12:55:15.931Z</updated>
    
    <content type="html"><![CDATA[<h4 id="onoremap-Is-c-u-normal-F-vi-cr">onoremap Is :&lt;c-u&gt;normal! F]vi]&lt;cr&gt;</h4><p>用 onoremap 映射一个 motion，上面代码的意思为将 Is 按键映射为找到本行光标前的 ‘]’ 符号，并选择在 ‘[]’ 内的内容。按 dIs 就可以删除本行内光标位置之前的 ‘[]’ 中的内容。</p><h4 id="c-r-c-w">:&lt;c-r&gt;&lt;c-w&gt;</h4><p>在命令模式下使用 ctrl + r 加 ctrl + w，代表把当前光标下的字符串写入命令行。</p><h4 id="10i">10i#</h4><p>插入 10 个 ‘#’</p><h4 id="normal-和-normal">normal 和 normal!</h4><p>例如给 F 添加一个映射：nnoremap F x</p><p>这时 F 就有了两个含义：</p><ul><li>vim 的出厂设置定义：反向查找</li><li>用户的自定义：x 代表删除</li></ul><p>normal F 代表用户的自定义用法，即 x 删除。normal! F 代表 vim 的出厂设置定义，即反向查找。</p><h4 id="s-和-r">s 和 r</h4><p>s 是替换当前光标下的字母并进入插入模式，r 是替换当前光标下的字母并保持在当前模式。</p><h4 id="vnoremap-normal-cr">vnoremap . :normal! .&lt;cr&gt;</h4><p>可视模式下的映射，将 “.” 映射为普通模式下的 “.” 操作，普通模式下的 “.” 操作为重复执行上一步的操作。例如：</p><p>asfdasdf aslfk sdf<br>asdfklsdf fklasdjf<br>sladfjaslas sdffasd<br>asdkfjksdjfksjdf sdfj</p><p>在第一行按 “A;”，给第一行添加了分号，然后在可视模式下选中剩下的三行，按下 “.”，就可以给剩下三行也在最后添加分号。</p><h4 id="改变数字">改变数字</h4><p>当光标在数字之前，可以按 ctrl + a 来增加数字的大小，按 ctrl + x 来减小数字的大小，然而光标在数字之后不可以如此操作。因此我们可以先按 0 来将光标置于行首来改变数字大小。</p><p>如果将一列数字改变，如下：</p><p>array[0] = 0;<br>array[0] = 0;<br>array[0] = 0;<br>array[0] = 0;<br>array[0] = 0;<br>array[0] = 0;<br>array[0] = 0;</p><p>可以使用可视块模式，即 ctrl + v 选中方括号中的 0 这一列，然后按 ctrl + a 来增加选中的全部数字的大小，按 ctrl + x 来减小选中的全部数字的大小。</p><p>如果想让数字递增，第一行的数字为 1，第二行的数字为 2 等，可以按 g ctrl + a 来实现，如果想让数字递减，可以按 g ctrl + x 来实现。</p><h4 id="生成数字">生成数字</h4><p>:put =range(1, 10) 可以从当前光标所在行的下一行开始，每一行插入一个数字，第一行为 1，第二行为 2，等等。</p><p>:0put =range(1, 10) 可以从首行开始，每一行插入一个数字，第一行为 1，第二行为 2，等等。</p><p>:for i in range(1, 10) | put =‘196.168.0.’ . i | endfor 可以生成十行字符串:<br>196.168.0.1<br>196.168.0.2<br>196.168.0.3<br>196.168.0.4<br>196.168.0.5<br>196.168.0.6<br>196.168.0.7<br>196.168.0.8<br>196.168.0.9<br>196.168.0.10</p><h4 id="录制宏及替代">录制宏及替代</h4><p><strong>普通宏：</strong></p><table><thead><tr><th>q</th><th>a</th><th>&lt;operation&gt;</th><th>q</th></tr></thead><tbody><tr><td>记录宏命令</td><td>记录宏到 a 寄存器</td><td>宏操作</td><td>记录结束退出</td></tr></tbody></table><p>qa&lt;operation&gt;q</p><p>使用宏：@a 或者 &lt;number&gt;@a 来重复执行 number 次。</p><p><strong>录制套娃宏：</strong></p><table><thead><tr><th>q</th><th>a</th><th>&lt;operation&gt;</th><th>@a</th><th>q</th></tr></thead><tbody><tr><td>记录宏命令</td><td>记录宏到 a 寄存器</td><td>宏操作</td><td>套娃</td><td>记录结束退出</td></tr></tbody></table><p>qa&lt;operation&gt;@aq</p><p>使用宏：@a</p><p><strong>替代方案：</strong></p><p>nnoremap &lt;leader&gt;nl :%s/^/\=printf(‘%-4d’, line(‘.’))&lt;cr&gt; 给所有行添加行标。</p><p>vnoremap &lt;leader&gt;vn : s/^/\=printf(“%d. “, line(”.”) - line(“'&lt;”) + 1)&lt;cr&gt; 可视模式下给选中的行加行标。</p><h4 id="set-path">set path+=**</h4><p>递归搜索目录，即搜索所有的目录，包括它们的子目录，子目录的子目录，一直循环下去，意味着目录下所有的文件和文件夹都要搜索。以 find 命令为例，添加这个设置后，可以找到子目录下的文件。</p><h4 id="set-textwidth-70-和-set-fo-Mm">set textwidth=70 和 set fo+=Mm</h4><p>set textwidth=70 可以让一行显示70个字母，多的会自动换行，set fo+=Mm 可以让 textwidth 设置同样应用到中文，一行只显示 70 个汉字。</p><h4 id="搜索-和">搜索 / 和 ?</h4><p>用 / 是从上往下搜索，按 n 是从上往下搜索下一个，按 N 是从下往上搜索上一个。用 ? 搜索，方向与 / 相反。</p><h4 id="搜索-和-2">搜索 * 和 #</h4><p>从上到下：</p><ul><li>精确搜索：*</li><li>模糊搜索：g*</li></ul><p>从下到上：</p><ul><li>精确搜索：#</li><li>模糊搜索：g#</li></ul><h4 id="正则表达式">正则表达式</h4><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>[ab1]</td><td>a 或者 b 或者 1</td></tr><tr><td>[0-9]</td><td>0 到 9 里的任意数字</td></tr><tr><td>[a-z]</td><td>a 到 z 里的任意字母</td></tr><tr><td>[A-Z]</td><td>A 到 Z 里的任意字母</td></tr><tr><td>[^0-9]</td><td>非 0-9 数字的任意字符</td></tr></tbody></table><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>任意一个字符</td></tr><tr><td>?</td><td>没有或者一个</td></tr><tr><td>*</td><td>没有或者多个</td></tr><tr><td>+</td><td>一个或者多个</td></tr><tr><td>[^a]</td><td>不是 a 的字符</td></tr><tr><td>^</td><td>行首</td></tr><tr><td>$</td><td>行末</td></tr><tr><td>\d</td><td>[0-9]</td></tr><tr><td>\D</td><td>[^0-9]</td></tr><tr><td>\w</td><td>[a-zA-Z0-9_]</td></tr><tr><td>\W</td><td>[^a-zA-Z0-9_]</td></tr><tr><td>\s</td><td>空格</td></tr><tr><td>\S</td><td>非空格</td></tr><tr><td>{min,max}</td><td>重复</td></tr><tr><td>()</td><td>组</td></tr><tr><td>(A|B)</td><td>组 A 或者组 B</td></tr></tbody></table><h4 id="计算混合运算">计算混合运算</h4><p>inoremap &lt;leader&gt;js &lt;C-O&gt;yiW&lt;End&gt;=&lt;C-R&gt;=&lt;C-R&gt;0&lt;CR&gt;<br>在插入模式下按 &lt;leader&gt;js 就可以计算式子，其中&lt;C-O&gt;为一次性使用命令，使用后仍回到插入模式，&lt;C-R&gt;为调用寄存器</p><h4 id="窗口管理">窗口管理</h4><p>命令行下</p><p>vim -o &lt;filename1&gt;&lt;filename2&gt; 依次水平打开窗口<br>vim -O &lt;filename1&gt;&lt;filename2&gt; 依次垂直打开窗口</p><p>&lt;c-w&gt;| 最大化宽度<br>&lt;c-w&gt;_ 最大化高度</p><p>:on 或者 :only 关闭除当前光标所在窗口外的所有窗口</p><p>:mksession&lt;filename&gt; 将当前窗口的 layout 记录到文件里，想要回到这样的 layout 就使用 :so&lt;filename&gt; 命令</p><h4 id="替换搜索到的字符">替换搜索到的字符</h4><p>nnoremap &lt;leader&gt;s :%s/\&lt;&lt;C-R&gt;&lt;C-W&gt;&gt;//g&lt;left&gt;&lt;left&gt;</p><h4 id="cnoreabbrev-Q-q">cnoreabbrev Q! q!</h4><p>在命令模式下，将 Q! 映射为 q!</p><ul><li>c：命令行指令，也就是说该命令只在命令行里起作用</li><li>nore：不循环映射</li><li>abbrev：映射命令</li></ul><h4 id="在命令行快速移动及修改">在命令行快速移动及修改</h4><p><strong>移动</strong></p><table><thead><tr><th>快捷键</th><th>含义</th></tr></thead><tbody><tr><td>&lt;-</td><td>向左移动一个位置</td></tr><tr><td>-&gt;</td><td>向右移动一个位置</td></tr><tr><td>&lt;S-Left&gt; or &lt;C-Left&gt;</td><td>向左移动一个 word 位置</td></tr><tr><td>&lt;S-Right&gt; or &lt;C-Right&gt;</td><td>向右移动一个 word 位置</td></tr><tr><td>CTRL-B or &lt;Home&gt;</td><td>到行首位置</td></tr><tr><td>CTRL-E or &lt;End&gt;</td><td>到行尾位置</td></tr></tbody></table><p><strong>删除</strong></p><table><thead><tr><th>快捷键</th><th>含义</th></tr></thead><tbody><tr><td>CTRL-w</td><td>删除一个 word</td></tr><tr><td>CTRL-u</td><td>从光标位置删除到行首</td></tr></tbody></table><p><strong>覆盖</strong></p><p>&lt;Insert&gt;: 进入覆盖模式，输入的字符覆盖以前的字符，再次按 &lt;Insert&gt; 退出覆盖模式。</p><p><strong>取消输入，回到 Normal 模式</strong></p><ul><li>CTRL-c</li><li>&lt;Esc&gt;</li></ul><h4 id="命令行窗口">命令行窗口</h4><p>在命令行窗口可以使用 normal 模式下的移动，可以使用各种 vimrc 里的映射。</p><p>可以通过两种方式打开这个窗口：</p><ul><li>如果已经在命令行：‘ctrl-f’</li><li>如果在 normal 模式：‘q:’</li></ul><p>退出 command-line window：</p><ul><li>执行命令退出回到编辑窗口：&lt;CR&gt;</li><li>通常使用的方式：‘:q’，‘:qa’，‘:qa!’</li><li>ctrl-c：进入命令行，‘q’，‘qa’，‘qa!’</li></ul><p>甚至搜索模式下，也可以使用以下方式来打开 command-line 窗口来进行编辑：</p><ul><li>从上到下的搜索：‘q/’</li><li>从下到上的搜索：‘q?’</li></ul><p>如果在命令行的命令比较长，或者避免使用箭头按键来移动，就可以使用命令行窗口。</p><h4 id="IdeaVimrc">IdeaVimrc</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-string">&quot; ================================================================================================</span><br><span class="hljs-string">&quot;</span> <span class="hljs-title class_">Extensions</span> <br><span class="hljs-string">&quot; ================================================================================================</span><br><span class="hljs-string">&quot;</span>下列插件需要在<span class="hljs-title class_">IDEA</span>中下载<br><span class="hljs-string">&quot;ideaVim</span><br><span class="hljs-string">&quot;</span><span class="hljs-title class_">IdeaVim</span>-<span class="hljs-title class_">EasyMotion</span><br><span class="hljs-string">&quot;IdeaVimExtension</span><br><span class="hljs-string">&quot;</span><span class="hljs-title class_">CodeGlance</span> <span class="hljs-title class_">Pro</span><br><br><span class="hljs-string">&quot; ================================================================================================</span><br><span class="hljs-string">&quot;</span> <span class="hljs-title class_">Basic</span> settings<br><span class="hljs-string">&quot; ================================================================================================</span><br><span class="hljs-string">&quot;</span>设置在光标距离窗口顶部或底部一定行数时，开始滚动屏幕内容的行为<br>set scrolloff=<span class="hljs-number">5</span><br><br>set easymotion<br><br>set cursorline<br><br>set showmatch<br><br>set nobackup<br><br>set surround<br><br>set ruler<br><br>set clipboard^=unnamed,unnamedplus<br><br><span class="hljs-string">&quot;--递增搜索功能：在执行搜索（使用 / 或 ? 命令）时，</span><br><span class="hljs-string">&quot;</span><span class="hljs-title class_">Vim</span> 会在您输入搜索模式的过程中逐步匹配并高亮显示匹配的文本。<br>set incsearch<br><br><span class="hljs-string">&quot;--在搜索时忽略大小写</span><br><span class="hljs-string">set ignorecase</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;</span>--将搜索匹配的文本高亮显示<br>set hlsearch<br><br><span class="hljs-string">&quot;--设置相对行号 和 当前行的绝对行号</span><br><span class="hljs-string">set number relativenumber</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;</span>--设置返回normal模式时回到英文输入法<br>set keep-english-<span class="hljs-keyword">in</span>-normal<br><br><span class="hljs-string">&quot; ================================================================================================</span><br><span class="hljs-string">&quot;</span> <span class="hljs-title class_">No</span> <span class="hljs-title class_">Leader</span> <span class="hljs-title class_">Keymaps</span><br><span class="hljs-string">&quot; ================================================================================================</span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;</span> go to somewhere (g <span class="hljs-keyword">in</span> normal mode <span class="hljs-keyword">for</span> goto somewhere)<br>nnoremap ga <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">GotoAction</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gb <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">JumpToLastChange</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gc <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">GotoClass</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gd <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">GotoDeclaration</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gs <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">GotoSuperMethod</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gi <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">GotoImplementation</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gf <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">GotoFile</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gm <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">GotoSymbol</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gu <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">ShowUsages</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gt <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">GotoTest</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gr <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">RecentFiles</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gh <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">Back</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap gl <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">Forward</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br><br>nnoremap ta <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">Annotate</span>&lt;cr&gt;<br>nnoremap tb <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">ToggleLineBreakpoint</span>&lt;cr&gt;<br>nnoremap tm <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">ToggleBookmark</span>&lt;cr&gt;<br>nnoremap tp <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">ActivateProjectToolWindow</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br><br>nnoremap &lt;C-f&gt; <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">ReformatCode</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap J <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">MethodDown</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap K <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">MethodUp</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap &lt;S-<span class="hljs-title class_">Down</span>&gt; <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">EditorCloneCaretBelow</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br>nnoremap &lt;S-<span class="hljs-title class_">Up</span>&gt; <span class="hljs-symbol">:&lt;C-u&gt;action</span> <span class="hljs-title class_">EditorCloneCaretAbove</span>&lt;<span class="hljs-title class_">CR</span>&gt;<br><br><span class="hljs-string">&quot; ================================================================================================</span><br><span class="hljs-string">&quot;</span>️️ <span class="hljs-title class_">Leader</span> <span class="hljs-title class_">Keymaps</span><br><span class="hljs-string">&quot; ================================================================================================</span><br><span class="hljs-string">let mapleader = &quot;</span> <span class="hljs-string">&quot;</span><br><span class="hljs-string">nnoremap &lt;Leader&gt;o :&lt;C-u&gt;action RecentProjectListGroup&lt;CR&gt;</span><br><span class="hljs-string">nnoremap &lt;Leader&gt;r :&lt;C-u&gt;action Replace&lt;CR&gt;</span><br><span class="hljs-string">vnoremap &lt;Leader&gt;r :&lt;C-u&gt;action Replace&lt;CR&gt;</span><br><span class="hljs-string">nnoremap &lt;Leader&gt;R :&lt;C-u&gt;action ReplaceInPath&lt;CR&gt;</span><br><span class="hljs-string">vnoremap &lt;Leader&gt;R :&lt;C-u&gt;action ReplaceInPath&lt;CR&gt;</span><br><span class="hljs-string">nnoremap &lt;Leader&gt;f :&lt;C-u&gt;action Find&lt;CR&gt;</span><br><span class="hljs-string">vnoremap &lt;Leader&gt;f :&lt;C-u&gt;action Find&lt;CR&gt;</span><br><span class="hljs-string">nnoremap &lt;Leader&gt;F :&lt;C-u&gt;action FindInPath&lt;CR&gt;</span><br><span class="hljs-string">vnoremap &lt;Leader&gt;F :&lt;C-u&gt;action FindInPath&lt;CR&gt;</span><br><span class="hljs-string">nnoremap &lt;Leader&gt;h gT</span><br><span class="hljs-string">nnoremap &lt;Leader&gt;l gt</span><br><span class="hljs-string">nnoremap &lt;leader&gt;ns :action NextSplitter&lt;CR&gt;</span><br><span class="hljs-string">nnoremap &lt;leader&gt;ps :action PrevSplitter&lt;CR&gt;</span><br><span class="hljs-string">nnoremap &lt;leader&gt;sh :action SplitHorizontally&lt;CR&gt;</span><br><span class="hljs-string">nnoremap &lt;leader&gt;sv :action SplitVertically&lt;CR&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;onoremap-Is-c-u-normal-F-vi-cr&quot;&gt;onoremap Is :&amp;lt;c-u&amp;gt;normal! F]vi]&amp;lt;cr&amp;gt;&lt;/h4&gt;
&lt;p&gt;用 onoremap 映射一个 motion，上面代码的意思为将 Is 按键映射为找到本</summary>
      
    
    
    
    <category term="Editor" scheme="http://example.com/categories/Editor/"/>
    
    
    <category term="Vim" scheme="http://example.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>画线和画三角形方法</title>
    <link href="http://example.com/posts/%E7%94%BB%E7%BA%BF%E5%92%8C%E7%94%BB%E9%9D%A2%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/posts/%E7%94%BB%E7%BA%BF%E5%92%8C%E7%94%BB%E9%9D%A2%E7%AE%97%E6%B3%95/</id>
    <published>2022-09-04T03:13:32.000Z</published>
    <updated>2025-04-17T12:55:15.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="画线算法">画线算法</h2><h3 id="DDA画线">DDA画线</h3><p>直线方程表示为 $y = kx + b$</p><p>当 $\lVert k \rVert &lt;= 1$时，$x$ 每递增$1$，$y$ 递增$k$。</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_1.png" alt=""></p><p>当 $\lVert k \rVert \geq 1$时，$x$ 每递增$1/k$，$y$ 递增$1$。</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_2.png" alt=""></p><p>因为光栅化不能绘制半个像素点，所以求出的值需要进行四舍五入即加 0.5 后再进行取整。</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_3.png" alt=""></p><p>DDA 算法是一个增量算法，它直观且容易实现，然而 $x$ 和 $y$ 都必须用浮点值表示，而且每一步都需要对 $y$ 进行舍入取整，不利于硬件实现。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawLine_DDA</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x1,<span class="hljs-built_in">int</span> y1,<span class="hljs-built_in">int</span> x2,<span class="hljs-built_in">int</span> y2</span>)</span>&#123;<br>    <span class="hljs-built_in">int</span> dx = x2 - x1;<br>    <span class="hljs-built_in">int</span> dy = y2 - y1;<br><br>    <span class="hljs-built_in">int</span> step = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(Math.Abs(dy) &gt; Math.Abs(dx))&#123;<br>        step = Math.Abs(dy);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        step = Math.Abs(dx);<br>    &#125;<br><br>    <span class="hljs-built_in">float</span> stepX = <span class="hljs-number">1.0f</span> * dx / step;<br>    <span class="hljs-built_in">float</span> stepY = <span class="hljs-number">1.0f</span> * dy / step;<br><br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">float</span> x = x1;<br>    <span class="hljs-built_in">float</span> y = y1;<br>    DrawPoint((<span class="hljs-built_in">int</span>)x, (<span class="hljs-built_in">int</span>)y);<br>    <span class="hljs-keyword">while</span> ((i++)&lt;step)&#123;<br>        x += stepX;<br>        y += stepY;<br>        DrawPoint((<span class="hljs-built_in">int</span>)x, (<span class="hljs-built_in">int</span>)(y+<span class="hljs-number">0.5f</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Bresenham画线">Bresenham画线</h3><p>Bresenham 算法只用 int 类型的加减和比较来绘制直线，大大降低了需要的计算资源。</p><p>它的思路是：水平直线、竖直直线单独处理，剩余的部分等分为 8 个区域，然后从最简单的斜率大于 0 小于 1 的部分开始，剩下的 7 个部分稍作修改即可。</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_4.png" alt=""></p><p>当斜率大于 0 小于 1 时，起始点为 ($x_0$, $y_0$)，终点为 ($x_1$, $y_1$)，我们遍历横坐标，找出每个横坐标对应的纵坐标。$x_{0+i}$ 对应的纵坐标应该为 $y_0 + i \times slope$，四舍五入获得的像素坐标为：int($y_0 + i \times slope + 0.5$)</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_5.png" alt=""></p><p>由于斜率大于 0 小于 1，相邻横坐标对应的纵坐标最多加 1。比如 $x_{0+1}$ 处的纵坐标要么还是 $y_0$，要么是 $y_{0+1}$。绝不可能是 $y_{0+2}$</p><p>然而 Bresenham 算法是想避免 float 类型的运算和比较。以 $x_{0+1}$ 为例：</p><p>$1 \times slope &lt; 0.5$ 则四舍，$1 \times slope \geq 0.5$ 则五入。然而实际判断 $1 \times slope &lt; 0.5$ 等价于 $2 \times slope &lt; 1$，等价于 $2 \times \Delta y &lt; \Delta x$，等价于 $2 \times \Delta y - \Delta x &lt; 0$，这时则完全没有 float 类型计算和比较了。($\Delta y = y_1 - y_0, \Delta x = x_1 - x_0$)。</p><p>若 $2 \times \Delta y - \Delta x &lt; 0$，则 $y(x_{0+1}) = y_0$，</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_6.png" alt=""></p><p>否则 $y(x_{0+1}) = y_{0+1}$</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_7.png" alt=""></p><p>接着再考虑 $x_{0+2}$ 处，</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_8.png" alt=""></p><p>若前一个像素自右上方衍生出，需要比较 $2 \times slope &lt; 1.5$，等价于 $4 \times \Delta y - 3 \times \Delta x &lt; 0$，注意 $4 \times \Delta y - 3 \times \Delta x = 2 \times \Delta y - \Delta x + (2 \times \Delta y - 2 \times \Delta x)$</p><p>若前一个像素自右方衍生出，需要比较 $2 \times slope &lt; 0.5$，等价于 $4 \times \Delta y - \Delta x &lt; 0$，注意 $4 \times \Delta y - \Delta x = 2 \times \Delta y - \Delta x + (2 \times \Delta y)$</p><p>同样的思路可以一直推下去直到线段的末尾。</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_9.png" alt=""></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawLine_Bresenham</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x0, <span class="hljs-built_in">int</span> x1, <span class="hljs-built_in">int</span> y0, <span class="hljs-built_in">int</span> y1</span>)</span><br>&#123;<br>    <span class="hljs-built_in">bool</span> steep = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(Math.Abs(x0 - x1) &lt; Math.Abs(y0 - y1))<br>    &#123;<br>        TempSwap(<span class="hljs-keyword">ref</span> x0, <span class="hljs-keyword">ref</span> y0);<br>        TempSwap(<span class="hljs-keyword">ref</span> x1, <span class="hljs-keyword">ref</span> y1);<br>        steep = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(x0 &gt; x1)<br>    &#123;<br>        TempSwap(<span class="hljs-keyword">ref</span> x0, <span class="hljs-keyword">ref</span> x1);<br>        TempSwap(<span class="hljs-keyword">ref</span> y0, <span class="hljs-keyword">ref</span> y1);<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> dx = x1 - x0;<br>    <span class="hljs-built_in">int</span> dy = y1 - y0;<br><br>    <span class="hljs-built_in">int</span> derror = Math.Abs(dy) * <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">int</span> error = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> y = y0;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> x = x0; x &lt;= x1; x++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (steep)<br>        &#123;<br>            DrawPoint(y, x);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            DrawPoint(x, y);<br>        &#125;<br><br>        error += derror;<br>        <br>        <span class="hljs-keyword">if</span> (error &gt; dx)<br>        &#123;<br>            y += (y1 &gt; y0 ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>);<br>            error -= dx * <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中点画线">中点画线</h3><p>如下图</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_10.png" alt=""></p><p>其中，<br>$$<br>\begin{aligned}<br>P &amp;= p_0 + (P_1 - P_0)t\<br>&amp;= P_0 - tP_0 + tP_1\<br>&amp;= (1 - t)P_0 + tP_1<br>\end{aligned}<br>$$</p><p>那么<br>$$<br>f(x) = (1 - t) \times f(x_0) + t \times f(x_1)<br>$$</p><p>直线隐函数方程为：<br>$$<br>F(x, y) = y - kx - b = 0<br>$$</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_11.png" alt=""></p><p>假设已经确定了要显示的点 ($x_i$, $y_i$)，那么需要确定下一个点绘制的位置，这里需要用到中点误差项。</p><p>$$<br>d_i = F(x_i + 1, y_i + 0.5) = y_i + 0.5 - k(x_i + 1) - b<br>$$</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_12.png" alt=""></p><p>$$<br>y_{i+1} = \begin{cases}<br>y_i + 1, (d_i &lt; 0)\<br>y_i,\quad(d_i \geq 0)<br>\end{cases}<br>$$</p><p>当 $d_i &lt; 0$ 时，<br>$$<br>\begin{aligned}<br>d_{i+1} &amp;= F(x_i + 2, y_i + 1.5)\<br>&amp;= y_i + 1.5 - k(x_i + 2) - b\<br>&amp;= y_i + 0.5 - k(x_i + 1) - b + 1 - k\<br>&amp;= d_i + 1 - k<br>\end{aligned}<br>$$</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_13.png" alt=""></p><p>当 $d_i \geq 0$ 时，<br>$$<br>\begin{aligned}<br>d_{i+1} &amp;= F(x_i + 2, y_i + 0.5)\<br>&amp;= y_i + 0.5 - k(x_i + 2) - b\<br>&amp;= y_i + 0.5 - k(x_i + 1) - b - k\<br>&amp;= d_i - k<br>\end{aligned}<br>$$</p><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_14.png" alt=""></p><p>当 $d_i &lt; 0$ 时，$d_{i+1} = d_i + 1 - k$，当 $d_i \geq 0$ 时，$d_{i+1} = d_i - k$</p><p>中点误差项初始值为：<br>$$<br>\begin{aligned}<br>d_0 &amp;= F(x_0 + 1, y_0 + 0.5)\<br>&amp;= y_0 + 0.5 - k(x_0 + 1) - b\<br>&amp;= y_0 - kx - b - k + 0.5\<br>&amp;= 0.5 - k<br>\end{aligned}<br>$$</p><p>接下来，我们需要进行整数化处理：</p><p>令 $d$ 乘以 $2\Delta x$ 得到 $e$，误差项正负值不变，不会影响 $y$ 的增量<br>$$<br>e = 2d\Delta x<br>$$<br>此时误差项初始值为：<br>$$<br>e_0 = 2d_0\Delta x = 2(0.5 - k)\Delta x = \Delta x - 2\Delta y<br>$$</p><p>此时误差项的递推公式为：<br>$$<br>\begin{aligned}<br>e &lt; 0, e &amp;= 2(d + 1 - k)\Delta x = 2d\Delta x + 2\Delta x - 2k\Delta x = e + 2\Delta x - 2\Delta y\<br>e \geq 0, e &amp;= 2(d - k)\Delta x = 2d\Delta x - 2k\Delta x = e - 2\Delta y<br>\end{aligned}<br>$$</p><p>$$<br>e_{i+1} = \begin{cases}<br>e_i + 2\Delta x - 2\Delta y, (e &lt; 0)\<br>e_i - 2\Delta y,\quad(e \geq 0)<br>\end{cases}<br>$$</p><p>那么此时进行画线操作，从 $P_0$ 开始到 $P_1$ 点沿 $x$ 轴方向，判断 $e$ 的符号来绘制点 ($x$, $y$)，若 $e &lt; 0$，将点更新为 ($x+1$, $y+1$)，$e = e + 2\Delta x - 2\Delta y$；否则将点更新为 ($x+1$, $y$)，$e = e - 2\Delta y$</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawLine_MidPoint</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x0,<span class="hljs-built_in">int</span> y0,<span class="hljs-built_in">int</span> x1,<span class="hljs-built_in">int</span> y1</span>)</span><br>&#123;<br>    <span class="hljs-built_in">bool</span> bInterchange = <span class="hljs-literal">false</span>;<br><br><span class="hljs-built_in">int</span> dx = abs(x1 - x0);<br>    <span class="hljs-built_in">int</span> dy = abs(y1 - y0);<br>    <span class="hljs-built_in">int</span> signx = x0 &lt; x1 ? <span class="hljs-number">1</span>: <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">int</span> signy = y0 &lt; y1 ? <span class="hljs-number">1</span>: <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span>(dy &gt; dx)&#123;<br>        <span class="hljs-built_in">int</span> temp = dy;<br>        dy = dx;<br>        dx = temp;<br>        bInterchange = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> e = dx - <span class="hljs-number">2</span> * dy;<br>    <span class="hljs-built_in">int</span> x = x0;<br>    <span class="hljs-built_in">int</span> y = y0;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= dx; i++)&#123;<br>        DrawPoint(x, y);<br>        <span class="hljs-keyword">if</span>(bInterchange)&#123;<br>            y += signy;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            x += signx;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(e &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(bInterchange)&#123;<br>                x += signx;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                y += signy;<br>            &#125;<br>            e += <span class="hljs-number">2</span> * dx - <span class="hljs-number">2</span> * dy;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            e -= <span class="hljs-number">2</span> * dy;<br>        &#125;<br>    &#125;<br> <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="画三角形方法">画三角形方法</h2><h3 id="利用线性插值画三角形">利用线性插值画三角形</h3><p>让我们假设三角形的三个点 t0，t1, t2，通过 y 坐标的大小排序成升序。 那么，边界 A 在是 t0 和 t2 之间的线段，边界 B 是 t0 和 t1 之间线段，最后的在 t1 和 t2 之间的线段。以高度差作为循环控制变量，从左到右对相同高度的像素进行着色。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawTriangle1</span>(<span class="hljs-params">Point t0, Point t1, Point t2</span>)</span><br>&#123;<br>    <span class="hljs-comment">//三角形的三个点y值相同，面积为0</span><br>    <span class="hljs-keyword">if</span> (t0.y == t1.y &amp;&amp; t1.y == t2.y) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//根据y值大小对坐标进行排序</span><br>    <span class="hljs-keyword">if</span> (t0.y &gt; t1.y)<br>    &#123;<br>        TempSwap(<span class="hljs-keyword">ref</span> t0, <span class="hljs-keyword">ref</span> t1);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (t0.y &gt; t2.y)<br>    &#123;<br>        TempSwap(<span class="hljs-keyword">ref</span> t0, <span class="hljs-keyword">ref</span> t2);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (t1.y &gt; t2.y)<br>    &#123;<br>        TempSwap(<span class="hljs-keyword">ref</span> t1, <span class="hljs-keyword">ref</span> t2);<br>    &#125;<br><br>    <span class="hljs-built_in">int</span> total_height = t2.y - t0.y;<br>    <span class="hljs-comment">//以高度差作为循环控制变量，此时不需要考虑斜率，因为着色完后每行都会被填充</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; total_height; i++)<br>    &#123;<br>        <span class="hljs-built_in">bool</span> second_half = i &gt; t1.y - t0.y || t1.y == t0.y;<br><br>        <span class="hljs-built_in">int</span> segment_height = second_half ? t2.y - t1.y : t1.y - t0.y;<br>        <span class="hljs-built_in">float</span> alpha = (<span class="hljs-built_in">float</span>)i / total_height;<br>        <span class="hljs-built_in">float</span> beta = (<span class="hljs-built_in">float</span>)(i - (second_half ? t1.y - t0.y : <span class="hljs-number">0</span>)) / segment_height;<br>        <span class="hljs-comment">//计算A，B两点的坐标</span><br>        Point A = t0 + (t2 - t0) * alpha;<br>        Point B = second_half ? t1 + (t2 - t1) * beta : t0 + (t1 - t0) * <span class="hljs-function">beta</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">if</span> (<span class="hljs-params">A.x &gt; B.x</span>)</span><br>        &#123;<br>            TempSwap(<span class="hljs-keyword">ref</span> A, <span class="hljs-keyword">ref</span> B);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = A.x; j &lt;= B.x; j++)<br>        &#123;<br>            <span class="hljs-built_in">float</span> phi = B.x == A.x ? <span class="hljs-number">1f</span> : (<span class="hljs-built_in">float</span>)(j - A.x) / (<span class="hljs-built_in">float</span>)(B.x - A.x);<br>            Point P = A + (B - A) * phi;<br>            DrawPoint(P.x, P.y);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="利用叉乘画三角形">利用叉乘画三角形</h3><p>对于三角形 $\triangle ABC$ 来说，把三条边看作 $\overset{\longrightarrow}{AB}$、$\overset{\longrightarrow}{BC}$、$\overset{\longrightarrow}{CA}$ 三条首尾相连的向量，平面内有一个点 $P$，我们通过向量叉乘来判断相对位置。</p><p>对二维向量叉乘做一个定义：</p><p>假设有两个二维向量 $\vec{a}$ 和 $\vec{b}$，我们把它们视为三维向量，$z$ 轴补 0，那么这个时候的 $\vec{a}$ 和 $\vec{b}$ 叉乘的结果为 $\vec{c}$，$\vec{c}$ 的 $x$ 值为 0， $y$ 值为 0， $z$ 值为 $a.x \times b.y - b.x \times a.y$，这个时候可以吧二维向量的叉乘定义为得到一个值，即为 $\vec{c}$ 的 $z$ 值。</p><ul><li>如果 $z$ 值大于 0，表示 $\vec{b}$ 在 $\vec{a}$ 的左侧</li><li>如果 $z$ 值小于 0，表示 $\vec{b}$ 在 $\vec{a}$ 的右侧</li><li>如果 $z$ 值等于 0，表示 $\vec{b}$ 与 $\vec{a}$ 共线</li></ul><p><img src="/posts_image/DrawLineAndFace/DrawLineAndFace_15.png" alt=""></p><ul><li>$\overset{\longrightarrow}{AB} \times \overset{\longrightarrow}{AP}$，值为正，则 $P$ 在 $AB$ 左侧</li><li>$\overset{\longrightarrow}{BC} \times \overset{\longrightarrow}{BP}$，值为正，则 $P$ 在 $BC$ 左侧</li><li>$\overset{\longrightarrow}{CA} \times \overset{\longrightarrow}{CP}$，值为正，则 $P$ 在 $AC$ 左侧</li></ul><p>综合以上三个条件，我们可以判断 $P$ 在 $\triangle ABC$ 内。如果三个计算中有值为负的情况，说明 $P$ 在 $\triangle ABC$ 外。如果有值为 0 的情况，说明 $P$ 在 $\triangle ABC$ 的边或顶点上。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-function">Vector3 <span class="hljs-title">crossProduct</span>(<span class="hljs-params">Point[] points, Point P</span>)</span><br>&#123;<br>    Vector2 AB = <span class="hljs-keyword">new</span> Vector2(points[<span class="hljs-number">1</span>].x - points[<span class="hljs-number">0</span>].x, points[<span class="hljs-number">1</span>].y - points[<span class="hljs-number">0</span>].y);<br>    Vector2 BC = <span class="hljs-keyword">new</span> Vector2(points[<span class="hljs-number">2</span>].x - points[<span class="hljs-number">1</span>].x, points[<span class="hljs-number">2</span>].y - points[<span class="hljs-number">1</span>].y);<br>    Vector2 CA = <span class="hljs-keyword">new</span> Vector2(points[<span class="hljs-number">0</span>].x - points[<span class="hljs-number">2</span>].x, points[<span class="hljs-number">0</span>].y - points[<span class="hljs-number">2</span>].y);<br><br>    Vector2 AP = <span class="hljs-keyword">new</span> Vector2(P.x - points[<span class="hljs-number">0</span>].x, P.y - points[<span class="hljs-number">0</span>].y);<br>    Vector2 BP = <span class="hljs-keyword">new</span> Vector2(P.x - points[<span class="hljs-number">1</span>].x, P.y - points[<span class="hljs-number">0</span>].y);<br>    Vector2 CP = <span class="hljs-keyword">new</span> Vector2(P.x - points[<span class="hljs-number">2</span>].x, P.y - points[<span class="hljs-number">0</span>].y);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector3(AB.x * AP.y - AP.x * AB.y, BC.x * BP.y - BP.x * BC.y, CA.x * CP.y - CP.x * CA.y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawTriangle2</span>(<span class="hljs-params">Point[] points</span>)</span><br>&#123;<br>    Vector2 bboxmin = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-built_in">float</span>.MaxValue,<span class="hljs-built_in">float</span>.MaxValue);<br>    Vector2 bboxmax = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-built_in">float</span>.MinValue,<span class="hljs-built_in">float</span>.MinValue);<br>    Vector2 clamp = <span class="hljs-keyword">new</span> Vector2(canvas.Width - <span class="hljs-number">1</span>, canvas.Height - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        bboxmin.x = Math.Max(<span class="hljs-number">0f</span>, Math.Min(bboxmin.x, points[i].x));<br>        bboxmin.y = Math.Max(<span class="hljs-number">0f</span>, Math.Min(bboxmin.y, points[i].y));<br>        bboxmax.x = Math.Min(clamp.x, Math.Max(bboxmax.x, points[i].x));<br>        bboxmax.y = Math.Min(clamp.y, Math.Max(bboxmax.y, points[i].y));<br>    &#125;<br><br>    Point p;<br>    <span class="hljs-keyword">for</span>(p.x = (<span class="hljs-built_in">int</span>)Math.Ceiling(bboxmin.x); p.x &lt;= (<span class="hljs-built_in">int</span>)Math.Floor(bboxmax.x); p.x++)&#123;<br>        <span class="hljs-keyword">for</span>(p.y = (<span class="hljs-built_in">int</span>)Math.Ceiling(bboxmin.y); p.y &lt;= (<span class="hljs-built_in">int</span>)Math.Floor(bboxmax.y); p.y++)&#123;<br>            Vector3 cross = crossProduct(points, p);<br>            <span class="hljs-keyword">if</span>(cross.x &lt; <span class="hljs-number">0</span> || cross.y &lt; <span class="hljs-number">0</span> || cross.z &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            DrawPoint(p.x, p.y);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="利用三角形重心画三角形">利用三角形重心画三角形</h3><p>有关于三角形重心的介绍可以参考上一篇博文，下面给出代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> Vector3 <span class="hljs-title">CrossProduct</span>(<span class="hljs-params">Vector3 v1, Vector3 v2</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector3(<br>        v1.y * v2.z - v1.z * v2.y,<br>        v1.z * v2.x - v1.x * v2.z,<br>        v1.x * v2.y - v1.y * v2.x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Vector3 <span class="hljs-title">Barycentric</span>(<span class="hljs-params">Point A, Point B, Point C, Point P</span>)</span><br>&#123;<br>    Vector3 x = <span class="hljs-keyword">new</span> Vector3(B.x - A.x, C.x - A.x, A.x - P.x);<br>    Vector3 y = <span class="hljs-keyword">new</span> Vector3(B.y - A.y, C.y - A.y, A.y - P.y);<br>    Vector3 u = CrossProduct(x, y);<br><br>    <span class="hljs-keyword">if</span> (Math.Abs(u.z) &gt; <span class="hljs-built_in">float</span>.Epsilon)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1f</span> - (u.x + u.y) / u.z, u.y / u.z, u.x / u.z);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawTriangle3</span>(<span class="hljs-params">Point[] points</span>)</span><br>&#123;<br>    Vector2 bboxmin = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-built_in">float</span>.MaxValue,<span class="hljs-built_in">float</span>.MaxValue);<br>    Vector2 bboxmax = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-built_in">float</span>.MinValue,<span class="hljs-built_in">float</span>.MinValue);<br>    Vector2 clamp = <span class="hljs-keyword">new</span> Vector2(canvas.Width - <span class="hljs-number">1</span>, canvas.Height - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        bboxmin.x = Math.Max(<span class="hljs-number">0f</span>, Math.Min(bboxmin.x, points[i].x));<br>        bboxmin.y = Math.Max(<span class="hljs-number">0f</span>, Math.Min(bboxmin.y, points[i].y));<br>        bboxmax.x = Math.Min(clamp.x, Math.Max(bboxmax.x, points[i].x));<br>        bboxmax.y = Math.Min(clamp.y, Math.Max(bboxmax.y, points[i].y));<br>    &#125;<br><br>    Point p;<br>    <span class="hljs-keyword">for</span>(p.x = (<span class="hljs-built_in">int</span>)Math.Ceiling(bboxmin.x); p.x &lt;= (<span class="hljs-built_in">int</span>)Math.Floor(bboxmax.x); p.x++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(p.y = (<span class="hljs-built_in">int</span>)Math.Ceiling(bboxmin.y); p.y &lt;= (<span class="hljs-built_in">int</span>)Math.Floor(bboxmax.y); p.y++)<br>        &#123;<br>            Vector3 bc_screen = Barycentric(points[<span class="hljs-number">0</span>], points[<span class="hljs-number">1</span>], points[<span class="hljs-number">2</span>], p);<br>            <span class="hljs-keyword">if</span> (bc_screen.x &lt; <span class="hljs-number">0f</span> || bc_screen.y &lt; <span class="hljs-number">0f</span> || bc_screen.z &lt; <span class="hljs-number">0f</span>) <span class="hljs-keyword">continue</span>;<br>            DrawPoint(p.x, p.y);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;画线算法&quot;&gt;画线算法&lt;/h2&gt;
&lt;h3 id=&quot;DDA画线&quot;&gt;DDA画线&lt;/h3&gt;
&lt;p&gt;直线方程表示为 $y = kx + b$&lt;/p&gt;
&lt;p&gt;当 $\lVert k \rVert &amp;lt;= 1$时，$x$ 每递增$1$，$y$ 递增$k$。&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="Computer Graphics" scheme="http://example.com/categories/Computer-Graphics/"/>
    
    
    <category term="Math" scheme="http://example.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>三角形重心坐标</title>
    <link href="http://example.com/posts/%E4%B8%89%E8%A7%92%E5%BD%A2%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/"/>
    <id>http://example.com/posts/%E4%B8%89%E8%A7%92%E5%BD%A2%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/</id>
    <published>2022-07-31T08:15:05.000Z</published>
    <updated>2025-04-17T12:55:15.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三角形">三角形</h2><p>想要定义一个三角形只需列出其 3 个顶点即可，但是列出这三个顶点的顺序非常重要。在左手坐标系并且从三角形正面看时，通常按照顺时针顺序枚举顶点。我们将这 3 个顶点分别称为 $\bf v_1$， $\bf v_2$， $\bf v_3$。</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_1.png" alt=""></p><p>其中的边长和长度可以表示为：<br>$$<br>\begin{aligned}<br>{\bf e_1} &amp;= {\bf v_3} - {\bf v_2} &amp; {\bf e_2} &amp;= {\bf v_1} - {\bf v_3} &amp; {\bf e_3} &amp;= {\bf v_2} - {\bf v_1}\<br>l_1 &amp;= \lVert {\bf e_1} \rVert &amp; l_2 &amp;= \lVert {\bf e_2} \rVert &amp; l_3 &amp;= \lVert {\bf e_3} \rVert<br>\end{aligned}<br>$$</p><p>正弦定理：<br>$$<br>\frac{\sin(\theta_1)}{l_1} = \frac{\sin(\theta_2)}{l_2} = \frac{\sin(\theta_3)}{l_3}<br>$$</p><p>余弦定理：<br>$$<br>\begin{aligned}<br>l_1^2 = l_2^2 + l_3^2 - 2l_2l_3\cos\theta_1\<br>l_2^2 = l_1^2 + l_3^2 - 2l_1l_3\cos\theta_2\<br>l_3^2 = l_1^2 + l_2^2 - 2l_1l_2\cos\theta_3\<br>\end{aligned}<br>$$</p><p>三角形周长：<br>$$<br>p = l_1 + l_2 + l_3<br>$$</p><h2 id="三角形面积">三角形面积</h2><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_2.png" alt=""></p><p>三角形面积：<br>$$<br>A = bh/2<br>$$</p><p>如果高度未知，则可以使用海伦公式，该公式只需要三边的边长即可求三角形的面积：<br>$$<br>\begin{aligned}<br>s = \frac{l_1 + l_2 + l_3}{2} = \frac{p}{2}<br>A = \sqrt{s(s - l_1)(s - l_2)(s - l_3)}<br>\end{aligned}<br>$$</p><p>我们还可以单独通过顶点坐标来计算三角形的面积，其基本思想是，为三角形的三条边中的每一条边计算梯形的有符号的面积，该面积由边和下方的 x 轴所界定，如下图所示</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_3.png" alt=""></p><p>“有符号的面积”是指如果边的指向是从左到右，则该面积为正；如果边的指向是从右到左，则面积为负。请注意，无论三角形如何定向，总会有至少一条边的面积为正值并且至少一条边的面积为负值。垂直边的面积为零。每条边下的面积公式为：<br>$$<br>\begin{aligned}<br>A({\bf e_1}) = \frac{(y_3 + y_2)(x_3 - x_2)}{2}\<br>A({\bf e_2}) = \frac{(y_1 + y_3)(x_1 - x_3)}{2}\<br>A({\bf e_3}) = \frac{(y_2 + y_1)(x_2 - x_1)}{2}\<br>\end{aligned}<br>$$</p><p>通过对 3 个梯形的有符号面积求和，可以获得三角形本身的面积。假设三角形周围的顶点按顺时针排序（如果按相反的顺序排序会反转面积的符号），可以通过下式对梯形的面积求和来计算三角形的有符号面积：<br>$$<br>\begin{aligned}<br>A &amp;= A({\bf e_1}) + A({\bf e_2}) + A({\bf e_3})\<br>&amp;= \frac{(y_3 + y_2)(x_3 - x_2) + (y_1 + y_3)(x_1 - x_3) + (y_2 + y_1)(x_2 - x_1)}{2}\<br>&amp;= \frac{y_3x_3 - y_3x_2 + y_2x_3 - y_2x_2 + y_1x_1 - y_1x_3 + y_3x_1 - y_3x_3 + y_2x_2 - y_2x_1 + y_1x_2 - y_1x_1}{2}\<br>&amp;= \frac{-y_3x_2 + y_2x_3 - y_1x_3 + y_3x_1 - y_2x_1 + y_1x_2}{2}\<br>&amp;= \frac{y_1(x_2 - x_3) + y_2(x_3 - x_1) + y_3(x_1 - x_2)}{2}<br>\end{aligned}<br>$$</p><p>我们还可以进一步化简这个式子，因为我们可以在不影响面积的情况下平移三角形，比如将三角形垂直移动直到一点落在 x 轴上。例如当第三个点落到 x 轴上时，我们可以从每个 y 坐标中减去 $y_3$：<br>$$<br>\begin{aligned}<br>A &amp;= \frac{y_1(x_2 - x_3) + y_2(x_3 - x_1) + y_3(x_1 - x_2)}{2}\<br>&amp;= \frac{(y_1 - y_3)(x_2 - x_3) + (y_2 - y_3)(x_3 - x_1) + (y_3 - y_3)(x_1 - x_2)}{2}\<br>&amp;= \frac{(y_1 - y_3)(x_2 - x_3) + (y_2 - y_3)(x_3 - x_1)}{2}<br>\end{aligned}<br>$$</p><p>在三维中，可以使用叉积来计算三角形的面积，两个矢量 ${\bf a}$ 和 ${\bf b}$ 的叉积的大小等于通过 ${\bf a}$ 和 ${\bf b}$ 这两条边形成的平行四边形的面积。由于三角形的面积是封闭的平行四边形面积的一半，那么，给定来自三角形的两个边矢量 ${\bf e_1}$ 和 ${\bf e_2}$，该三角形的面积为：<br>$$<br>A = \frac{\lVert{\bf e_1 \times e_2}\rVert}{2}<br>$$</p><h2 id="重心空间">重心空间</h2><p>三角形平面中的任何点都可以表示为顶点的加权平均值。这些加权称为重心坐标。从重心坐标 ($b_1$, $b_2$, $b_3$) 到标准三维空间的转换可由下式定义：<br>$$<br>(b_1, b_2, b_3) \equiv b_1{\bf v_1}  + b_2{\bf v_2}  + b_3{\bf v_3}<br>$$<br>重心坐标是一些矢量的线性组合，而普通笛卡尔坐标也可以解释为基矢量的线性组合，但重心坐标和普通笛卡尔坐标之间有一个细微的区别，那就是重心坐标的坐标之和被限制为 1，其定义如下：<br>$$<br>b_1 + b_2 + b_3 = 1<br>$$<br>值 $b_1$、$b_2$、$b_3$ 分别是每个顶点对该点的“贡献”或“权重”。下图显示了点及其重心坐标的一些示例。</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_4.png" alt=""></p><p>上图中的三角形的 3 个顶点在重心坐标中具有以下很简单的形式：<br>$$<br>(1, 0, 0) \equiv {\bf v_1} \qquad (0, 1, 0) \equiv {\bf v_2} \qquad (0, 0, 1) \equiv {\bf v_3}<br>$$<br>而且，与顶点相对的一条边上的所有点对应于该顶点的重心坐标将具有零值。例如，对于包含 ${\bf e_1}$（与 ${\bf v_1}$ 相对）的直线上的所有点，$b_1 = 0$。</p><p>平面中的任何点都可以用重心坐标来描述，而不仅仅是三角形内的点。三角形内部的点的重心坐标都在 [0, 1] 范围内，三角形外的任何点都将至少有一个负坐标值。重心空间可以将平面以与原始三角形大小相同的三角形来网格化，如下图所示。</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_5.png" alt=""></p><p>还有另一种思考重心坐标的方法。丢弃 $b_3$，我们可以将 ($b_1$, $b_2$) 解释为常规的 (x, y) 二维坐标，其中，原点位于 ${\bf v_3}$，x 轴是 ${\bf v_1 - v_3}$，y 轴是 ${\bf v_2 - v_3}$：<br>$$<br>\begin{aligned}<br>(b_1, b_2, b_3) &amp;\equiv b_1{\bf v_1} + b_2{\bf v_2} + b_3{\bf v_3}\<br>&amp;\equiv b_1{\bf v_1} + b_2{\bf v_2} + (1 - b_1 - b_2){\bf v_3}\<br>&amp;\equiv b_1{\bf v_1} + b_2{\bf v_2} + {\bf v_3} - b_1{\bf v_3} - b_2{\bf v_3}\<br>&amp;\equiv {\bf v_3} + b_1({\bf v_1 - v_3}) + b_2({\bf v_2 - v_3})<br>\end{aligned}<br>$$</p><h2 id="计算重心坐标">计算重心坐标</h2><p>现在来看一看如何确定笛卡尔坐标的重心坐标。先从下图的二维开始，它显示了 ${\bf v_1}$、${\bf v_2}$ 和 ${\bf v_3}$ 这三个顶点以及点 ${\bf p}$。我们还标记了 3 个分割出来的子三角形 $T_1$、$T_2$、$T_3$，它们与同一索引的顶点相对。</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_6.png" alt=""></p><p>已知 3 个顶点和点 ${\bf p}$ 的笛卡尔坐标，求重心坐标 $b_1$、$b_2$ 和 $b_3$。以下给了 3 个方程和 3 个未知数：<br>$$<br>\begin{aligned}<br>b_1x_1 + b_2x_2 + b_3x_3 &amp;= p_x,\<br>b_1y_1 + b_2y_2 + b_3y_3 &amp;= p_y,\<br>b_1 + b_2 + b_3 &amp;= 1<br>\end{aligned}<br>$$</p><p>求解该方程组得出以下结果：<br>$$<br>\begin{aligned}<br>b_1 &amp;= \frac{(p_y - y_3)(x_2 - x_3) + (y_2 - y_3)(x_3 - p_x)}{(y_1 - y_3)(x_2 - x_3) + (y_2 - y_3)(x_3 - x_1)},\<br>b_2 &amp;= \frac{(p_y - y_1)(x_3 - x_1) + (y_3 - y_1)(x_1 - p_x)}{(y_1 - y_3)(x_2 - x_3) + (y_2 - y_3)(x_3 - x_1)},\<br>b_3 &amp;= \frac{(p_y - y_2)(x_1 - x_2) + (y_1 - y_2)(x_2 - p_x)}{(y_1 - y_3)(x_2 - x_3) + (y_2 - y_3)(x_3 - x_1)}\<br>\end{aligned}<br>$$</p><p>可以看到每个表达式中的分母是相同的，而且由海伦公式的变形可知它等于三角形面积的两倍。而对于每个重心坐标 $b_i$ 来说，其分子等于子三角形 $T_i$ 的面积的两倍，换言之：<br>$$<br>b_1 = A(T_1)/A(T),\qquad b_2 = A(T_2)/A(T),\qquad b_3 = A(T_3)/A(T)<br>$$</p><p>请注意，即使 ${\bf p}$ 在三角形之外，此解释也是适用的，因为如果顶点以逆时针顺序枚举，则计算面积的公式会产生负值结果。如果三角形的三个顶点是共线的，那么分母中的面积将为零，因此不能计算重心坐标。</p><p>计算三维中任意点 ${\bf p}$ 的重心坐标比在二维中更复杂。我们不能像以前一样求解方程组，因为有 3 个未知数和 4 个方程。另一个复杂因素是 ${\bf p}$ 可能不在包含三角形的平面中，在这种情况下，重心坐标是不确定的。现在，先假设 ${\bf p}$ 位于包含三角形的平面中的情形。</p><p>一个有效的技巧是，通过丢弃 x、y 或 z 中的一个来将三维问题转变为二维问题。这具有将三角形投影到 3 个基本平面之一上的效果。以直觉而言，这是有效的，因为投影面积与原始面积成正比。</p><p>但是，应该丢弃哪一个坐标呢？我们不能总丢弃相同的，因为如果三角形垂直于投影平面，投影点将是共线的。如果三角形几乎垂直于投影平面，那么将遇到浮点精度问题。解决这个问题的方法是选择投影平面，以便最大化投影三角形的面积。这可以通过检查平面法线来完成，具有最大绝对值的坐标就是我们将要丢弃的坐标。例如，如果法线是 [0.267, -0.802, 0.535]，那么将丢弃顶点和 ${\bf p}$ 点的 y 值，投影到 xz 平面上。</p><p>下面代码展示如何计算任意三维点的重心坐标：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">computeBarycentricCoords3d</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">const</span> Vector3 v[<span class="hljs-number">3</span>], <span class="hljs-comment">// vertices of the triangle</span></span><br><span class="hljs-params">    <span class="hljs-type">const</span> Vector3 &amp;p,   <span class="hljs-comment">// point that we wish to compute coords for</span></span><br><span class="hljs-params">    <span class="hljs-type">float</span> b[<span class="hljs-number">3</span>]          <span class="hljs-comment">// barycentric coords returned here</span></span><br><span class="hljs-params">)</span> &#123;<br><br>    <span class="hljs-comment">// First, compute two clockwise edge vectors</span><br>    Vector3 d1 = v[<span class="hljs-number">1</span>] - v[<span class="hljs-number">0</span>];<br>    Vector3 d2 = v[<span class="hljs-number">2</span>] - v[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// Compute surface normal using cross product.  In many cases</span><br>    <span class="hljs-comment">// this step could be skipped, since we would have the surface</span><br>    <span class="hljs-comment">// normal precomputed.  We do not need to normalize it, although</span><br>    <span class="hljs-comment">// if a precomputed normal was normalized, it would be OK.</span><br>    Vector3 n = crossProduct(d1, d2);<br><br>    <span class="hljs-comment">// Locate dominant axis of normal, and select plane of projection</span><br>    <span class="hljs-type">float</span> u1, u2, u3, u4;<br>    <span class="hljs-type">float</span> v1, v2, v3, v4;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">fabs</span>(n.x) &gt;= <span class="hljs-built_in">fabs</span>(n.y)) &amp;&amp; (<span class="hljs-built_in">fabs</span>(n.x) &gt;= <span class="hljs-built_in">fabs</span>(n.z))) &#123;<br><br>        <span class="hljs-comment">// Discard x, project onto yz plane</span><br>        u1 = v[<span class="hljs-number">0</span>].y - v[<span class="hljs-number">2</span>].y;<br>        u2 = v[<span class="hljs-number">1</span>].y - v[<span class="hljs-number">2</span>].y;<br>        u3 = p.y - v[<span class="hljs-number">0</span>].y;<br>        u4 = p.y - v[<span class="hljs-number">2</span>].y;<br><br>        v1 = v[<span class="hljs-number">0</span>].z - v[<span class="hljs-number">2</span>].z;<br>        v2 = v[<span class="hljs-number">1</span>].z - v[<span class="hljs-number">2</span>].z;<br>        v3 = p.z - v[<span class="hljs-number">0</span>].z;<br>        v4 = p.z - v[<span class="hljs-number">2</span>].z;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(n.y) &gt;= <span class="hljs-built_in">fabs</span>(n.z)) &#123;<br><br>        <span class="hljs-comment">// Discard y, project onto xz plane</span><br>        u1 = v[<span class="hljs-number">0</span>].z - v[<span class="hljs-number">2</span>].z;<br>        u2 = v[<span class="hljs-number">1</span>].z - v[<span class="hljs-number">2</span>].z;<br>        u3 = p.z - v[<span class="hljs-number">0</span>].z;<br>        u4 = p.z - v[<span class="hljs-number">2</span>].z;<br><br>        v1 = v[<span class="hljs-number">0</span>].x - v[<span class="hljs-number">2</span>].x;<br>        v2 = v[<span class="hljs-number">1</span>].x - v[<span class="hljs-number">2</span>].x;<br>        v3 = p.x - v[<span class="hljs-number">0</span>].x;<br>        v4 = p.x - v[<span class="hljs-number">2</span>].x;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>        <span class="hljs-comment">// Discard z, project onto xy plane</span><br>        u1 = v[<span class="hljs-number">0</span>].x - v[<span class="hljs-number">2</span>].x;<br>        u2 = v[<span class="hljs-number">1</span>].x - v[<span class="hljs-number">2</span>].x;<br>        u3 = p.x - v[<span class="hljs-number">0</span>].x;<br>        u4 = p.x - v[<span class="hljs-number">2</span>].x;<br><br>        v1 = v[<span class="hljs-number">0</span>].y - v[<span class="hljs-number">2</span>].y;<br>        v2 = v[<span class="hljs-number">1</span>].y - v[<span class="hljs-number">2</span>].y;<br>        v3 = p.y - v[<span class="hljs-number">0</span>].y;<br>        v4 = p.y - v[<span class="hljs-number">2</span>].y;<br>    &#125;<br><br>    <span class="hljs-comment">// Compute denominator, check for invalid</span><br>    <span class="hljs-type">float</span> denom = v1*u2 - v2*u1;<br>    <span class="hljs-keyword">if</span> (denom == <span class="hljs-number">0.0f</span>) &#123;<br><br>        <span class="hljs-comment">// Bogus triangle - probably triangle has zero area</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Compute barycentric coordinates</span><br>    <span class="hljs-type">float</span> oneOverDenom = <span class="hljs-number">1.0f</span> / denom;<br>    b[<span class="hljs-number">0</span>] = (v4*u2 - v2*u4) * oneOverDenom;<br>    b[<span class="hljs-number">1</span>] = (v1*u3 - v3*u1) * oneOverDenom;<br>    b[<span class="hljs-number">2</span>] = <span class="hljs-number">1.0f</span> - b[<span class="hljs-number">0</span>] - b[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">// OK</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种技术可以用于计算三维中的重心坐标，那就是使用叉积来计算三维三角形的面积的方法。给定三角形的两个边矢量 $\bf e_1$ 和 $\bf e_2$，可以将三角形的面积计算为 $\lVert{\bf e_1 \times e_2}\rVert /2$。只要得到整个三角形的面积和 3 个子三角形的面积，就可以计算出其重心坐标。</p><p>当然，这里有一个小问题：叉积的大小对顶点的排序不敏感——按照定义，其大小总是正的。那么三角形之外的点就不适用了，因为三角形之外的点必须始终至少有一个负重心坐标。看起来我们真正需要的是一种计算叉积矢量长度的方法，如果顶点以“不正确”的顺序枚举，则会产生负值。事实证明，使用点积有一种非常简单的方法。</p><p>假设将 $\bf c$ 指定为三角形的两个边矢量的叉积，$\bf c$ 的大小将等于三角形面积的两倍。假设有一个单位长度的法线 $\bf \hat{n}$。现在 $\bf c$ 和 $\bf \hat{n}$ 是平行的，因为它们都垂直于三角形所在的平面。但是，它们可能指向相反的方向，所以：<br>$$<br>\begin{aligned}<br>{\bf c} \cdot {\bf \hat{n}} &amp;= \lVert {\bf c} \rVert \lVert {\bf \hat{n}} \rVert \cos\theta\<br>&amp;= \lVert {\bf c} \rVert(1)(\pm 1)\<br>&amp;= \pm \lVert {\bf c} \rVert<br>\end{aligned}<br>$$</p><p>将此结果除以 2，就可以计算三维中三角形的“有符号面积”。</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_7.png" alt=""></p><p>在上图中，每个顶点都有一个从 $\bf v_i$ 到 $\bf p$ 的矢量，名为 $\bf d_i$。<br>$$<br>\begin{aligned}<br>{\bf e_1} &amp;= {\bf v_3} - {\bf v_2} &amp; {\bf e_2} &amp;= {\bf v_1} - {\bf v_3} &amp; {\bf e_3} &amp;= {\bf v_2} - {\bf v_1}\<br>{\bf d_1} &amp;= {\bf p} - {\bf v_1} &amp; {\bf d_2} &amp;= {\bf p} - {\bf v_2} &amp; {\bf d_3} &amp;= {\bf p} - {\bf v_3}<br>\end{aligned}<br>$$</p><p>我们还需要一个表面法线，可以通过下式计算：<br>$$<br>\bf \hat{n} = \frac{e_1 \times e_2}{\lVert e_1 \times e_2 \rVert}<br>$$</p><p>现在整个三角形（简称为 $T$）的面积和 3 个子三角形的面积可由下式给出：<br>$$<br>\begin{aligned}<br>A(T) &amp;= (({\bf e_1 \times e_2})\cdot{\bf\hat{n}})/2\<br>A(T_1) &amp;= (({\bf e_1 \times d_3})\cdot{\bf\hat{n}})/2\<br>A(T_2) &amp;= (({\bf e_2 \times d_1})\cdot{\bf\hat{n}})/2\<br>A(T_3) &amp;= (({\bf e_3 \times d_2})\cdot{\bf\hat{n}})/2<br>\end{aligned}<br>$$</p><p>每个重心坐标 $b_i$ 可由 $A(T_i)/A(T)$ 给出：<br>$$<br>\begin{aligned}<br>b_1 = A(T_1)/A(T) = \frac{({\bf e_1 \times d_3})\cdot{\bf\hat{n}}}{({\bf e_1 \times e_2})\cdot{\bf\hat{n}}}\<br>b_2 = A(T_2)/A(T) = \frac{({\bf e_2 \times d_1})\cdot{\bf\hat{n}}}{({\bf e_1 \times e_2})\cdot{\bf\hat{n}}}\<br>b_3 = A(T_3)/A(T) = \frac{({\bf e_3 \times d_2})\cdot{\bf\hat{n}}}{({\bf e_1 \times e_2})\cdot{\bf\hat{n}}}\<br>\end{aligned}<br>$$</p><p>请注意，$\bf \hat{n}$ 被用于所有的分子和分母，所以它不一定必须是单位矢量。</p><h2 id="特殊点">特殊点</h2><h3 id="重心">重心</h3><p>重心是三角形完美的平衡点，它是中线的交点（中线是从一个顶点到对边中点的直线）。</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_8.png" alt=""></p><p>重心是 3 个顶点的几何平均值：<br>$$<br>{\bf c_{Grav}} = \frac{\bf v_1 + v_2 + v_3}{3}<br>$$</p><p>重心坐标为：<br>$$<br>(\frac{1}{3}, \frac{1}{3}, \frac{1}{3})<br>$$<br>重心也被称为质心。</p><h3 id="内心">内心</h3><p>三角形的内心是三角形 3 条角平分线的焦点，它之所以被称为内心，是因为它也是三角形内切圆的圆心。由该特性可知，内心与三角形各条边的距离是相等的。</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_9.png" alt=""></p><p>内心可通过下式计算：<br>$$<br>{\bf c_{In}} = \frac{l_1{\bf v_1} + l_2{\bf v_2} + l_3{\bf v_3}}{p}<br>$$<br>其中，$p = l_1 + l_2 + l_3$ 是三角形的周长。因此，内心的重心坐标为：<br>$$<br>(\frac{l_1}{p}, \frac{l_2}{p}, \frac{l_3}{p})<br>$$<br>可以通过下式将三角形的面积除以其周长来计算内切圆的半径：<br>$$<br>r_{In} = \frac{A}{p}<br>$$<br>内切圆解决了找到与 3 条线相切的圆的问题。</p><h3 id="外心">外心</h3><p>外心是三角形中与顶点等距的点，它是围绕三角形的外接圆的圆心。外心构造为各条边的垂直平分线的交点。</p><p><img src="/posts_image/BarycentricCoordinates/BarycentricCoordinates_10.png" alt=""></p><p>要计算外心，需要先定义以下的中间值：<br>$$<br>\begin{aligned}<br>d_1 &amp;= -{\bf e_2}\cdot{\bf e_3},\<br>d_2 &amp;= -{\bf e_3}\cdot{\bf e_1},\<br>d_3 &amp;= -{\bf e_1}\cdot{\bf e_2},\<br>c_1 &amp;= d_2d_3,\<br>c_2 &amp;= d_3d_1,\<br>c_3 &amp;= d_1d_2,\<br>c &amp;= c_1 + c_2 + c_3<br>\end{aligned}<br>$$<br>在取得这些中间值后，即可按下式给出外心的重心坐标：<br>$$<br>(\frac{c_2 + c_3}{2c}, \frac{c_3 + c_1}{2c}, \frac{c_1 + c_2}{2c})<br>$$</p><p>由此，外心可通过下式计算：<br>$$<br>{\bf c_{Circ}} = \frac{(c_2 + c_3){\bf v_1} + (c_3 + c_1){\bf v_2} + (c_1 + c_2){\bf v_3}}{2c}<br>$$</p><p>外接圆半径的计算公式为：<br>$$<br>r_{Circ} = \frac{\sqrt{(d_1 + d_2)(d_2 + d_3)(d_3 + d_1)/c}}{2}<br>$$<br>外接圆半径和外心解决了找到通过三个点的圆的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;三角形&quot;&gt;三角形&lt;/h2&gt;
&lt;p&gt;想要定义一个三角形只需列出其 3 个顶点即可，但是列出这三个顶点的顺序非常重要。在左手坐标系并且从三角形正面看时，通常按照顺时针顺序枚举顶点。我们将这 3 个顶点分别称为 $\bf v_1$， $\bf v_2$， $\bf v_</summary>
      
    
    
    
    <category term="Computer Graphics" scheme="http://example.com/categories/Computer-Graphics/"/>
    
    
    <category term="Math" scheme="http://example.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>四元数和三维旋转(三)</title>
    <link href="http://example.com/posts/%E5%9B%9B%E5%85%83%E6%95%B0%E5%92%8C%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC(%E4%B8%89)/"/>
    <id>http://example.com/posts/%E5%9B%9B%E5%85%83%E6%95%B0%E5%92%8C%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC(%E4%B8%89)/</id>
    <published>2022-07-20T01:52:22.000Z</published>
    <updated>2025-04-17T12:55:15.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四元数插值">四元数插值</h2><p>假设有两个旋转变换 $q_0 = [\cos(\theta_{0}), \sin(\theta_{0})\pmb{u_0}]$ 和 $q_1 = [\cos(\theta_{1}), \sin(\theta_{1})\pmb{u_1}]$，我们希望找出一些中间变换 $q_{t}$，让初始变换 $q_{0}$ 能够平滑地过渡到最终变换 $q_{1}$，$t$ 的取值可以是 $t \in [0, 1]$，当 $t = 0$ 时 $q_{t}$ 等同于初始变换 $q_{0}$，而 $t = 1$ 时 $q_{t}$ 等同于最终变换 $q_{1}$。</p><p>由于插值的对象是两个<strong>变换</strong>，想象起来可能非常困难，我们不妨假设 3D 空间中有任意一个向量 $v$，那么 $q_{0}$ 会将 $v$ 变换到 $v_{0} = q_{0}vq_{0}^<em>$，而 $q_{1}$ 会将 $v$ 变换到 $v_{1} = q_{1}vq_{1}^</em>$。我们需要找出中间向量 $v_{t} = q_{t}vq_{t}^*$ 所对应的变换 $q_{t}$，使 $v$ 旋转到 $v_{0}$ 与 $v_{1}$ 中间的某个位置 $v_{t}$:</p><p><img src="/posts_image/Quaternion/Quaternion_9.png" alt=""></p><p>我们可以看到，这个<strong>旋转的变化量</strong>其实对应的仍是一个旋转。它将由 $q_{0}$ 变换到 $v_{0}$ 的向量进一步旋转到 $v_{t}$。这个旋转拥有某一个固定的旋转轴 $\pmb{u_{t}}$，我们只需要缩放这个变换所对应的角度 $\phi$ 就能够达到插值的目的了。</p><p>那么，现在的问题是，我们该怎么获得这个旋转的变化量。我们不妨考虑一下什么变换 $\Delta q$ 能将已经旋转到 $v_{0}$ 的向量 $v$ 直接变换到 $v_{1}$。这其实就是一个旋转的复合，我们先进行 $q_{0}$ 变换，再进行 $\Delta q$ 变换，它们复合的结果需要等于 $q_{1}$ 变换，也就是说：<br>$$<br>\Delta qq_{0} = q_{1}<br>$$<br>那么，<br>$$<br>\begin{aligned}<br>\Delta qq_{0}q_{0}^{-1} &amp;= q_{1}q_{0}^{-1}\<br>\<br>\Delta q &amp;= q_{1}q_{0}^{-1}\<br>\end{aligned}<br>$$</p><p>因为所有的旋转 $q$ 都是单位四元数，$q^{-1} = q^<em>$，它又可以写成：<br>$$<br>\Delta q = q_{1}q_{0}^</em><br>$$</p><p>如果我们对 $\Delta q$ 取 $t$ 次方，$(\Delta q)^t$ 就能缩放这个旋转所对应的角度了。所以，我们就能得出插值的公式：</p><p>$$<br>q_t = Slerp(q_0, q_1; t) = (q_1q_0^<em>)^tq_0<br>$$<br>可以发现，当 $t = 0$ 时，$q_t = q_0$；而当 $t = 1$ 时，$q_t = q_1$；如果 $t$ 为中间值，比如说 $t = 0.4$ 时，$q_t = (q_{1}q_{0}^</em>)^{0.4}q_{0}$，它会先进行 $q_0$ 变换将 $v$ 变换到 $v_0$，并在此基础上向 $v_1$ 旋转 40%.</p><p>这个插值方法称为Slerp，但它涉及到多个四元数的乘法，而且还包含幂运算，实际应用中效率很低。为了理解它我们还需要研究一下 3D 空间的旋转与四元数的 4D 向量空间之间的关系</p><h3 id="3D空间旋转变化量-vs-四元数4D向量空间夹角">3D空间旋转变化量 vs. 四元数4D向量空间夹角</h3><p>为了探讨这个关系，我们来实际计算一下 $\Delta q$。由于这个关系和角度有关，我们只需要关心 $\Delta q$ 的实部就可以了：</p><p>$$<br>\begin{aligned}<br>\Delta q &amp;= q_{1}q_{0}^*\<br>&amp;= [\cos(\theta_{1}), \sin(\theta_{1})\pmb{u_1}][\cos(\theta_{0}), -\sin(\theta_{0})\pmb{u_0}]\<br>&amp;= [\cos(\theta_{0})\cos(\theta_{1}) - (\sin(\theta_{1})\pmb{u_1})\cdot(-\sin(\theta_{0})\pmb{u_0}), \dots]\<br>&amp;= [\cos(\theta_{0})\cos(\theta_{1}) + (\sin(\theta_{1})\pmb{u_1})\cdot(\sin(\theta_{0})\pmb{u_0}), \dots]\<br>\end{aligned}<br>$$</p><p>如果将 $q_{0}$ 和 $q_{1}$ 看作是两个四维向量，我们可以发现 $\Delta q$ 的实部正好就是 $q_{0}$ 和 $q_{1}$ 点乘的结果 $q_{0} \cdot q_{1}$，因为 $q_{0}$ 和 $q_{1}$ 都是单位四元数，$q_{0} \cdot q_{1}$ 正好是这两个四元数在 4D 空间中夹角的余弦值，我们将这个夹角称为 $\theta$，那么 $q_{0} \cdot q_{1} = \cos(\theta)$</p><p>我们又知道，$\Delta q$ 表示的也是一个旋转，而如果它代表的旋转的角度是 $2\phi$，那么 $\Delta q$ 的实数部为 $\Delta q = [\cos(\phi), \dots]$。所以<br>$$<br>\Delta q = [\cos(\phi), \dots] = [\cos(\theta), \dots]\<br>\cos(\phi) = \cos(\theta)<br>$$</p><p>因为 $\phi$ 和 $\theta$ 都是夹角，$\phi，\theta \in [0, \pi]$，所以这个方程有唯一的解<br>$$<br>\phi = \theta<br>$$</p><p>这也就是说，$q_{0}$ 与 $q_{1}$ 作为向量在 4D 四元数空间中的夹角 $\theta$，正好是它们旋转变化量 $\Delta q$ 的所代表旋转的角度的一半，即 $\theta = \frac{1}{2}(2\phi)$。所以，我们可以直接用插值向量的方法对旋转进行插值。</p><p>为了更直观的理解这层关系，请看下面这两幅图。虽然四元数是出于四维空间之内的，但是因为只有两个四元数，我们可以将它们投影到一个二维的圆上来，也就是左图。右侧则是 3D 空间中发生的旋转改变</p><p><img src="/posts_image/Quaternion/Quaternion_10.png" alt=""></p><p>可以看到，当 $q_{1}$ 与 $q_{0}$ 之间的夹角为 $\theta$ 时，旋转的变化量正好是 $2\theta$。如果我们在圆上有一个单位四元数 $q_{t}$，使得它与 $q_{0}$ 的夹角为 $t\theta$，与 $q_{1}$ 的夹角为 $(1 - t)\theta$，那么我们就能保证在 3D 空间中，它相对于 $q_{0}$ 的旋转变化量为 $2t\theta$，相对于 $q_{1}$ 的旋转变化量为 $2(1 - t)\theta$。</p><p>现在，两个单位四元数的插值就被我们简化为了一个圆上（其实是超球面的一部分）两个向量的插值，我们能直接套用向量的插值公式对两个四元数进行插值。接下来，我们就来讨论如何对两个向量进行插值。</p><h2 id="Lerp-Nlerp-Slerp">Lerp, Nlerp, Slerp</h2><p>不论是哪种插值方法，我们都希望将中间向量 $v_{t}$ 写为初始向量 $v_{0}$ 和最终向量 $v_{1}$ 的线性组合，也就是说：<br>$$<br>v_{t} = \alpha v_{0} + \beta v_{1}<br>$$<br>其中，系数 $\alpha$ 与 $\beta$ 都是 $t$ 的函数。不同的插值方法只是拥有不同的系数而已。</p><h3 id="Lerp">Lerp</h3><p>首先是两个向量插值最简单的一种形式：<strong>线性插值</strong>，也叫做“Lerp”。Lerp 会沿着一条直线进行插值，如果将 $\pmb{v_{0}}$ 和 $\pmb{v_{1}}$ 看做是三角形的两个边，那么 $\pmb{v_{t}}$ 会指向三角形的第三条边。</p><p><img src="/posts_image/Quaternion/Quaternion_11.png" alt=""></p><p>我们能将 $\pmb{v_{t}}$ 写为两个向量的和。<br>$$<br>\begin{aligned}<br>\pmb{v_{t}} = Lerp(\pmb{v_{0}}, \pmb{v_{1}}, t) &amp;= \pmb{v_{0}} + t(\pmb{v_{1}} - \pmb{v_{0}})\<br>&amp;= (1 - t)\pmb{v_{0}} + t\pmb{v_{1}}<br>\end{aligned}<br>$$</p><p>如果将 Lerp 的结果应用到单位四元数上，我们可以得到：<br>$$<br>q_{t} = Lerp(q_{0}, q_{1}, t) = (1 - t)q_{0} + tq_{1}<br>$$<br>当然，因为我们是沿着一条直线（也就是圆上的一个弦）进行插值的，这样插值出来的四元数并不是单位四元数。</p><p><img src="/posts_image/Quaternion/Quaternion_12.png" alt=""></p><h3 id="Nlerp">Nlerp</h3><p>虽然这样插值出来的 $q_{t}$ 并不是单位四元数，但只要将 $q_{t}$ 除以他的模长 $\lVert q_{t} \rVert$ 就能够将其转化为一个单位四元数了。</p><p><img src="/posts_image/Quaternion/Quaternion_13.png" alt=""></p><p>我们将这种先对向量进行插值，再进行正规化的插值方法称为<strong>正规化线性插值</strong>，或者“Nlerp”。与 Lerp 不同，Nlerp 的两个输入向量必须是单位向量，否则插值出来的结果不会经过初始和最终向量。下面分别是向量和四元数的 Nlerp 公式。</p><p>$$<br>v_{t} = Nlerp(\pmb{v_{0}}, \pmb{v_{1}}, t) = \frac{(1 - t)\pmb{v_{0}} + t\pmb{v_{1}}}{\lVert (1 - t)\pmb{v_{0}} + t\pmb{v_{1}} \rVert}\<br>\<br>q_{t} = Nlerp(q_{0}, q_{1}, t) = \frac{(1 - t)q_{0} + tq_{1}}{\lVert (1 - t)q_{0} + tq_{1} \rVert}<br>$$</p><p>Nlerp 插值仍然存在有一定的问题，当需要插值的弧比较大时，$\pmb{v_{t}}$ 的角速度会有显著的变化．我们可以来看一个例子：</p><p><img src="/posts_image/Quaternion/Quaternion_14.png" alt=""></p><p>这五个 $t$ 值将整个弧和弦分割成了四个部分．虽然弦上的四段是等长的，但是四个弧是完全不相等的。$t = 0$ 到 $t = 0.25$ 之间的弧（红色）明显比 $t = 0.25$ 到 $t = 0.50$ 的弧（蓝色）要短了不少．</p><p>这也就是说，在同等时间内，$\pmb{v_{t}}$ 扫过的角度是不同的。$\pmb{v_{t}}$ 扫过的速度（或者说角速度）首先会不断地增加，到 $t = 0.50$ 之后会开始减速，所以 Nlerp 插值不能保证均匀的角速度．</p><h3 id="Slerp">Slerp</h3><p>为了解决这个问题，我们可以转而对角度进行线性插值。也就是说，如果 $\pmb{v_{1}}$ 和 $\pmb{v_{2}}$ 之间的夹角为 $\theta$，那么<br>$$<br>\theta_{t} = (1 - t)\cdot 0 + t\theta = t\theta<br>$$<br>因为对角度线性插值直接是让向量在球面上的一个弧上旋转，所以又称球面线性插值，或者“Slerp”。</p><p>上面的公式并没有涉及到任何的向量，我们希望将 $\pmb{v_{t}}$ 写为 $\pmb{v_{0}}$ 和 $\pmb{v_{1}}$ 的线性组合<br>$$<br>\pmb{v_{t}} = \alpha\pmb{v_{0}} + \beta\pmb{v_{1}}<br>\tag{1}<br>$$<br>这里的 $\pmb{v_{0}}$ 和 $\pmb{v_{1}}$ 仍是单位向量，为了求出这其中的 $\alpha$ 和 $\beta$，我们需要借助图像来找出一些关系：</p><p><img src="/posts_image/Quaternion/Quaternion_15.png" alt=""></p><p>我们可以先对(1)式的两边同时点乘 $\pmb{v_{0}}$<br>$$<br>\begin{aligned}<br>\pmb{v_{0}}\cdot\pmb{v_{t}} &amp;= \pmb{v_{0}}\cdot(\alpha\pmb{v_{0}} + \beta\pmb{v_{1}})\<br>\pmb{v_{0}}\cdot\pmb{v_{t}} &amp;= \alpha(\pmb{v_{0}}\cdot\pmb{v_{0}}) + \beta(\pmb{v_{0}}\cdot\pmb{v_{1}})<br>\end{aligned}<br>$$<br>我们知道，$\pmb{v_{0}}$ 和 $\pmb{v_{t}}$ 之间的夹角是 $t\theta$，$\pmb{v_{0}}$ 与它自身之间的夹角为 0，$\pmb{v_{0}}$ 和 $\pmb{v_{1}}$ 之间的夹角是 $\theta$，而且所有的向量都是单位向量，所以<br>$$<br>\cos(t\theta) = \alpha + \beta\cos(\theta)<br>\tag{2}<br>$$<br>同理，我们将(1)式的两边同时点乘 $\pmb{v_{1}}$，构造第二个方程<br>$$<br>\begin{aligned}<br>\pmb{v_{1}}\cdot\pmb{v_{t}} &amp;= \pmb{v_{1}}\cdot(\alpha\pmb{v_{0}} + \beta\pmb{v_{1}})\<br>\pmb{v_{1}}\cdot\pmb{v_{t}} &amp;= \alpha(\pmb{v_{1}}\cdot\pmb{v_{0}}) + \beta(\pmb{v_{1}}\cdot\pmb{v_{1}})<br>\end{aligned}<br>$$</p><p>$$<br>\cos((1 - t)\theta) = \alpha\cos(\theta) + \beta<br>\tag{3}<br>$$</p><p>现在我们可以用(2)式和(3)式求出 $\alpha$ 和 $\beta$ 了。</p><p>由(2)式可以得到<br>$$<br>\alpha = \cos(t\theta) - \beta\cos(\theta)<br>\tag{4}<br>$$</p><p>将(4)式代入(3)式<br>$$<br>\begin{aligned}<br>\cos((1 - t)\theta) &amp;= (\cos(t\theta) - \beta\cos(\theta))\cos(\theta) + \beta\<br>\cos((1 - t)\theta) &amp;= \cos(t\theta)\cos(\theta) - \beta\cos^2(\theta) + \beta\<br>\beta(1 - \cos^2(\theta)) &amp;= \cos((1 - t)\theta) - \cos(t\theta)\cos(\theta)\<br>\beta &amp;= \frac{\cos(\theta - t\theta) - \cos(t\theta)\cos(\theta)}{\sin^2(\theta)}\<br>\beta &amp;= \frac{\cos(\theta)\cos(t\theta) + \sin(\theta)\sin(t\theta) - \cos(t\theta)\cos(\theta)}{\sin^2(\theta)}\<br>\beta &amp;= \frac{\sin(\theta)\sin(t\theta)}{\sin^2(\theta)}\<br>\beta &amp;= \frac{\sin(t\theta)}{\sin(\theta)}<br>\end{aligned}<br>$$</p><p>将 $\beta$ 代入(4)式解出 $\alpha$<br>$$<br>\begin{aligned}<br>\alpha &amp;= \cos(t\theta) - (\frac{\sin(t\theta)}{\sin(\theta)})\cos(\theta)\<br>&amp;= \frac{\cos(t\theta)\sin(\theta) - \sin(t\theta)\cos(\theta)}{\sin(\theta)}\<br>&amp;= \frac{\sin((1 - t)\theta)}{\sin(\theta)}<br>\end{aligned}<br>$$</p><p>将 $\alpha$ 和 $\beta$ 代回(1)式，我们可以得到向量的Slerp公式<br>$$<br>\pmb{v_{t}} = Slerp(\pmb{v_{0}}, \pmb{v_{1}}, t) = \frac{\sin((1 - t)\theta)}{\sin(\theta)}\pmb{v_{0}} + \frac{\sin(t\theta)}{\sin(\theta)}\pmb{v_{1}}<br>$$<br>类似地，我们有四元数的 Slerp 公式：<br>$$<br>q_{t} = Slerp(q_{0}, q_{1}, t) = \frac{\sin((1 - t)\theta)}{\sin(\theta)}q_{0} + \frac{\sin(t\theta)}{\sin(\theta)}q_{1}<br>$$<br>其中 $q_{0}$ 与 $q_{1}$ 之间的夹角 $\theta$ 可以直接使用它们点乘的结果来得出，即<br>$$<br>\theta = \arccos(q_{0} \cdot q_{1})<br>$$</p><p>这里导出的公式会比之前利用幂运算的公式要高效很多，但是它仍然涉及到三个三角函数以及一个反三角函数的运算，所以还是会比 Nlerp 要慢一点。如果要插值的角度比较小的话，Nlerp 其实相对于 Slerp 的误差并没有那么大。为了提高效率，我们经常会使用 Nlerp 来代替 Slerp。我们也能用一些数值分析的方法来近似并优化四元数的 Slerp。</p><p>除了效率问题之外，我们在实现 Slerp 时要注意，如果单位四元数之间的夹角 $\theta$ 非常小，那么 $\sin(\theta)$ 可能会由于浮点数的误差被近似为 0.0，从而导致除以 0 的错误．所以，我们在实施 Slerp 之前，需要检查两个四元数的夹角是否过小（或者完全相同）。一旦发现这种问题，我们就必须改用 Nlerp 对两个四元数进行插值，这时候 Nlerp 的误差非常小所以基本不会与真正的 Slerp 有什么区别。</p><h3 id="双倍覆盖带来的问题">双倍覆盖带来的问题</h3><p>如果你还记得，两个不同的单位四元数 $q$ 与 $-q$ 对应的其实是同一个旋转，这个特性显然会对我们的插值造成一些影响．虽然 $q$ 与 $-q$ 对向量变换的最终效果是完全相同的，但是它们作为向量相差了 $\pi$ 弧度：</p><p><img src="/posts_image/Quaternion/Quaternion_16.png" alt=""></p><p>可以看到，虽然我们能够将 $q_{0}$ 向左插值至 $q_{1}$（蓝色的弧），但这会将 3D 空间中的向量旋转接近 360 度，而实际上这两个旋转相差并没有那么多，它并不是 3D 空间中的弧面最短路径。而如果我们将 $q_{0}$ 向右插值至等价的 $-q_{1}$（红色的弧），它的旋转变化量就会比插值到 $q_{1}$ 要小很多，所以 $q_{0}$ 插值到 $-q_{1}$ 才是插值的最短路径。</p><p>这也就告诉我们，在对两个单位四元数进行插值之前，我们需要先检测 $q_{0}$ 与 $q_{1}$ 之间是否是钝角，即检测它们点积的结果 $q_{0} \cdot q_{1}$ 是否为负数。如果 $q_{0} \cdot q_{1} &lt; 0$ ，那么我们就反转其中的一个四元数，比如说将 $q_{1}$ 改为 $-q_{1}$，并使用 $q_{0}$ 与 $-q_{1}$ 之间新的夹角来进行插值，这样才能保证插值的路径是最短的。</p><h2 id="Squad">Squad</h2><p>Slerp已经是我们理想中的插值方式了：它直接对角度插值，插值角度匀速变化，运算效率尚可。但是它还有一个小问题：角度变化的速率等于夹角，即 $\frac{d\theta_{t}}{dt} = \frac{d}{dt}(t\theta) = \theta$，这就意味着，当我们在多个角速度之间插值的时候，当在不同的四元数之间插值的时候，速率会发生突变，或者说在切断点处不可导。从数学上讲，函数 $f$ 连续并不意味着函数的一阶导连续（前者称为 $C^0$ 连续，后者称为 $C^1$ 连续）。</p><p>为此，我们希望能以<strong>牺牲固定角速度</strong>为条件，让插值的曲线能够在高阶导处也连续，下面介绍的Squad（Spherical and quadrangle）就是一种解决方法。</p><h3 id="Bezier-曲线">Bézier 曲线</h3><p>假设我们有一个向量的序列 $\pmb{v_{0}}$， $\pmb{v_{1}}$，$\dots$，$\pmb{v_{n}}$，如果我们想对这个序列进行插值，那么我们可以分别对每一对向量 $\pmb{v_{i}}$ 和 $\pmb{v_{i+1}}$ 进行插值，然后将插值的曲线连接起来，也就是我们所说的样条（Spline）．如果直接使用 Lerp 的话，我们会得到这样的结果（假设我们只有五个向量需要插值 $\pmb{v_{0}}$，$\pmb{v_{1}}$，$\pmb{v_{2}}$，$\pmb{v_{3}}$，$\pmb{v_{4}}$）：</p><p><img src="/posts_image/Quaternion/Quaternion_17.png" alt=""></p><p>很明显，这个曲线虽然是连续的，但是它的一阶导数（切线）在切换插值向量时都不是连续的。为了解决这个问题，我们最常使用的就是 Bézier 曲线。我们一开始的想法可能会是将中间的 $\pmb{v_{1}}$，$\pmb{v_{2}}$，$\pmb{v_{3}}$ 作为控制点，直接使用一个四次 Bézier 曲线（因为有五个点）来生成这个近似曲线。但是 Bézier 曲线只会经过初始点与最终点（插值），一般不会经过中间的控制点（近似），所以这样求出来的曲线虽然是可导的，但是插值曲线不会经过中间的三个向量：</p><p><img src="/posts_image/Quaternion/Quaternion_18.png" alt=""></p><p>为了解决这个问题，我们可以分段对每两个向量 $\pmb{v_{i}}$ 和 $\pmb{v_{i+1}}$ 之间使用 Bézier曲线进行插值，之后将所有的曲线（样条）连接起来．因为我们需要让曲线的一阶导数（或者说曲线的趋势）连续，我们还需要知道它们的前一个向量 $\pmb{v_{i-1}}$ 和后一个向量 $\pmb{v_{i+2}}$，并且用它们生成两个控制点 $\pmb{s_{i}}$ 和 $\pmb{s_{i+1}}$ 来控制曲线的趋势．我们会使用 $\pmb{v_{i}}$ 和 $\pmb{v_{i+1}}$ 作为端点（曲线会经过这两个点），$\pmb{s_{i}}$ 和 $\pmb{s_{i+1}}$ 作为中间的控制点，使用一个三次 Bézier 曲线（Cubic Bézier Curve，四个点）来近似这个两个向量之间的插值。</p><p>在我们的例子中，因为我们一共有四对向量（$\pmb{v_{0}}\pmb{v_{1}}$、$\pmb{v_{1}}\pmb{v_{2}}$、$\pmb{v_{2}}\pmb{v_{3}}$、$\pmb{v_{3}}\pmb{v_{4}}$），我们会使用四个三次 Bézier 曲线对这五个点进行插值．我们知道，对于三次Bézier 曲线所产生的样条，如果想让最终的插值曲线达到 $C^1$ 连续，则需要让前一个样条在 $\pmb{v_{i}}$ 的控制点与当前样条在 $\pmb{v_{i}}$ 的控制点分别处于最终曲线在 $\pmb{v_{i}}$ 处切线对等的两侧：</p><p><img src="/posts_image/Quaternion/Quaternion_19.png" alt=""></p><p>在上面的曲线中，蓝色的线就是曲线在点 $\pmb{v_{i}}$ 处的切线，红色的点就是三次 Bézier 曲线的控制点，分别处于切线对等的两侧．对于两个端点 $\pmb{v_{0}}$ 和 $\pmb{v_{4}}$，我们直接将这两个向量的控制点取为它们本身（这不是唯一的做法，但这样是可行的），最终得到一个平滑的曲线。我们希望将类似的逻辑带到四元数的超球面上，得到四元数序列的插值的方法，但在此之前我们需要了解如何构造一个三次 Bézier 曲线。</p><h3 id="de-Casteljau-算法">de Casteljau 算法</h3><p>Bézier 曲线的构造有个著名的递归算法叫做 de Casteljau 算法（de Casteljau’s Algorithm），它对任意次方的 Bézier 曲线都是成立的，但是这里我们只关注三次 Bézier 曲线的情况。</p><p>这个算法最基本的思想就是线性插值的嵌套。假设我们有四个向量 $\pmb{v_{0}}$，$\pmb{v_{1}}$，$\pmb{v_{2}}$，$\pmb{v_{3}}$，那么我们可以这样子获得最终的三次 Bézier 曲线：</p><p>首先，我们对每一对向量 $\pmb{v_{0}}\pmb{v_{1}}$、$\pmb{v_{1}}\pmb{v_{2}}$、$\pmb{v_{2}}\pmb{v_{3}}$ 进行线性插值，获得 $\pmb{v_{01}}$、$\pmb{v_{12}}$、$\pmb{v_{23}}$：</p><p>$$<br>\pmb{v_{01}} = Lerp(\pmb{v_{0}}, \pmb{v_{1}}; t)\<br>\pmb{v_{12}} = Lerp(\pmb{v_{1}}, \pmb{v_{2}}; t)\<br>\pmb{v_{23}} = Lerp(\pmb{v_{2}}, \pmb{v_{3}}; t)\<br>$$</p><p>之后，我们对 $\pmb{v_{01}}\pmb{v_{12}}$ 和 $\pmb{v_{12}}\pmb{v_{23}}$ 这两对向量进行线性插值，获得 $\pmb{v_{012}}$ 和 $\pmb{v_{123}}$</p><p>$$<br>\pmb{v_{012}} = Lerp(\pmb{v_{01}}, \pmb{v_{12}}; t)\<br>\pmb{v_{123}} = Lerp(\pmb{v_{12}}, \pmb{v_{23}}; t)\<br>$$</p><p>最后，对 $\pmb{v_{012}}$ 和 $\pmb{v_{123}}$ 进行线性插值获得 $\pmb{v_{0123}}$，这个向量就是我们想要的最终结果，它就是三次 Bézier 曲线上的点：</p><p>$$<br>\pmb{v_{0123}} = Lerp(\pmb{v_{012}}, \pmb{v_{123}}; t)\<br>$$</p><p>虽然这个算法看起来很繁琐，但是我们可以通过一张图来理解它（取 $t$ = 0.4）：</p><p><img src="/posts_image/Quaternion/Quaternion_20.png" alt=""></p><p>可以看到，虽然我们一直在使用线性插值，最终获得的却是一条三次 Bézier 曲线（黑色的线）。</p><p>如果将这些式子合并起来，我们就能得到三次 Bézier 曲线的递归公式。因为这个式子太长了，我将 $Lerp(\pmb{v_{i}}, \pmb{v_{i+1}}; t)$ 简写为 $L(\pmb{v_{i}}, \pmb{v_{i+1}}; t)$：<br>$$<br>Bézier(\pmb{v_{0}}, \pmb{v_{1}}, \pmb{v_{2}}, \pmb{v_{3}}; t) = L(L(L(\pmb{v_{0}}, \pmb{v_{1}}; t), L(\pmb{v_{1}}, \pmb{v_{2}}; t); t), L(L(\pmb{v_{1}}, \pmb{v_{2}}; t), L(\pmb{v_{2}}, \pmb{v_{3}}; t); t); t)<br>$$</p><p>如果将 Lerp 的定义 $Lerp(\pmb{v_{i}}, \pmb{v_{i+1}}; t) = (1 - t)\pmb{v_{i}} + t\pmb{v_{i+1}}$ 不断代入并展开的话，我们就能获得这样一个式子：<br>$$<br>Bézier(\pmb{v_{0}}, \pmb{v_{1}}, \pmb{v_{2}}, \pmb{v_{3}}; t) = (1 - t)^3\pmb{v_{0}} + 3(1 - t)^2t\pmb{v_{1}} + 3(1 - t)t^2\pmb{v_{2}} + t^3\pmb{v_{3}}<br>$$</p><p>因为每项的次数都是 3，所以我们说它是一个三次 Bézier 曲线。</p><p>我们可以直接将递归的公式运用到四元数上，得到四元数的球面 Bézier 曲线公式，但因为球面的线性插值不是 Lerp 而是 Slerp，我们需要将公式中所有的 Lerp 全部换成 Slerp（你可以想象一下，将四个向量形成的四边形看作是一个网格（Mesh），之后将这个网格贴在球面上）。同样因为公式太长，我会将 $Slerp(q_{i}, q_{i+1}; t)$ 简写为 $S(q_{i}, q_{i+1}; t)$：<br>$$<br>SBézier(q_{0}, q_{1}, q_{2}, q_{3}; t) = S(S(S(q_{0}, q_{1}; t), S(q_{1}, q_{2}; t);t),S(S(q_{1}, q_{2}; t), S(q_{2}, q_{3}; t); t); t)<br>$$<br>很明显这个方法实在是太复杂了。仅仅是一个 Slerp 就要使用四个三角函数，而我们这里一共有 7个 Slerp，如果真的要使用它进行插值会对性能产生非常大的影响。</p><h3 id="Squad-2">Squad</h3><p>三次 Bézier 曲线实际上是嵌套了三层一次（one-order）插值，而 Squad 则使用的是一层二次插值嵌套了一层一次插值。</p><p>我们首先是分别对 $\pmb{v_{0}}\pmb{v_{3}}$ 和 $\pmb{v_{1}}\pmb{v_{2}}$ 进行插值，得到 $\pmb{v_{03}}$ 和 $\pmb{v_{12}}$：<br>$$<br>\pmb{v_{03}} = Lerp(\pmb{v_{0}}, \pmb{v_{3}}; t)\<br>\pmb{v_{12}} = Lerp(\pmb{v_{1}}, \pmb{v_{2}}; t)\<br>$$<br>之后，我们使用 $2t(1 - t)$ 为参数，对 $\pmb{v_{03}}\pmb{v_{12}}$ 进行二次插值，得到最终的 $\pmb{v_{0312}}$ ：<br>$$<br>\pmb{v_{0312}} = Lerp(\pmb{v_{03}}, \pmb{v_{12}}; 2t(1 - t))\<br>$$</p><p>上述过程可以通过下图阐明（$t = 0.4$），黑色曲线就是生成的插值曲线：</p><p><img src="/posts_image/Quaternion/Quaternion_21.png" alt=""></p><p>当然，我们也可以把它写成递归形式：<br>$$<br>Squad(\pmb{v_{0}}, \pmb{v_{1}}, \pmb{v_{2}}, \pmb{v_{3}}; t) = Lerp(Lerp(\pmb{v_{0}}, \pmb{v_{3}}; t), Lerp(\pmb{v_{1}}, \pmb{v_{2}}; t); 2t(1 - t))<br>$$</p><p>可以看到，这样的插值要比三次 Bézier 曲线简单很多，将七次 Lerp 减少到了三次．虽然最终的曲线与三次 Bézier 曲线不完全相同，但是已经很近似了。我们可以看几个对比。下图中，左边是三次 Bézier 曲线，右边是 Squad 曲线：</p><p><img src="/posts_image/Quaternion/Quaternion_22.png" alt=""></p><p>如果利用 Lerp 的定义 $Lerp(\pmb{v_{i}}, \pmb{v_{i+1}}; t) = (1 - t)\pmb{v_{i}} + t\pmb{v_{i+1}}$ 将递归式展开的话，我们能得到这样的式子<br>$$<br>Squad(\pmb{v_{0}}, \pmb{v_{1}}, \pmb{v_{2}}, \pmb{v_{3}}; t) = (2t^2 - 2t + 1)(1 - t)\pmb{v_{0}} + 2(1 - t)^2t\pmb{v_{1}} + 2(1 - t)t^2\pmb{v_{2}} + t(2t^2 - 2t + 1)\pmb{v_{3}}<br>$$</p><p>它仍是一个三次曲线，只不过系数有所不同。</p><p>如果我们将这个递归公式用于球面，就能得到四元数的 Squad 公式。<br>$$<br>Squad(q_{0}, q_{1}, q_{2}, q_{3}; t) = Slerp(Slerp(q_{0}, q_{3}; t), Slerp(q_{1}, q_{2}; t); 2t(1 - t))<br>$$</p><p>我们知道 $Slerp(q_{i}, q_{i+1}; t) = (q_{i+1}q_{i}^<em>)^tq_{i}$，所以我们可以将 Squad 写成指数形式：<br>$$<br>Squad(q_{0}, q_{1}, q_{2}, q_{3}; t) = (Slerp(q_{1}, q_{2}; t)(Slerp(q_{0}, q_{3}; t))^</em>)^{2t(1-t)}Slerp(q_{0}, q_{3}; t)<br>$$</p><h3 id="Squad-应用">Squad 应用</h3><p>接下来，我们回到本章最初的主题，对多个单位四元数进行插值。如果我们有一个四元数序列 $q_{0}$，$q_{1}$，$\dots$，$q_{n}$，我们希望对每一对四元数 $q_{i}$ 和 $q_{i+1}$ 都使用 Squad 进行插值，所以我们有<br>$$<br>Squad(q_{i}, s_{i}, s_{i+1}, q_{i+1}; t) = Slerp(Slerp(q_{i}, q_{i+1}; t), Slerp(s_{i}, s_{i+1}; t); 2t(1 - t))<br>$$<br>现在，留下来的问题就是找出中间的控制点 $s_{i}$ 和 $s_{i+1}$ 了。类似于 Bézier 曲线的样条，我们同样需要前一个四元数 $q_{i-1}$ 以及 $q_{i+2}$ 的信息。</p><p>$s_{i}$ 的推导还是比较复杂的，但是它最基本的理念非常简单：让 Squad 在切换点可导，从而达到 $C^1$ 连续。也就是说，我们希望 $q_{i-1}q_{i}$ 插值时在 $t = 1$ 处的导数，与 $q_{i}q_{i+1}$ 插值时在 $t = 0$ 处的导数相等：<br>$$<br>Squad’(q_{i-1}, s_{i-1}, s_{i}, q_{i}; 1) = Squad’(q_{i}, s_{i}, s_{i+1}, q_{i+1}; 0)<br>$$</p><p>如果我们想要从这里继续推导下去的话，就需要用到单位四元数导数的定义（它和 $q = [\cos(\theta), \sin(\theta)\pmb{u}] = e^{u\theta}$ 有关）。最终得到<br>$$<br>s_{i} = q_{i}exp(-\frac{\log(q_{i}^*q_{i-1}) + \log(q_{i}^*q_{i+1})}{4})<br>$$<br>注意，和 Bézier 曲线的样条不同的是，这里的 $s_{i}$ 在对 $q_{i-1}q_{i}$ 插值时和对 $q_{i}q_{i+1}$ 插值时都是相同的，不像之前是处于切线的两端不同的两个向量。</p><p>与两个四元数之间的插值一样，Squad 同样会受到双重覆盖的影响。我们在计算中间控制点和插值之前，需要先选中一个四元数，比如说 $q_{i}$，检测它与其它三个四元数之间的夹角，如果是钝角就翻转，将插值的路线减到最小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;四元数插值&quot;&gt;四元数插值&lt;/h2&gt;
&lt;p&gt;假设有两个旋转变换 $q_0 = [\cos(\theta_{0}), \sin(\theta_{0})\pmb{u_0}]$ 和 $q_1 = [\cos(\theta_{1}), \sin(\theta_{1})\pm</summary>
      
    
    
    
    <category term="Computer Graphics" scheme="http://example.com/categories/Computer-Graphics/"/>
    
    
    <category term="Math" scheme="http://example.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>四元数和三维旋转(二)</title>
    <link href="http://example.com/posts/%E5%9B%9B%E5%85%83%E6%95%B0%E5%92%8C%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC(%E4%BA%8C)/"/>
    <id>http://example.com/posts/%E5%9B%9B%E5%85%83%E6%95%B0%E5%92%8C%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC(%E4%BA%8C)/</id>
    <published>2022-07-18T02:09:23.000Z</published>
    <updated>2025-04-17T12:55:15.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四元数">四元数</h2><p>所有的四元数 $q \in \mathbb{H}$ 都可以写成下面这种形式：<br>$$<br>q = a + bi + cj + dk,(a,b,c,d \in \mathbb{R})<br>$$</p><p>其中<br>$$<br>i^2 = j^2 = k^2 = ijk = -1<br>$$</p><p>如果把上式称为四元数的<strong>代数形式</strong>，那么和复数类似，它也有对应的<strong>向量形式一</strong>：<br>$$<br>q = \begin{bmatrix}<br>a\ b\ c\ d\<br>\end{bmatrix}<br>$$</p><p>如果将四元数 $q$ 的实部和虚部分开，并用一个三维的向量来表示虚部，将它表示为标量和向量的有序对形式，那么四元数还可以表示为下述的<strong>向量形式二</strong>：<br>$$<br>q = [s, \pmb{v}], (\pmb{v} = \begin{bmatrix} x\ y\ z\ \end{bmatrix},\quad s,x,y,z \in \mathbb{R})<br>$$</p><h3 id="四元数的性质">四元数的性质</h3><h4 id="四元数的模长">四元数的模长</h4><p>仿照复数模长的定义，我们可以暂时将四元数 $q = a + bi + cj + dk$ 的模长定义为<br>$$<br>\lVert q \rVert = \sqrt{a^2 + b^2 + c^2 + d^2}<br>$$<br>如果用标量向量有序对的形式进行表示的话，$q = [s, \pmb{v}]$ 的模长为：<br>$$<br>\lVert q \rVert = \sqrt{s^2 + \lVert\pmb{v}\rVert^2} = \sqrt{s^2 + \pmb{v}\cdot\pmb{v}}<br>$$</p><h4 id="四元数的加减法">四元数的加减法</h4><p>与复数类似，四元数的加法只需要将分量相加就可以了，如果我们有两个四元数 $q_{1} = a + bi + cj + dk$，$q_{2} = e + fi + gj + hk$，那么它们的和为<br>$$<br>\begin{aligned}<br>q_{1} + q_{2} &amp;= a + bi + cj + dk + e + fi + gj + hk\<br>&amp;= (a + e) + (b + f)i + (c + g)j + (d + h)k<br>\end{aligned}<br>$$</p><p>减法同理，将加号改为减号就可以了<br>$$<br>q_{1} - q_{2} = (a - e) + (b - f)i + (c - g)j + (d - h)k<br>$$</p><p>如果四元数是以标量向量有序对形式定义的，比如说 $q_{1} = [s, \pmb{v}]$，$q_{2} = [t, \pmb{u}]$，那么<br>$$<br>q_{1} \pm q_{2} = [s \pm t, \pmb{v}\pm\pmb{u}]<br>$$</p><h4 id="四元数的标量乘法">四元数的标量乘法</h4><p>如果我们有一个四元数 $q = a + bi + cj + dk$ 和一个标量 $s$，那么它们的乘积为：<br>$$<br>\begin{aligned}<br>sq &amp;= s(a + bi + cj + dk)\<br>&amp;= sa + sbi + scj + sdk<br>\end{aligned}<br>$$</p><p>四元数与标量的乘法遵守交换律，也就是说 $sq = qs$</p><h4 id="四元数乘法">四元数乘法</h4><p>四元数之间的乘法不遵守交换律，也就是说一般情况下 $q_{1}q_{2} \neq q_{2}q_{1}$。这也就有了左乘和右乘的区别，如果是 $q_{1}q_{2}$，我们就说&quot;$q_{2}$ 左乘以 $q_{1}$“，如果是 $q_{2}q_{1}$，那我们就说”$q_{2}$ 右乘以 $q_{1}$&quot;。除了交换律之外，结合律和分配律在四元数内都是成立的。</p><p>如果有两个四元数 $q_{1} = a + bi + cj + dk$ 和 $q_{2} = e + fi + gj + hk$，那么<br>$$<br>\begin{aligned}<br>q_{1}q_{2} &amp;= (a + bi + cj + dk)(e + fi + gj + hk)\<br>&amp;= ae + afi + agj + ahk +\<br>&amp;\quad bei + bfi^2 + bgij + bhik +\<br>&amp;\quad cej + cfji + cgj^2 + chjk +\<br>&amp;\quad dek + dfki + dgkj + dhk^2<br>\end{aligned}<br>$$</p><p>由 $i^2 = j^2 = k^2 = ijk = -1$ 我们可以推导出 $jk = i$，$ij = k$，$ki = j$，$kj = -i$，$ji = -k$，$ik = -j$，于是我们可以得到：</p><p><img src="/posts_image/Quaternion/Quaternion_7.png" alt=""></p><p>容易观察到交换律并不成立。利用上面的表格，我们可以对四元数之间的乘法进行归纳化简：<br>$$<br>\begin{aligned}<br>q_{1}q_{2}<br>&amp;= ae + afi + agj + ahk +\<br>&amp;\quad bei + bfi^2 + bgij + bhik +\<br>&amp;\quad cej + cfji + cgj^2 + chjk +\<br>&amp;\quad dek + dfki + dgkj + dhk^2\<br>&amp;= (a\textcolor{red}{e} - b\textcolor{blue}{f} - c\textcolor{green}{g} - d\textcolor{orange}{h})+\<br>&amp;\quad (b\textcolor{red}{e} + a\textcolor{blue}{f} - d\textcolor{green}{g} + c\textcolor{orange}{h})i+\<br>&amp;\quad (c\textcolor{red}{e} + d\textcolor{blue}{f} + a\textcolor{green}{g} - b\textcolor{orange}{h})j+\<br>&amp;\quad (d\textcolor{red}{e} - c\textcolor{blue}{f} + b\textcolor{green}{g} + a\textcolor{orange}{h})k\<br>\end{aligned}<br>$$</p><h4 id="矩阵形式">矩阵形式</h4><p>可以看到，四元数的相乘其实也是一个线性组合，我们同样可以将它写成矩阵的形式：<br>$$<br>q_{1}q_{2} =<br>\begin{bmatrix}<br>a&amp;-b&amp;-c&amp;-d\<br>b&amp;a&amp;-d&amp;c\<br>c&amp;d&amp;a&amp;-b\<br>d&amp;-c&amp;b&amp;a\<br>\end{bmatrix}<br>\begin{bmatrix}<br>\textcolor{red}{e}\<br>\textcolor{blue}{f}\<br>\textcolor{green}{g}\<br>\textcolor{orange}{h}\<br>\end{bmatrix}<br>$$</p><p>注意，这个矩阵所作出的变换等价于<strong>左乘 $q_{1}$</strong>。因为四元数不符合乘法交换律，所以<strong>右乘 $q_{1}$<strong>的变换是一个不同的矩阵，它可以使用完全相同的方法推导而得，下面这个矩阵所作出的变换等价于</strong>右乘 $q_{1}$</strong></p><p>$$<br>q_{2}q_{1} =<br>\begin{bmatrix}<br>a&amp;-b&amp;-c&amp;-d\<br>b&amp;a&amp;d&amp;-c\<br>c&amp;-d&amp;a&amp;b\<br>d&amp;c&amp;-b&amp;a\<br>\end{bmatrix}<br>\begin{bmatrix}<br>\textcolor{red}{e}\<br>\textcolor{blue}{f}\<br>\textcolor{green}{g}\<br>\textcolor{orange}{h}\<br>\end{bmatrix}<br>$$</p><h4 id="Grasmann积">Graßmann积</h4><p>重新整理之前的乘法结果：</p><p>$$<br>\begin{aligned}<br>q_{1}q_{2} &amp;= (ae -(bf + cg + dh))+\<br>&amp;\quad(b\textcolor{red}{e} + \textcolor{blue}{a}f + ch - dg)i+\<br>&amp;\quad(c\textcolor{red}{e} + \textcolor{blue}{a}g + df - bh)j+\<br>&amp;\quad(d\textcolor{red}{e} + \textcolor{blue}{a}h + bg - cf)k\<br>\end{aligned}<br>$$</p><p>如果令 $\pmb{v} = \begin{bmatrix}b\ c\ d\ \end{bmatrix}$，$\pmb{u} = \begin{bmatrix}f\ g\ h\ \end{bmatrix}$，那么</p><p>$$<br>\pmb{v}\cdot\pmb{u} = bf + cg + dh<br>$$<br>$$<br>\begin{aligned}<br>\pmb{v}\times\pmb{u} &amp;=<br>\begin{vmatrix}<br>\pmb{i}&amp;\pmb{j}&amp;\pmb{k}\<br>b&amp;c&amp;d\<br>f&amp;g&amp;h\<br>\end{vmatrix}\<br>&amp;= (ch - dg)\pmb{i} - (bh - df)\pmb{j} + (bg - cf)\pmb{k}<br>\end{aligned}<br>$$</p><p>注意 $\pmb{v}\times\pmb{u}$ 的结果是一个向量，这里的 $\pmb{i}、\pmb{j}、\pmb{k}$ 是向量的基，如果使用标量向量有序对形式来表示，$q_{1}q_{2}$ 的结果可以用向量点乘和叉乘的形式表示出来</p><p>$$<br>q_{1}q_{2} = [ae - \pmb{v}\cdot\pmb{u}, a\pmb{u} + e\pmb{v} + \pmb{v}\times\pmb{u}]<br>$$</p><p>这个结果也被叫做 <strong>Graßmann积</strong>，一般来说：</p><div class="note note-primary">            <p><strong>Theorem 7：Graßmann积</strong><br>对任意四元数 $q_{1} = [s, \pmb{v}]$，$q_{2} = [t, \pmb{u}]$，$q_{1}q_{2}$ 的结果是<br>$$<br>q_{1}q_{2} = [st - \pmb{v}\cdot\pmb{u}, s\pmb{u} + t\pmb{v} + \pmb{v}\times\pmb{u}]<br>$$</p>          </div><h4 id="纯四元数">纯四元数</h4><p>实部为零，仅有虚部的四元数为<strong>纯四元数</strong>，即：<br>$$<br>q = [0, \pmb{v}]<br>$$</p><p>对于两个纯四元数 $q_{1} = [0, \pmb{v}]$，$q_{2} = [0, \pmb{u}]$，那么它们的乘积为：<br>$$<br>q_{1}q_{2} = [-\pmb{v}\cdot\pmb{u}, \pmb{v}\times\pmb{u}]<br>$$</p><h4 id="共轭">共轭</h4><p>四元数 $q = a + bi + cj + dk$ 的<strong>共轭</strong>为 $q^* = a - bi - cj - dk$。如果用标量向量有序对的形式来定义的话，$q = [s, \pmb{v}]$ 的共轭为 $q^* = [s, -\pmb{v}]$。共轭四元数的一个非常有用的性质就是<br>$$<br>\begin{aligned}<br>qq^* &amp;= [s, \pmb{v}]\cdot[s, -\pmb{v}]\<br>&amp;= [s^2 - \pmb{v}\cdot(-\pmb{v}), s(-\pmb{v}) + s\pmb{v} + \pmb{v}\times(-\pmb{v})]\<br>&amp;= [s^2 + \pmb{v}\cdot\pmb{v}, 0]\<br>&amp;= s^2 + x^2 + y^2 + z^2\<br>&amp;= \lVert q \rVert^2<br>\end{aligned}<br>$$<br>结果是一个标量，正是四元数模长的平方。<br>$$<br>q^<em>q = (q^</em>)(q^<em>)^</em> = \lVert q^* \rVert^2 = \lVert q \rVert^2<br>$$<br>我们得到，$q^<em>q = qq^</em>$，这个特殊的乘法遵守交换律。</p><h4 id="逆">逆</h4><p>因为四元数乘法不遵守交换律，我们不会将两个四元数相除写为 $\frac{p}{q}$ 的形式，取而代之的是将乘法的逆运算定义为 $pq^{-1}$ 或者 $q^{-1}p$，注意它们的结果一般是不同的。</p><p>其中，$q^{-1}$ 是 $q$ 的<strong>逆</strong>，我们规定<br>$$<br>qq^{-1} = q^{-1}q = 1\quad(q \neq 0)<br>$$</p><p>右乘 $q$ 的逆运算为右乘 $q^{-1}$，左乘 $q$ 的逆运算为左乘 $q^{-1}$。</p><p>利用共轭，我们可以进行如下推导：<br>$$<br>\begin{aligned}<br>qq^{-1} &amp;= 1\<br>q^<em>qq^{-1} &amp;= q^</em>\<br>\lVert q \rVert^2q^{-1} &amp;= q^<em>\<br>q^{-1} &amp;= \frac{q^</em>}{\lVert q \rVert^2}\<br>\end{aligned}<br>$$</p><p>四元数的逆就是它的共轭除以它模长的平方。如果 $\lVert q \rVert = 1$，那么它的逆就是它的共轭，此时称 $q$ 为一个<strong>单位四元数</strong>。</p><h3 id="四元数与3D旋转">四元数与3D旋转</h3><p>如果我们需要将一个向量 $\pmb{v}$ 沿着一个用单位向量所定义的旋转轴 $\pmb{u}$ 旋转 $\theta$ 度，那么我们可以将这个向量 $\pmb{v}$ 拆分为正交于旋转轴的 $\pmb{v_{\perp}}$ 以及平行于旋转轴的 $\pmb{v_{\parallel}}$。我们可以对这两个分向量分别进行旋转，获得 $\pmb{v_{\perp}‘}$ 和 $\pmb{v_{\parallel}’}$。将它们相加就是 $\pmb{v}$ 旋转之后的结果 $\pmb{v’} = \pmb{v_{\perp}‘} + \pmb{v_{\parallel}’}$。</p><p>我们可以将这些向量定义为纯四元数：</p><p>$$<br>\begin{aligned}<br>v &amp;= [0, \pmb{v}]\<br>v_{\perp} &amp;= [0, \pmb{v_{\perp}}]\<br>v_{\parallel} &amp;= [0, \pmb{v_{\parallel}}]\<br>v’ &amp;= [0, \pmb{v’}]\<br>v_{\perp}’ &amp;= [0, \pmb{v_{\perp}‘}]\<br>v_{\parallel}’ &amp;= [0, \pmb{v_{\parallel}'}]\<br>u &amp;= [0, \pmb{u}]<br>\end{aligned}<br>$$</p><p>那么我们就能得到</p><p>$$<br>v = v_{\parallel} + v_{\perp} \qquad v’ = v_{\parallel}’ + v_{\perp}’<br>$$</p><p>和之前一样，我们这里也分开讨论 $v_{\perp}$ 和 $v_{\parallel}$ 的情况。</p><h4 id="v-perp-的旋转">$v_{\perp}$ 的旋转</h4><p>我们在上一篇推导过，如果一个向量 $\pmb{v_{\perp}}$ 正交于旋转轴 $\pmb{u}$，那么</p><p>$$<br>\pmb{v_{\perp}'} = \cos(\theta)\pmb{v_{\perp}} + \sin(\theta)(\pmb{u}\times\pmb{v_{\perp}})<br>$$</p><p>而且，对于两个纯四元数 $q_{1} = [0, \pmb{v}]$，$q_{2} = [0, \pmb{u}]$，那么它们的乘积为 $q_{1}q_{2} = [-\pmb{v}\cdot\pmb{u}, \pmb{v}\times\pmb{u}]$，类似地，<br>$$<br>uv_{\perp} = [-\pmb{u}\cdot\pmb{v_{\perp}}, \pmb{u}\times\pmb{v_{\perp}}]<br>$$<br>因为 $\pmb{v_{\perp}}$ 正交于 $\pmb{u}$，所以 $\pmb{u}\cdot\pmb{v_{\perp}} = 0$，也就是说，<br>$$<br>\begin{aligned}<br>uv_{\perp} &amp;= [0, \pmb{u}\times\pmb{v_{\perp}}]\<br>&amp;= \pmb{u}\times\pmb{v_{\perp}}<br>\end{aligned}<br>$$<br>将这个等式以及之前定义的纯四元数代入，而且四元数乘法遵守分配律，我们可以获得：<br>$$<br>\begin{aligned}<br>v_{\perp}’ &amp;= \cos(\theta)v_{\perp} + \sin(\theta)(uv_{\perp})\<br>&amp;= (\cos(\theta) + \sin(\theta)u)v_{\perp}<br>\end{aligned}<br>$$</p><p>可以注意到，如果我们将 $(\cos(\theta) + \sin(\theta)u)$ 看作是一个四元数，我们就能将旋转写成四元数的乘积了。到此为止，我们已经将旋转与四元数的积联系起来了。如果令 $q = \cos(\theta) + \sin(\theta)u$，我们能得到<br>$$<br>v_{\perp}’ = qv_{\perp}<br>$$</p><p>我们可以对 $q$ 继续进行变形：<br>$$<br>\begin{aligned}<br>q &amp;= \cos(\theta) + \sin(\theta)u\<br>&amp;= [\cos(\theta), \pmb{0}] + [0, \sin(\theta)\pmb{u}]\<br>&amp;= [\cos(\theta), \sin(\theta)\pmb{u}]\<br>\end{aligned}<br>$$</p><p>也就是说，如果旋转轴 $\pmb{u}$ 的坐标为 $\begin{bmatrix}u_{x}\ u_{y}\ u_{z}\end{bmatrix}$，旋转角为 $\theta$，那么完成这一旋转所需的四元数 $q$ 可以构造为<br>$$<br>q = \cos(\theta) + \sin(\theta)u_{x}i + \sin(\theta)u_{y}j + \sin(\theta)u_{z}k<br>$$<br>这样我们就完成了对 $v_{\perp}$ 的旋转，我们可以得到下面这个定理：</p><div class="note note-primary">            <p><strong>Theorem 8：3D 旋转公式（四元数型，正交情况）</strong><br>当 $\pmb{v_{\perp}}$ 正交于旋转轴 $\pmb{u}$ 时，旋转 $\theta$ 角度之后的 $\pmb{v_{\perp}‘}$ 可以使用四元数乘法来获得，令 $v_{\perp} = [0, \pmb{v_{\perp}}]$，$q = [\cos(\theta), \sin(\theta)\pmb{u}]$，那么：<br>$$<br>v_{\perp}’ = qv_{\perp}<br>$$</p>          </div><p>这个四元数 $q$ 的模长为 1，它是一个单位四元数，它所代表的变换不会对原向量进行缩放，是一个纯旋转。<br>$$<br>\begin{aligned}<br>\lVert q \rVert &amp;= \sqrt{\cos^2(\theta) + (\sin(\theta)\pmb{u}\cdot\sin(\theta)\pmb{u})}\<br>&amp;= \sqrt{\cos^2(\theta) + \sin^2(\theta)(\pmb{u}\cdot\pmb{u})}\<br>&amp;= \sqrt{\cos^2(\theta) + \sin^2(\theta)(\lVert\pmb{u}\rVert^2)}\<br>&amp;= \sqrt{\cos^2(\theta) + \sin^2(\theta)}\<br>&amp;= 1<br>\end{aligned}<br>$$</p><h4 id="v-parallel-的旋转">$v_{\parallel}$ 的旋转</h4><p>接下来是平行于旋转轴的 $v_{\parallel}$，由于它平行于旋转轴，所以旋转不会对它作出任何的变换，也就是说：</p><div class="note note-primary">            <p><strong>Theorem 9：3D 旋转公式（四元数型，平行情况）</strong><br>当 $\pmb{v_{\parallel}}$ 平行于旋转轴 $\pmb{u}$ 时，旋转 $\theta$ 角度之后的 $\pmb{v_{\parallel}‘}$ 可以用四元数写为：<br>$$<br>v_{\parallel}’ = v_{\parallel}<br>$$</p>          </div><h4 id="v-的旋转">$v$ 的旋转</h4><p>$$<br>\begin{aligned}<br>v’ &amp;= v_{\parallel}’ + v_{\perp}'\<br>&amp;= v_{\parallel} + qv_{\perp} \qquad (其中 q = [\cos(\theta), \sin(\theta)\pmb{u}])<br>\end{aligned}<br>$$</p><p>在进一步化简前，我们需要证明几个引理：</p><div class="note note-secondary">            <p><strong>Lemma 1</strong><br>如果 $q = [\cos(\theta), \sin(\theta)\pmb{u}]$，而且 $\pmb{u}$ 为单位向量，那么 $q^2 = qq = [\cos(2\theta), \sin(2\theta)\pmb{u}]$</p>          </div><p>$Proof$.</p><p>$$<br>\begin{aligned}<br>q^2 &amp;= [\cos(\theta), \sin(\theta)\pmb{u}] \cdot [\cos(\theta), \sin(\theta)\pmb{u}]\<br>&amp;= [\cos^2(\theta) - (\sin(\theta)\pmb{u}\cdot\sin(\theta)\pmb{u}), (\cos(\theta)\sin(\theta) + \sin(\theta)\cos(\theta))\pmb{u} + (\sin(\theta)\pmb{u}\times\sin(\theta)\pmb{u})]\<br>&amp;= [\cos^2(\theta) - \sin^2(\theta)\lVert\pmb{u}\rVert^2, 2\sin(\theta)\cos(\theta)\pmb{u} + \pmb{0}]\<br>&amp;= [\cos^2(\theta) - \sin^2(\theta), 2\sin(\theta)\cos(\theta)\pmb{u}]\<br>&amp;= [\cos(2\theta), \sin(2\theta)\pmb{u}]<br>\end{aligned}<br>$$</p><p>这个引理的几何意义是，如果沿着同一个轴 $\pmb{u}$ 连续旋转 $\theta$ 度两次，那么所作出的变换等同于直接沿着 $\pmb{u}$ 旋转 $2\theta$ 度</p><p>那么，我们就能够对原本的旋转公式进行变形了</p><p>$$<br>\begin{aligned}<br>v’ &amp;= v_{\parallel} + qv_{\perp} \qquad\qquad (q = [\cos(\theta), \sin(\theta)\pmb{u}])\<br>&amp;= 1 \cdot v_{\parallel} + qv_{\perp}\<br>&amp;= pp^{-1}v_{\parallel} + ppv_{\perp} \quad (令 q = p^2，则 p = [\cos(\frac{1}{2}\theta), \sin(\frac{1}{2}\theta)\pmb{u}])<br>\end{aligned}<br>$$</p><p>在这里，我们引入了一个新的四元数 $p = [\cos(\frac{1}{2}\theta), \sin(\frac{1}{2}\theta)\pmb{u}]$。根据刚刚证明的引理，我们可以验证<br>$$<br>\begin{aligned}<br>pp &amp;= p^2\<br>&amp;= [\cos(2\cdot\frac{1}{2}\theta), \sin(2\cdot\frac{1}{2}\theta)\pmb{u}]\<br>&amp;= [\cos(\theta), \sin(\theta)\pmb{u}] = q<br>\end{aligned}<br>$$</p><p>和 $q$ 一样，$\lVert p \rVert = 1$，$p$ 也是一个单位四元数，也就是说<br>$$<br>p^{-1} = p^*<br>$$</p><p>将这个结果代入之前的等式中<br>$$<br>\begin{aligned}<br>v’ &amp;= pp^{-1}v_{\parallel} + ppv_{\perp}\<br>&amp;= pp^*v_{\parallel} + ppv_{\perp}<br>\end{aligned}<br>$$</p><p>我们还需再证明两个引理：</p><div class="note note-secondary">            <p><strong>Lemma 2</strong><br>假设 $v_{\parallel} = [0, \pmb{v_{\parallel}}]$ 是一个纯四元数，而 $q = [\alpha, \beta\pmb{u}]$，其中 $\pmb{u}$ 是一个单位向量，$\alpha，\beta \in \mathbb{R}$，在这种条件下，如果 $\pmb{v_{\parallel}}$ 平行于 $\pmb{u}$，那么 $qv_{\parallel} = v_{\parallel}q$</p>          </div><p>$Proof$.</p><p>$$<br>\begin{aligned}<br>LHS &amp;= qv_{\parallel}\<br>&amp;= [\alpha, \beta\pmb{u}]\cdot[0, \pmb{v_{\parallel}}]\<br>&amp;= [0 - \beta\pmb{u}\cdot\pmb{v_{\parallel}}, \alpha\pmb{v_{\parallel}} + \pmb{0} + \beta\pmb{u}\times\pmb{v_{\parallel}}]\<br>&amp;= [-\beta\pmb{u}\cdot\pmb{v_{\parallel}}, \alpha\pmb{v_{\parallel}}] \qquad (\pmb{v_{\parallel}} 平行于 \pmb{u}，所以 \beta\pmb{u}\times\pmb{v_{\parallel}} = \pmb{0})<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>RHS &amp;= v_{\parallel}q\<br>&amp;= [0, \pmb{v_{\parallel}}]\cdot[\alpha, \beta\pmb{u}]\<br>&amp;= [0 - \pmb{v_{\parallel}}\cdot\beta\pmb{u}, \pmb{0} + \alpha\pmb{v_{\parallel}} + \pmb{v_{\parallel}}\times\beta\pmb{u}]\<br>&amp;= [-\pmb{v_{\parallel}}\cdot\beta\pmb{u}, \alpha\pmb{v_{\parallel}}] \qquad ({v_{\parallel}} 平行于 \pmb{u}，所以 \pmb{v_{\parallel}}\times\beta\pmb{u} = \pmb{0})\<br>&amp;= [-\beta\pmb{u}\cdot\pmb{v_{\parallel}}, \alpha\pmb{v_{\parallel}}] = LHS \qquad (点乘遵守交换律)<br>\end{aligned}<br>$$</p><div class="note note-secondary">            <p><strong>Lemma 3</strong><br>假设 $v_{\perp} = [0, \pmb{v_{\perp}}]$ 是一个纯四元数，而 $q = [\alpha, \beta\pmb{u}]$，其中 $\pmb{u}$ 是一个单位向量，$\alpha，\beta \in \mathbb{R}$，在这种条件下，如果 $\pmb{v_{\perp}}$ 正交于 $\pmb{u}$，那么 $qv_{\perp} = v_{\perp}q^*$</p>          </div><p>$Proof$.</p><p>$$<br>\begin{aligned}<br>LHS &amp;= qv_{\perp}\<br>&amp;= [\alpha, \beta\pmb{u}]\cdot[0, \pmb{v_{\perp}}]\<br>&amp;= [0 - \beta\pmb{u}\cdot\pmb{v_{\perp}}, \alpha\pmb{v_{\perp}} + \pmb{0} + \beta\pmb{u}\times\pmb{v_{\perp}}]\<br>&amp;= [0, \alpha\pmb{v_{\perp}} + \beta\pmb{u}\times\pmb{v_{\perp}}] \qquad (\pmb{v_{\perp}} 正交于 \pmb{u}，所以 \beta\pmb{u}\cdot\pmb{v_{\perp}} = 0)<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>RHS &amp;= v_{\perp}q^*\<br>&amp;= [0, \pmb{v_{\perp}}]\cdot[\alpha, -\beta\pmb{u}]\<br>&amp;= [0 + \pmb{v_{\perp}}\cdot\beta\pmb{u}, \pmb{0} + \alpha\pmb{v_{\perp}} + \pmb{v_{\perp}}\times(-\beta\pmb{u})]\<br>&amp;= [0, \alpha\pmb{v_{\perp}} + \pmb{v_{\perp}}\times(-\beta\pmb{u})] \qquad ({v_{\perp}} 正交于 \pmb{u}，所以 \pmb{v_{\perp}}\cdot\beta\pmb{u} = 0)\<br>&amp;= [0, \alpha\pmb{v_{\perp}} - (-\beta\pmb{u})\times\pmb{v_{\perp}}] \qquad (\pmb{a}\times\pmb{b} = -\pmb{b}\times\pmb{a})\<br>&amp;= [0, \alpha\pmb{v_{\perp}} + \beta\pmb{u}\times\pmb{v_{\perp}}] = LHS<br>\end{aligned}<br>$$</p><p>现在，我们能对之前的公式做出最后的变形了：<br>$$<br>\begin{aligned}<br>v’ &amp;= pp^<em>v_{\parallel} + ppv_{\perp}\<br>&amp;= pv_{\parallel}p^</em> + pv_{\perp}p^<em>\<br>&amp;= p(v_{\parallel} + v_{\perp})p^</em>\<br>&amp;= pvp^*<br>\end{aligned}<br>$$</p><p>我们可以将上述推导总结为一个定理：</p><div class="note note-primary">            <p><strong>Theorem 10：3D 旋转公式（四元数型，一般情况）</strong><br>任意向量 $\pmb{v}$ 沿着以单位向量定义的旋转轴 $\pmb{u}$ 旋转 $\theta$ 度之后的 $\pmb{v’}$ 可以使用四元数乘法来获得。令 $v = [0, \pmb{v}]$，$q = [\cos(\frac{1}{2}\theta), \sin(\frac{1}{2}\theta)\pmb{u}]$，那么：<br>$$<br>v’ = qvq^* = qvq^{-1}<br>$$</p>          </div><p>如果我们有 $q = [\cos(\theta), \sin(\theta)\pmb{u}]$，那么 $v’ = qvq^*$ 可以将 $\pmb{v}$ 沿着 $\pmb{u}$ 旋转 $2\theta$ 度。</p><p>虽然这个公式非常简洁，但是不够直观，想了解它的真正含义的话，还需将它还原到变形之前的式子：<br>$$<br>v’ = qvq^* = qq^*v_{\parallel} + qqv_{\perp} = v_{\parallel} + q^2v_{\perp}<br>$$</p><p>也就是说，$qvq^<em>$ 这个变换，对 $v$ 平行于旋转轴的分量 $v_{\parallel}$ 实施的变换是 $qq^</em>$，这两个变换完全抵消了，也就是没有旋转，而对于正交于旋转轴的分量 $v_{\perp}$ 则实施的是两次变换 $q^2 = qq$，将它旋转 $\frac{\theta}{2} + \frac{\theta}{2} = \theta$ 度。</p><p>实际上，这个公式和上一篇推导的向量型旋转公式完全等价，证明可能会用到 $\pmb{a}\times(\pmb{b}\times\pmb{c}) = (\pmb{a}\cdot\pmb{c})\pmb{b} - (\pmb{a}\cdot\pmb{b})\pmb{c}$ 这个公式<br>$$<br>qvq^* = [0, \cos(\theta)\pmb{v} + (1 - \cos(\theta))(\pmb{u}\cdot\pmb{v})\pmb{u} + \sin(\theta)(\pmb{u}\times\pmb{v})]<br>$$</p><p>因为所有的旋转四元数的实部都只是一个角度的余弦值，假设有一个单位四元数 $q = [a, \pmb{b}]$，那么我们可以直接得到<br>$$<br>\frac{\theta}{2} = \arccos(a) \qquad \pmb{u} = \frac{\pmb{b}}{\sin(\arccos(a))}<br>$$</p><h3 id="3D旋转的矩阵形式">3D旋转的矩阵形式</h3><p>左乘一个四元数 $q = a + bi + cj + dk$ 等同于下面这个矩阵<br>$$<br>L(q) = \begin{bmatrix}<br>a&amp;-b&amp;-c&amp;-d\<br>b&amp;a&amp;-d&amp;c\<br>c&amp;d&amp;a&amp;-b\<br>d&amp;-c&amp;b&amp;a\<br>\end{bmatrix}<br>$$<br>而右乘 $q$ 等同于这个矩阵<br>$$<br>R(q) = \begin{bmatrix}<br>a&amp;-b&amp;-c&amp;-d\<br>b&amp;a&amp;d&amp;-c\<br>c&amp;-d&amp;a&amp;b\<br>d&amp;c&amp;-b&amp;a\<br>\end{bmatrix}<br>$$</p><p>所以，我们可以利用这两个公式将 $v’ = qvq^<em>$ 写成矩阵形式。假设 $a = \cos(\frac{\theta}{2})，b = \sin(\frac{\theta}{2})u_{x}，c = \sin(\frac{\theta}{2})u_{y}，d = \sin(\frac{\theta}{2})u_{z}，q = a + bi + cj + dk$，我们就能得到：<br>$$<br>\begin{aligned}<br>qvq^</em> &amp;= L(q)R(q^<em>)v \qquad (或者 R(q^</em>)L(q)v，它们是等价的)\<br>&amp;= \begin{bmatrix}<br>a&amp;-b&amp;-c&amp;-d\<br>b&amp;a&amp;-d&amp;c\<br>c&amp;d&amp;a&amp;-b\<br>d&amp;-c&amp;b&amp;a\<br>\end{bmatrix}<br>\begin{bmatrix}<br>a&amp;b&amp;c&amp;d\<br>-b&amp;a&amp;-d&amp;c\<br>-c&amp;d&amp;a&amp;-b\<br>-d&amp;-c&amp;b&amp;a\<br>\end{bmatrix}v \qquad (注意 R(q^<em>) = R(q)^T)\<br>&amp;= \begin{bmatrix}<br>a^2 + b^2 + c^2 + d^2&amp;ab - ab - cd + cd&amp;ac + bd - ac - bd&amp;ad - bc + bc - ad\<br>ab - ab + cd - cd&amp;b^2 + a^2 - d^2 - c^2&amp;bc - ad - ad + bc&amp;bd + ac + bd + ac\<br>ac - bd - ac + bd&amp;bc + ad + ad + bc&amp;c^2 - d^2 + a^2 - b^2&amp;cd + cd - ab - ab\<br>ad + bc - bc - ad&amp;bd - ac + bd - ac&amp;cd + cd + ab + ab&amp;d^2 - c^2 - b^2 + a^2\<br>\end{bmatrix}v<br>\end{aligned}<br>$$<br>因为 $a^2 + b^2 + c^2 + d^2 = 1$，这个式子能化简为<br>$$<br>qvq^</em> =<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;0\<br>0&amp;1 - 2c^2 - 2d^2&amp;2bc - 2ad&amp;2ac + 2bd\<br>0&amp;2bc + 2ad&amp;1 - 2b^2 - 2d^2&amp;2cd - 2ab\<br>0&amp;2bd - 2ac&amp;2ab + 2cd&amp;1 - 2b^2 - 2c^2\<br>\end{bmatrix}v<br>$$</p><p>这样我们就得到了 3D 旋转的矩阵形式。因为矩阵的第一行和第一列不会对 $v$ 进行任何变换，我们可以将它压缩成 3 $\times$ 3 矩阵（用作 3D 向量的变换）：</p><div class="note note-primary">            <p><strong>Theorem 11：3D 旋转公式（矩阵型）</strong><br>任意向量 $\pmb{v}$ 沿着以单位向量定义的旋转轴 $\pmb{u}$ 旋转 $\theta$ 度之后的 $\pmb{v’}$ 可以使用矩阵乘法来获得。令 $a = \cos(\frac{\theta}{2})，b = \sin(\frac{\theta}{2})u_{x}，c = \sin(\frac{\theta}{2})u_{y}，d = \sin(\frac{\theta}{2})u_{z}$，那么：<br>$$<br>v’ =<br>\begin{bmatrix}<br>1 - 2c^2 - 2d^2&amp;2bc - 2ad&amp;2ac + 2bd\<br>2bc + 2ad&amp;1 - 2b^2 - 2d^2&amp;2cd - 2ab\<br>2bd - 2ac&amp;2ab + 2cd&amp;1 - 2b^2 - 2c^2\<br>\end{bmatrix}v<br>$$</p>          </div><p>虽然 3D 旋转的矩阵形式可能不如四元数形式简单，而且占用更多的空间，但是对于大批量的变换，使用<strong>预计算</strong>好的矩阵是比四元数乘法更有效率的。</p><h3 id="旋转的复合">旋转的复合</h3><p>假设有两个表示沿着不同轴，不同角度旋转的四元数 $q_{1}$，$q_{2}$，我们先对 $v$ 进行 $q_{1}$ 的变换，再进行 $q_{2}$ 的变换。</p><p>首先，我们实施 $q_{1}$ 的变换，变换后的 $v’$ 为<br>$$<br>v’ = q_{1}vq_{1}^*<br>$$<br>接下来，对 $v’$ 进行 $q_{2}$ 的变换，得到 $v’‘$<br>$$<br>\begin{aligned}<br>v’’ &amp;= q_{2}v’q_{2}^<em>\<br>&amp;= q_{2}q_{1}vq_{1}^<em>q_{2}^</em><br>\end{aligned}<br>$$<br>我们需要对这两个变换进行复合，写为一个等价变换的形式：<br>$$<br>v’’ = q_{net}vq_{net}^</em><br>$$</p><p>为了写成上面这种形式，我们还需要一个引理：</p><div class="note note-secondary">            <p><strong>Lemma 4</strong><br>对任意四元数 $q_{1} = [s, \pmb{v}]、q_{2} = [t, \pmb{u}]$<br>$$<br>q_{1}^<em>q_{2}^</em> = (q_{2}q_{1})^*<br>$$</p>          </div><p>$Proof$.</p><p>$$<br>\begin{aligned}<br>LHS &amp;= q_{1}^<em>q_{2}^</em>\<br>&amp;= [s, -\pmb{v}]\cdot[t, -\pmb{u}]\<br>&amp;= [st - (-\pmb{v})\cdot(-\pmb{u}), s(-\pmb{u}) + t(-\pmb{v}) + (-\pmb{v})\times(-\pmb{u})]\<br>&amp;= [st - \pmb{v}\cdot\pmb{u}, -s\pmb{u} - t\pmb{v} + \pmb{v}\times\pmb{u}]<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>RHS &amp;= (q_{2}q_{1})^<em>\<br>&amp;= ([t, \pmb{u}]\cdot[s, \pmb{v}])^</em>\<br>&amp;= [ts - \pmb{u}\cdot\pmb{v}, t\pmb{v} + s\pmb{u} + \pmb{u}\times\pmb{v}]\<br>&amp;= [st - \pmb{v}\cdot\pmb{u}, -s\pmb{u} - t\pmb{v} + \pmb{v}\times\pmb{u}] = LHS<br>\end{aligned}<br>$$</p><p>所以我们能得到<br>$$<br>\begin{aligned}<br>v’’ &amp;= q_{2}q_{1}vq_{1}^<em>q_{2}^</em>\<br>&amp;= (q_{2}q_{1})v(q_{2}q_{1})^*\<br>\end{aligned}<br>$$</p><p>这也就是说，$q_{net} = q_{2}q_{1}$。注意四元数乘法的顺序，我们先进行的是 $q_{1}$ 的变换，再进行 $q_{2}$ 的变换。这和矩阵与函数的复合非常相似，都是从右往左叠加。</p><p>要注意的是，$q_{1}$ 与 $q_{2}$ 的等价旋转 $q_{net}$ 并不是分别沿着 $q_{1}$ 和 $q_{2}$ 的两个旋转轴进行的两次旋转。它是沿着一个全新的旋转轴进行的一次等价旋转，仅仅只有旋转的结果相同。</p><p>虽然我们讨论的是两个旋转的复合，但是它可以很容易地推广到多个旋转的复合。比如说我们还需要进行第三个旋转 $q_{3}$，那么<br>$$<br>\begin{aligned}<br>v’‘’ &amp;= q_{3}(q_{2}q_{1})v(q_{2}q_{1})^<em>q_{3}^</em>\<br>&amp;= (q_{3}q_{2}q_{1})v(q_{3}q_{2}q_{1})^*<br>\end{aligned}<br>$$<br>它的等价旋转就是 $q_{net} = q_{3}q_{2}q_{1}$</p><h3 id="双倍覆盖">双倍覆盖</h3><p>四元数与 3D 旋转的关系并不是一对一的，同一个 3D 旋转可以使用两个不同的四元数来表示。对任意的四元数 $q = [\cos(\frac{\theta}{2}), \sin(\frac{\theta}{2})\pmb{u}]$，$q$ 与 $-q$ 代表的是同一个旋转。如果 $q$ 表示的是沿着旋转轴 $\pmb{u}$ 旋转 $\theta$ 度，那么 $-q$ 代表的是沿着相反的旋转轴 $-\pmb{u}$ 旋转 $(2\pi - \theta)$ 度：<br>$$<br>\begin{aligned}<br>-q &amp;= [-\cos(\frac{\theta}{2}), -\sin(\frac{\theta}{2})\pmb{u}]\<br>&amp;= [\cos(\pi - \frac{\theta}{2}), \sin(\pi - \frac{\theta}{2})(-\pmb{u})]\qquad (\cos(\pi - \theta) = -\cos(\theta), \sin(\pi - \theta) = \sin(\theta))<br>\end{aligned}<br>$$<br>所以，这个四元数旋转的角度为 $2(\pi - \frac{\theta}{2}) = 2\pi - \theta$。从下面的图中我们可以看到，这两个旋转是完全等价的：</p><p><img src="/posts_image/Quaternion/Quaternion_8.png" alt=""></p><p>其实从四元数的旋转公式中也能推导出相同的结果<br>$$<br>(-q)v(-q)^* = (-1)^2qvq^* = qvq^*<br>$$</p><p>所以，我们经常说单位四元数与 3D 旋转有一个“<strong>2对1满射同态</strong>”关系，或者说单位四元数“<strong>双倍覆盖</strong>”了 3D 旋转。</p><p>因为这个映射是满射，我们可以说所有的单位四元数都对应着一个 3D 旋转。或者说，一个四维单位超球面（也叫做 $\mathbb{S}^3$）上任意一点所对应的四元数（$\lVert q \rVert = 1$）都对应着一个 3D 旋转。</p><p>有一点需要注意的是，虽然 $q$ 与 $-q$ 是两个不同的四元数，但是由于旋转矩阵中的每一项都包含了四元数两个分量的乘积，它们的旋转矩阵是完全相同的。旋转矩阵并不会出现双倍覆盖的问题。</p><h3 id="指数形式">指数形式</h3><p>在讨论复数的时候，我们利用欧拉公式将 2D 的旋转写成了 $v’ = e^{i\theta}v$ 这样的指数形式。实际上，我们也可以利用四元数将 3D 旋转写成类似的形式。</p><p>类似于复数的欧拉公式，四元数也有一个类似的公式，如果 $\pmb{u}$ 是一个单位向量，那么对于单位四元数 $u = [0, \pmb{u}]$，有<br>$$<br>e^{u\theta} = \cos(\theta) + u\sin(\theta) = \cos(\theta) + \pmb{u}\sin(\theta)<br>$$<br>也就是说，$q = [\cos(\theta), \sin(\theta)\pmb{u}]$ 可以使用指数表示为 $e^{u\theta}$。这个公式的证明与欧拉公式的证明非常类似，直接使用级数展开就可以了。</p><p>$Proof$.</p><p>我们知道，$e^{x}$，$\sin(x)$，$\cos(x)$ 分别能用泰勒级数展开为：</p><p>$$<br>\begin{aligned}<br>e^{x} &amp;= \sum_{n=0}^{\infty}{\frac{x^{n}}{n!}} = 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \frac{x^4}{4!} + \dots\<br>\sin(x) &amp;= \sum_{n=0}^{\infty}{\frac{(-1)^n}{(2n + 1)!}x^{2n + 1}} = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} + \dots\<br>\cos(x) &amp;= \sum_{n=0}^{\infty}{\frac{(-1)^n}{(2n)!}x^{2n}} = 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \frac{x^6}{6!} + \dots\<br>\end{aligned}<br>$$</p><p>我们可以将 $x = u\theta$ 代入 $e^x$，得到<br>$$<br>\begin{aligned}<br>LHS = e^{u\theta} &amp;= \sum_{n=0}^{\infty}{\frac{(u\theta)^n}{n!}}\<br>&amp;= 1 + u\theta + \frac{(u\theta)^2}{2!} + \frac{(u\theta)^3}{3!} + \frac{(u\theta)^4}{4!} + \frac{(u\theta)^5}{5!} + \dots\<br>&amp;= 1 + u\theta + \frac{u^2\theta^2}{2!} + \frac{u^3\theta^3}{3!} + \frac{u^4\theta^4}{4!} + \frac{u^5\theta^5}{5!} + \dots\<br>\end{aligned}<br>$$</p><p>因为 $u^2 = [-\pmb{u}\cdot\pmb{u}, \pmb{0}] = -\lVert u \rVert^2 = -1$，我们可以对 $e^{u\theta}$ 进一步化简<br>$$<br>\begin{aligned}<br>LHS &amp;= 1 + u\theta + \frac{u^2\theta^2}{2!} + \frac{uu^2\theta^3}{3!} + \frac{(u^2)^2\theta^4}{4!} + \frac{u(u^2)^2\theta^5}{5!} + \dots\<br>&amp;= 1 + u\theta - \frac{\theta^2}{2!} - \frac{u\theta^3}{3!} + \frac{\theta^4}{4!} + \frac{u\theta^5}{5!} - \dots\<br>\end{aligned}<br>$$</p><p>同理，将 $\theta$ 代入 $\cos(x)$ 和 $\sin(x)$，<br>$$<br>\begin{aligned}<br>\sin(\theta) &amp;= \sum_{n=0}^{\infty}{\frac{(-1)^n}{(2n + 1)!}\theta^{2n + 1}}\<br>&amp;= \theta - \frac{\theta^3}{3!} + \frac{\theta^5}{5!} - \frac{\theta^7}{7!} + \dots\<br>\<br>\cos(\theta) &amp;= \sum_{n=0}^{\infty}{\frac{(-1)^n}{(2n)!}\theta^{2n}}\<br>&amp;= 1 - \frac{\theta^2}{2!} + \frac{\theta^4}{4!} - \frac{\theta^6}{6!} + \dots\<br>\end{aligned}<br>$$</p><p>所以，<br>$$<br>\begin{aligned}<br>RHS &amp;= \cos(\theta) + u\sin(\theta)\<br>&amp;= \sum_{n=0}^{\infty}{\frac{(-1)^n}{(2n)!}\theta^{2n}} + u\sum_{n=0}^{\infty}{\frac{(-1)^n}{(2n + 1)!}\theta^{2n + 1}}\<br>&amp;= 1 + u\theta - \frac{\theta^2}{2!} - \frac{u\theta^3}{3!} + \frac{\theta^4}{4!} + \frac{u\theta^5}{5!} - \dots = LHS<br>\end{aligned}<br>$$</p><p>因为 $\pmb{u}$ 是一个单位向量，$u^2 = [-\pmb{u}\cdot\pmb{u}, \pmb{0}] = -\lVert u \rVert^2 = -1$，这与欧拉公式中的 $i$ 是非常类似的。</p><p>有了指数型的表示方式，我们就能够将之前四元数的旋转公式改写为指数形式了：</p><div class="note note-primary">            <p><strong>Theorem 12：3D 旋转公式（指数型）</strong><br>任意向量 $\pmb{v}$ 沿着以单位向量定义的旋转轴 $\pmb{u}$ 旋转 $\theta$ 度之后的 $\pmb{v’}$ 可以使用四元数的指数表示。令 $v = [0, \pmb{v}]，u = [0, \pmb{u}]$，那么：<br>$$<br>v’ = e^{u\frac{\theta}{2}}ve^{-u\frac{\theta}{2}}<br>$$</p>          </div><p>有了四元数的指数定义，我们就能够定义四元数的更多运算了，首先是自然对数 $\log$，对任意单位四元数 $q = [\cos(\theta), \sin(\theta)\pmb{u}]$，<br>$$<br>\log(q) = \log(e^{u\theta}) = [0, \pmb{u}\theta]<br>$$<br>接下来是四元数的幂运算<br>$$<br>q^t = (e^{u\theta})^t = e^{u(t\theta)} = [\cos(t\theta), \sin(t\theta)\pmb{u}]<br>$$<br>可以看到，一个单位四元数的 $t$ 次幂等同于将它的旋转角缩放至 $t$ 倍，并且不会改变它的旋转轴（$u$ 必须是单位向量，所以一般不能与 $t$ 结合）。这些运算会在之后讨论四元数插值时非常有用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;四元数&quot;&gt;四元数&lt;/h2&gt;
&lt;p&gt;所有的四元数 $q \in \mathbb{H}$ 都可以写成下面这种形式：&lt;br&gt;
$$&lt;br&gt;
q = a + bi + cj + dk,(a,b,c,d \in \mathbb{R})&lt;br&gt;
$$&lt;/p&gt;
&lt;p&gt;其中&lt;br</summary>
      
    
    
    
    <category term="Computer Graphics" scheme="http://example.com/categories/Computer-Graphics/"/>
    
    
    <category term="Math" scheme="http://example.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>四元数和三维旋转(一)</title>
    <link href="http://example.com/posts/%E5%9B%9B%E5%85%83%E6%95%B0%E5%92%8C%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC(%E4%B8%80)/"/>
    <id>http://example.com/posts/%E5%9B%9B%E5%85%83%E6%95%B0%E5%92%8C%E4%B8%89%E7%BB%B4%E6%97%8B%E8%BD%AC(%E4%B8%80)/</id>
    <published>2022-07-16T12:57:52.000Z</published>
    <updated>2025-04-17T12:55:15.932Z</updated>
    
    <content type="html"><![CDATA[<p>由于使用欧拉角进行旋转时会存在万向锁的问题，同时，用欧拉角进行插值也不尽方便，而基于四元数的旋转既解决了万向锁的问题，又能非常方便地进行插值。本文将对在学习过程中遇到的四元数的定义、推导、性质、插值等问题进行总结归纳。</p><h2 id="复数">复数</h2><p>我们先来简要讨论一下复数的一些性质以及它与 2D 旋转之间的关系，四元数的很多性质都与复数非常类似，所以理解复数的一些性质对理解四元数非常有帮助。</p><h3 id="定义">定义</h3><p>任意一个复数 $z \in \mathbb{C}$ 都可以表示为 $z = a + bi$ 的形式，其中 $a,b \in \mathbb{R}$ 而且 $i^2 = -1$。我们将 $a$ 称为复数 $z$ 的实部，表示为 $a = Re(z)$，$b$ 称为复数 $z$ 的虚部，表示为 $b = Im(z)$。</p><p>因为 $z = a + bi$ 其实就是对于 ${1, i}$ 这个<strong>基</strong>（Basis）的<strong>线性组合</strong>（Linear Combination），我们也可以用向量来表示一个复数：<br>$$<br>z = \begin{bmatrix}<br>a\<br>b\<br>\end{bmatrix}<br>$$</p><p>因为这个向量有两个元素，我们可以使用复平面上的一个点来表示一个复数。复平面的横坐标代表它的实部，纵坐标代表它的虚部：</p><p><img src="/posts_image/Quaternion/Quaternion_1.png" alt=""></p><h3 id="复数的加减法">复数的加减法</h3><p>如果我们有两个复数 $z_{1} = a + bi$，$z_{2} = c + di$，它们的和就是分量相加的结果：<br>$$<br>z_{1} + z_{2} = (a + c) + (b + d)i<br>$$<br>同理，如果要对它们相减，直接将分量相减就可以了。<br>$$<br>z_{1} - z_{2} = (a - c) + (b - d)i<br>$$</p><h3 id="复数的乘法">复数的乘法</h3><p>如果有两个复数 $z_{1} = a + bi$，$z_{2} = c + di$，我们可以使用分配律来计算它们的乘积<br>$$<br>\begin{aligned}<br>z_{1}z_{2} &amp;= (a + bi)(c + di)\<br>&amp;= ac + adi + bci + bdi^2\<br>&amp;= ac - bd + adi +bci\<br>&amp;= a\textcolor{red}{c} - b\textcolor{blue}{d} +\<br>&amp;\quad(b\textcolor{red}{c} + a\textcolor{blue}{d})i<br>\end{aligned}<br>$$<br>如果仔细观察可以发现，复数相乘的结果其实也是一个矩阵与向量相乘的结果，也就是说：<br>$$<br>\begin{aligned}<br>z_{1}z_{2} &amp;= a\textcolor{red}{c} - b\textcolor{blue}{d} +\<br>&amp;\quad(b\textcolor{red}{c} + a\textcolor{blue}{d})i\<br>&amp;=<br>\begin{bmatrix}<br>a&amp;-b\<br>b&amp;a\<br>\end{bmatrix}<br>\begin{bmatrix}<br>\textcolor{red}{c}\<br>\textcolor{blue}{d}\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><p>右侧的 $\begin{bmatrix}c\ d \end{bmatrix}$ 是用向量的形式来表示的 $z_{2}$，而左侧的 $\begin{bmatrix} a&amp;-b\ b&amp;a\ \end{bmatrix}$ 则是 $z_{1}$ 的矩阵形式。我们可以发现，复数相乘这个运算，其实是与 $\begin{bmatrix} a&amp;-b\ b&amp;a\ \end{bmatrix}$ 则是 $z_{1}$ 这个矩阵所代表的<strong>变换</strong>是等价的。</p><p>那么在矩阵形式下，复数与复数的相乘也可以表示为矩阵的相乘，如果我们有两个复数 $z_{1} = a + bi$，$z_{2} = c + di$，那么与 $z_{1}z_{2}$ 所代表的变换则可以表示为</p><p>$$<br>\begin{aligned}<br>z_{1}z_{2} &amp;=<br>\begin{bmatrix}<br>a&amp;-b\<br>b&amp;a\<br>\end{bmatrix}<br>\begin{bmatrix}<br>c&amp;-d\<br>d&amp;c\<br>\end{bmatrix}\<br>&amp;=<br>\begin{bmatrix}<br>ac - bd&amp;-(bc + ad)\<br>bc + ad&amp;ac - bd\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><p>复数的相乘满足交换律，即 $z_{1}z_{2}$ 与 $z_{2}z_{1}$ 是等价的</p><p>$$<br>\begin{aligned}<br>z_{2}z_{1} &amp;=<br>\begin{bmatrix}<br>c&amp;-d\<br>d&amp;c\<br>\end{bmatrix}<br>\begin{bmatrix}<br>a&amp;-b\<br>b&amp;a\<br>\end{bmatrix}\<br>&amp;=<br>\begin{bmatrix}<br>ac - bd&amp;-(bc + ad)\<br>bc + ad&amp;ac - bd\<br>\end{bmatrix} = z_{1}z_{2}<br>\end{aligned}<br>$$</p><p>除此之外，我们来看一下一些特殊的矩阵形式：<br>$$<br>1 = \begin{bmatrix}<br>1&amp;0\<br>0&amp;1\<br>\end{bmatrix}<br>= I<br>\quad(a = 1, b = 0)<br>$$<br>$$<br>i = \begin{bmatrix}<br>0&amp;-1\<br>1&amp;0\<br>\end{bmatrix}<br>\quad(a = 0, b = 1)<br>$$</p><p>实数单位 1 与矩阵单位矩阵是等价的，而虚数单位 $i$ 则等价于 $\begin{bmatrix} 0&amp;-1\ 1&amp;0\ \end{bmatrix}$，如果我们尝试对它进行平方，可以发现：</p><p>$$<br>i^2 = i \cdot i =<br>\begin{bmatrix}<br>0&amp;-1\<br>1&amp;0\<br>\end{bmatrix}<br>\begin{bmatrix}<br>0&amp;-1\<br>1&amp;0\<br>\end{bmatrix}<br>= \begin{bmatrix}<br>-1&amp;0\<br>0&amp;-1\<br>\end{bmatrix} = -I = -1<br>$$</p><p>即便实在矩阵形式下，$i^2$ 与 -1 其实也是等价的，这进一步展示了复数与这一矩阵形式的关联。</p><h3 id="复数的模长与共轭">复数的模长与共轭</h3><p>复数 $z = a + bi$ 的<strong>模长</strong>（Magnitude）定义为<br>$$<br>\lVert z \rVert = \sqrt{a^2 + b^2}<br>$$</p><p>复数 $z = a + bi$ 的<strong>共轭</strong>（Conjugate）定义为</p><p>$$<br>\bar{z} = a - bi<br>$$</p><p>如果尝试计算 $z\bar{z}$，我们就会发现</p><p>$$<br>\begin{aligned}<br>z\bar{z} &amp;= (a + bi)(a - bi)\<br>&amp;= a^2 - abi + abi + b^2\<br>&amp;= a^2 + b^2 = {\lVert z \rVert}^2<br>\end{aligned}<br>$$</p><p>所以，一个复数的模长又可以通过下面的方式计算</p><p>$$<br>\lVert z \rVert = \sqrt{z\bar{z}}<br>$$</p><h3 id="复数与二维旋转">复数与二维旋转</h3><p>注意观察复数 $z$ 的矩阵形式 $\begin{bmatrix} a&amp;-b\ b&amp;a\ \end{bmatrix}$，我们可以把它变换为下述形式：</p><p>$$<br>\begin{bmatrix} a&amp;-b\ b&amp;a\ \end{bmatrix} = \sqrt{a^2 + b^2}<br>\begin{bmatrix}<br>\frac{a}{\sqrt{a^2 + b^2}}&amp;\frac{-b}{\sqrt{a^2 + b^2}}\<br>\frac{b}{\sqrt{a^2 + b^2}}&amp;\frac{a}{\sqrt{a^2 + b^2}}\<br>\end{bmatrix}<br>$$</p><p><img src="/posts_image/Quaternion/Quaternion_2.png" alt=""></p><p>可以看到，$\lVert z \rVert$ 正是复数 $z$ 与坐标轴所形成的三角形的斜边长，而 $a$，$b$ 分别为三角形的两个直角边．如果将斜边与实数轴正方向的夹角记为 $\theta$ 的话，按照三角函数的定义可以得出 $\frac{a}{\sqrt{a^2 + b^2}} = \cos(\theta)$ 且 $\frac{b}{\sqrt{a^2 + b^2}} = \sin(\theta)$,这个角度 $\theta$ 其实就是 $atan2(b, a)$。知道了这些，原矩阵就可以变形为</p><p>$$<br>\begin{aligned}<br>\begin{bmatrix} a&amp;-b\ b&amp;a\ \end{bmatrix} &amp;= \sqrt{a^2 + b^2}<br>\begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}\<br>&amp;= \lVert z \rVert<br>\begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}\<br>&amp;= \lVert z \rVert \cdot I<br>\begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}\<br>&amp;= \begin{bmatrix}<br>\lVert z \rVert&amp;0\<br>0&amp;\lVert z \rVert\<br>\end{bmatrix}<br>\begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}\<br>\end{aligned}<br>$$</p><p>其中，左边的 $\begin{bmatrix}\lVert z \rVert&amp;0\ 0&amp;\lVert z \rVert\ \end{bmatrix}$ 是缩放矩阵，而右边的 $\begin{bmatrix}\cos(\theta)&amp;-\sin(\theta)\ \sin(\theta)&amp;\cos(\theta)\ \end{bmatrix}$ 是 2D 旋转矩阵。</p><p>让我们看看这个矩阵对两个基 $\begin{bmatrix}1\ 0 \end{bmatrix}$ 和 $\begin{bmatrix}0\ 1 \end{bmatrix}$ 的变换效果，首先是 $\begin{bmatrix}1\ 0 \end{bmatrix}$:</p><p>$$<br>\begin{aligned}<br>\begin{bmatrix}<br>a&amp;-b\<br>b&amp;a\<br>\end{bmatrix}<br>\begin{bmatrix}<br>1\<br>0\<br>\end{bmatrix}<br>&amp;= \begin{bmatrix}<br>\lVert z \rVert&amp;0\<br>0&amp;\lVert z \rVert\<br>\end{bmatrix}<br>\begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}<br>\begin{bmatrix}<br>1\<br>0\<br>\end{bmatrix}\<br>&amp;= \begin{bmatrix}<br>\lVert z \rVert&amp;0\<br>0&amp;\lVert z \rVert\<br>\end{bmatrix}<br>\begin{bmatrix}<br>\cos(\theta)\<br>\sin(\theta)\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><p>第一步首先将 $\begin{bmatrix}1\ 0 \end{bmatrix}$ 变换到了 $\begin{bmatrix}\cos(\theta)\ \sin(\theta) \end{bmatrix}$ 的位置，也就是逆时针旋转了 $\theta$ 度，接下来<br>$$<br>\begin{bmatrix}<br>\lVert z \rVert&amp;0\<br>0&amp;\lVert z \rVert\<br>\end{bmatrix}<br>\begin{bmatrix}<br>\cos(\theta)\<br>\sin(\theta)\<br>\end{bmatrix} =<br>\begin{bmatrix}<br>\lVert z \rVert\cos(\theta)\<br>\lVert z \rVert\sin(\theta)\<br>\end{bmatrix}<br>$$<br>缩放矩阵将 $\begin{bmatrix}\cos(\theta)\ \sin(\theta)\ \end{bmatrix}$ 缩放了 $\lVert z \rVert$ 倍，变为 $\begin{bmatrix}\lVert z \rVert\cos(\theta)\ \lVert z \rVert\sin(\theta)\ \end{bmatrix}$。总的来说，就是对 $\begin{bmatrix}1\ 0 \end{bmatrix}$ 旋转了 $\theta$ 度，并缩放了 $\lVert z \rVert$ 倍。</p><p>接下来是 $\begin{bmatrix}0\ 1 \end{bmatrix}$：</p><p>$$<br>\begin{aligned}<br>\begin{bmatrix}<br>a&amp;-b\<br>b&amp;a\<br>\end{bmatrix}<br>\begin{bmatrix}<br>0\<br>1\<br>\end{bmatrix}<br>&amp;= \begin{bmatrix}<br>\lVert z \rVert&amp;0\<br>0&amp;\lVert z \rVert\<br>\end{bmatrix}<br>\begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}<br>\begin{bmatrix}<br>0\<br>1\<br>\end{bmatrix}\<br>&amp;= \begin{bmatrix}<br>\lVert z \rVert&amp;0\<br>0&amp;\lVert z \rVert\<br>\end{bmatrix}<br>\begin{bmatrix}<br>-\sin(\theta)\<br>\cos(\theta)\<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><p>这里，第一步将 $\begin{bmatrix}0\ 1 \end{bmatrix}$ 变换到了 $\begin{bmatrix}-\sin(\theta)\ \cos(\theta) \end{bmatrix}$ 的位置，这同样是逆时针旋转了 $\theta$ 度，见下图：</p><p><img src="/posts_image/Quaternion/Quaternion_2.png" alt=""></p><p>第二步变换同样会将 $\begin{bmatrix}-\sin(\theta)\ \cos(\theta) \end{bmatrix}$ 缩放为 $\begin{bmatrix}-\lVert z \rVert\sin(\theta)\ \lVert z \rVert\cos(\theta) \end{bmatrix}$。这样等于是将整个坐标系逆时针旋转了 $\theta$ 度，并缩放了 $\lVert z \rVert$ 倍。</p><p>换句话说，复数相乘的几何意义就是<strong>旋转与缩放变换的复合</strong>。如果有一个复数 $z = a + bi$，那么 $z$ 与任意一个复数 $c$ 相乘都会将 $c$ 逆时针旋转 $\theta = atan2(b, a)$ 度，并将其缩放 $\lVert z \rVert = \sqrt{a^2 + b^2}$ 倍。</p><p>如果复数的模长为 1，那么它的几何意义就只有旋转。</p><p>$$<br>z = \begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}<br>$$</p><p>如果我们想让 2D 空间中任意一个向量 $\vec{v}$ 旋转 $\theta$ 度，那么我们就可以使用这个矩阵对 $\vec{v}$ 进行变换：</p><div class="note note-primary">            <p><strong>Theorem 1：2D 旋转公式（矩阵型）</strong><br>$$<br>\vec{v’} = \begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}<br>\vec{v}<br>$$</p>          </div><p>其实 $\begin{bmatrix}\cos(\theta)&amp;-\sin(\theta)\ \sin(\theta)&amp;\cos(\theta)\ \end{bmatrix}$ 这个旋转矩阵如果写成复数形式的话就是 $\cos(\theta) + i\sin(\theta)$</p><p>如果我们将向量 $\vec{v} = \begin{bmatrix} x\ y\ \end{bmatrix}$ 看作是一个复数 $v = x + yi$，其中实部为 $x$，虚部为 $y$。那么我们可以构造一个复数 $z = \cos(\theta) + i\sin(\theta)$，并将它与 $v$ 相乘来进行旋转，旋转 $\theta$ 度之后的向量 $v’$ 可以用等价的复数乘法来表示：</p><div class="note note-primary">            <p><strong>Theorem 2：2D 旋转公式（复数积型）</strong><br>$$<br>\begin{aligned}<br>v’ &amp;= zv\<br>&amp;= (\cos(\theta) + i\sin(\theta)) v<br>\end{aligned}<br>$$</p>          </div><h3 id="复数的极坐标型">复数的极坐标型</h3><p>$\cos(\theta) + i\sin(\theta)$ 还可以进行下一步的变形，根据欧拉公式（Euler’s Formula），<br>$$<br>\cos(\theta) + i\sin(\theta) = e^{i\theta}<br>$$</p><div class="note note-success">            <p><strong>欧拉公式的证明：</strong></p><p>令 $f(\theta) = \frac{\cos(\theta) + i\sin(\theta)}{e^{i\theta}} = e^{-i\theta}(\cos(\theta) + i\sin(\theta))$，对实数 $\theta$，对 $f(\theta)$ 求导，得到 $f’(\theta) = e^{-i\theta}(i\cos(\theta) - \sin(\theta)) - ie^{-i\theta}(\cos(\theta) + i\sin(\theta)) = 0$，因此 $f(\theta)$ 是常数。又因为 $f(0) = 1$，所以 $f(\theta) \equiv 1$。欧拉公式得证。</p>          </div><p>有了这个等式，我们就能将复数表示为<br>$$<br>\begin{aligned}<br>z &amp;= \lVert z \rVert<br>\begin{bmatrix}<br>\cos(\theta)&amp;-\sin(\theta)\<br>\sin(\theta)&amp;\cos(\theta)\<br>\end{bmatrix}<br>&amp;= \lVert z \rVert (\cos(\theta) + i\sin(\theta))<br>&amp;= \lVert z \rVert e^{i\theta}<br>\end{aligned}<br>$$</p><p>如果我们定义 $r = \lVert z \rVert$，我们就得到了复数的极坐标形式：<br>$$<br>z = re^{i\theta}<br>$$</p><p>现在复数的定义就与实部与虚部的两个分量 $a$，$b$ 无关了，我们可以使用一个缩放因子 $r$ 和旋转角度 $\theta$ 的形式来定义任意一个复数，而且它旋转与缩放的性质仍然存在。如果我们想对 2D 空间中的向量 $\vec{v} = \begin{bmatrix} x\ y\ \end{bmatrix}$ 进行旋转并缩放，我们可以类似地将这个向量看作是一个复数 $v = x + yi$，那么，经过旋转 $\theta$ 度，缩放 $r$ 倍之后的向量 $v’$ 就可以这样计算：<br>$$<br>v’ = re^{i\theta}v<br>$$<br>如果仅需要旋转 $\theta$ 度的话，可以令缩放因子 $r = 1$，那么变换后的结果就是</p><div class="note note-primary">            <p><strong>Theorem 3：2D 旋转公式（指数型）</strong><br>$$<br>v’ = e^{i\theta}v<br>$$</p>          </div><h3 id="复数的几种表示形式总结">复数的几种表示形式总结</h3><ul><li>代数形式一：$z = a + bi$</li><li>代数形式二：$z = r(\cos(\theta) + i\sin(\theta))$</li><li>向量形式：$z = \begin{bmatrix}a\ b\ \end{bmatrix}$</li><li>矩阵形式一：$\begin{bmatrix} a&amp;-b\ b&amp;a\ \end{bmatrix}$</li><li>矩阵形式二：$\begin{bmatrix}\lVert z \rVert&amp;0\ 0&amp;\lVert z \rVert\ \end{bmatrix} \begin{bmatrix}\cos(\theta)&amp;-\sin(\theta)\ \sin(\theta)&amp;\cos(\theta)\ \end{bmatrix}\$</li><li>极坐标形式：$z = re^{i\theta}$</li></ul><p>这几种形式完全等价</p><h3 id="旋转的复合">旋转的复合</h3><p>如果我们有两个代表 2D 旋转的单位复数 $z_{1} = \cos(\theta) + i\sin(\theta)$，$z_{2} = \cos(\phi) + i\sin(\phi)$ 以及一个向量 $v = x + yi$，我们可以先对 $v$ 进行 $z_{1}$ 的旋转<br>$$<br>v’ = z_{1}v<br>$$<br>在此基础上，我们对 $v’$ 进行 $z_{2}$ 的旋转<br>$$<br>\begin{aligned}<br>v’’ &amp;= z_{2}(z_{1}v)\<br>&amp;= (z_{2}z_{1})v<br>\end{aligned}<br>$$<br>如果我们将这两次旋转所作出的等效变换称为 $z_{net}$，那么<br>$$<br>\begin{aligned}<br>v’’ &amp;= (z_{2}z_{1})v = z_{net}v\<br>z_{net} &amp;= z_{2}z_{1}<br>\end{aligned}<br>$$</p><p>因为复数的相乘遵守交换律，所以<br>$$<br>z_{net} = z_{2}z_{1} = z_{1}z_{2}<br>$$<br>如果尝试计算一下 $z_{net}$，会发现<br>$$<br>\begin{aligned}<br>z_{net} &amp;= (\cos(\theta) + i\sin(\theta))(\cos(\phi) + i\sin(\phi))\<br>&amp;= \cos(\theta)\cos(\phi) + i(\cos(\theta)\sin(\phi)) + i(\sin(\theta)\cos(\phi)) - \sin(\theta)\sin(\phi)\<br>&amp;= (\cos(\theta)\cos(\phi) - \sin(\theta)\sin(\phi)) + (\cos(\theta)\sin(\phi) + \sin(\theta)\cos(\phi))i<br>\end{aligned}<br>$$</p><p>这个式子可以利用三角恒等式化简为：<br>$$<br>\begin{aligned}<br>z_{net} &amp;= (\cos(\theta) + i\sin(\theta))(\cos(\phi) + i\sin(\phi))\<br>&amp;= \cos(\theta + \phi) + i\sin(\theta + \phi)<br>\end{aligned}<br>$$</p><p>所以，当我们对两个 2D 旋转进行复合时，所得到的变换 $z_{net}$ 仍是一个旋转，而且与施加的次序无关。这个等效变换的旋转角是 $z_{1} 与 $z_{2} 旋转角之和。</p><h2 id="轴角式旋转">轴角式旋转</h2><p>假设我们有一个经过原点的（如果旋转轴不经过原点我们可以先将旋转轴平移到原点，进行旋转，再平移回原处）旋转轴 $\vec{u} = (x,y,z)^T$，我们希望将一个向量 $\vec{v}$，沿着这个旋转轴旋转 $\theta$ 度，变换到 $\vec{v’}$</p><p><img src="/posts_image/Quaternion/Quaternion_4.png" alt=""></p><p>我们使用右手坐标系统，并且将使用右手定则来定义旋转的正方向。你可以将右手拇指指向旋转轴 $\vec{u}$ 的正方向，这时其他四个手指弯曲的方向即为旋转的正方向。在上图中即为逆时针方向。</p><p>为了消除旋转轴 $\vec{u}$ 模长这个多余的自由度，我们可以规定 $\vec{u}$ 的模长为 1，即 $\vec{u}$ 是一个单位向量。规定 $\vec{u}$ 为单位向量后能为我们带来很多便利，这也是数学和物理中对方向定义的惯例。如果 $\vec{u}$ 不是一个单位向量，我们可以通过下面的公式将它转化为一个单位向量<br>$$<br>\hat{u} = \frac{\vec{u}}{\lVert \vec{u} \rVert}<br>$$</p><h3 id="旋转的分解">旋转的分解</h3><p>我们可以将 $\vec{v}$ 分解为<strong>平行</strong>于旋转轴 $\vec{u}$ 以及<strong>正交</strong>于 $\vec{u}$ 的两个分量，$\vec{v_{\parallel}}$ 和 $\vec{v_{\perp}}$，即<br>$$<br>\vec{v} = \vec{v_{\parallel}} + \vec{v_{\perp}}<br>$$<br>我们可以分别旋转这两个分量，再将它们旋转的结果相加获得旋转后的向量<br>$$<br>\vec{v’} = \vec{v_{\parallel}‘} + \vec{v_{\perp}’}<br>$$<br>下面是分解的示意图：</p><p><img src="/posts_image/Quaternion/Quaternion_5.png" alt=""></p><p>可以看到，$\vec{v_{\parallel}}$ 其实就是 $\vec{v}$ 在 $\vec{u}$ 上的正交投影，根据正交投影公式，我们可以得出：</p><p>$$<br>\begin{aligned}<br>\vec{v_{\parallel}} &amp;= proj_{u}(\vec{v})\<br>&amp;= \frac{\vec{u}\cdot\vec{v}}{\vec{u}\cdot\vec{u}}\vec{u}\<br>&amp;= \frac{\vec{u}\cdot\vec{v}}{\lVert \vec{u} \rVert ^2}\vec{u}\<br>&amp;= (\vec{u}\cdot\vec{v})\vec{u}<br>\end{aligned}<br>$$</p><p>因为 $\vec{v} = \vec{v_{\parallel}} + \vec{v_{\perp}}$，我们可以得到<br>$$<br>\begin{aligned}<br>\vec{v_{\perp}} &amp;= \vec{v} - \vec{v_{\parallel}}\<br>&amp;= \vec{v} - (\vec{u}\cdot\vec{v})\vec{u}<br>\end{aligned}<br>$$</p><h3 id="vec-v-parallel-的旋转">$\vec{v_{\parallel}}$ 的旋转</h3><p>从之前的图示中可以看到，$\vec{v_{\parallel}}$ 其实没有被旋转，仍然与旋转轴 $\vec{u}$ 重合，所以</p><div class="note note-primary">            <p><strong>Theorem 4：3D 旋转公式（向量型，平行情况）</strong><br>当 $\vec{v_{\parallel}}$ 平行于旋转轴 $\vec{u}$ 时，旋转 $\theta$ 角度之后的 $\vec{v_{\parallel}‘}$ 为：<br>$$<br>\vec{v_{\parallel}’} = \vec{v_{\parallel}}<br>$$</p>          </div><h3 id="vec-v-perp-的旋转">$\vec{v_{\perp}}$ 的旋转</h3><p>接下来，我们需要处理正交于 $\vec{u}$ 的 $\vec{v_{\perp}}$。因为这两个向量是正交的，这个旋转可以看作是平面内的一个旋转。因为旋转不改变 $\vec{v_{\perp}}$ 的长度，所以路径是一个园。下面是这个旋转的示意图，右侧的为俯视图：</p><p><img src="/posts_image/Quaternion/Quaternion_6.png" alt=""></p><p>现在，3D 的旋转就被我们转化为了 2D 平面上的旋转，由于在这个平面上我们只有一个向量 $\vec{v_{\perp}}$，用它来表示一个旋转是不够的，我们还需构造一个同时正交于 $\vec{u}$ 和 $\vec{v_{\perp}}$ 的向量 $\vec{w}$，这个可以通过叉乘来获得<br>$$<br>\vec{w} = \vec{u}\times\vec{v_{\perp}}<br>$$</p><p>注意叉乘的顺序，因为我们使用的是右手坐标系统，按右手定则这个新的向量 $\vec{w}$ 指向 $\vec{v_{\perp}}$ 逆时针旋转 $\pi / 2$ 后的方向，并且和 $\vec{v_{\perp}}$ 一样也处于正交于 $\vec{u}$ 的平面内，因为 $\lVert\vec{u}\rVert = 1$，我们可以发现：<br>$$<br>\begin{aligned}<br>\lVert\vec{w}\rVert &amp;= \lVert\vec{u}\times\vec{v_{\perp}}\rVert\<br>&amp;= \lVert\vec{u}\rVert\cdot\lVert\vec{v_{\perp}}\rVert\cdot\sin(\pi/2)\<br>&amp;= \lVert\vec{v_{\perp}}\rVert<br>\end{aligned}<br>$$<br>$\vec{w}$ 和 $\vec{v_{\perp}}$ 的模长相同，且 $\vec{w}$ 也位于圆上，我们可以将 $\vec{w}$ 和 $\vec{v_{\perp}}$ 作为平面内的两个坐标轴，我们现在可以把 $\vec{v_{\perp}‘}$ 投影到 $\vec{w}$ 和 $\vec{v_{\perp}}$ 上，将其分解为 $\vec{v_{v}’}$ 和 $\vec{v_{w}'}$，利用三角形的知识我们可以得到：</p><p>$$<br>\begin{aligned}<br>\vec{v_{\perp}‘} &amp;= \vec{v_{v}’} + \vec{v_{w}'}\<br>&amp;= \cos(\theta)\vec{v_{\perp}} + \sin(\theta)\vec{w}\<br>&amp;= \cos(\theta)\vec{v_{\perp}} + \sin(\theta)(\vec{u}\times\vec{v_{\perp}})<br>\end{aligned}<br>$$</p><div class="note note-primary">            <p><strong>Theorem 5：3D 旋转公式（向量型，正交情况）</strong><br>当 $\vec{v_{\perp}}$ 正交于旋转轴 $\vec{u}$ 时，旋转 $\theta$ 角度之后的 $\vec{v_{\perp}‘}$ 为：<br>$$<br>\vec{v_{\perp}’} = \cos(\theta)\vec{v_{\perp}} + \sin(\theta)(\vec{u}\times\vec{v_{\perp}})<br>$$</p>          </div><h3 id="vec-v-的旋转">$\vec{v}$ 的旋转</h3><p>将上面两个结果组合可以获得：<br>$$<br>\begin{aligned}<br>\vec{v’} &amp;= \vec{v_{\parallel}‘} + \vec{v_{\perp}’}\<br>&amp;= \vec{v_{\parallel}} + \cos(\theta)\vec{v_{\perp}} + \sin(\theta)(\vec{u}\times\vec{v_{\perp}})<br>\end{aligned}<br>$$</p><p>因为叉乘遵守分配律，<br>$$<br>\begin{aligned}<br>\vec{u}\times\vec{v_{\perp}} &amp;= \vec{u}\times(\vec{v} - \vec{v_{\parallel}})\<br>&amp;= \vec{u}\times\vec{v} - \vec{u}\times\vec{v_{\parallel}}\<br>&amp;= \vec{u}\times\vec{v}\quad (\vec{u} 平行于 \vec{v_{\parallel}}，所以 \vec{u}\times\vec{v_{\parallel}} = \vec{0})<br>\end{aligned}<br>$$</p><p>最后，将 $\vec{v_{\parallel}} = (\vec{u}\cdot\vec{v})\vec{u}$ 和 $\vec{v_{\perp}} = \vec{v} - (\vec{u}\cdot\vec{v})\vec{u}$ 代入<br>$$<br>\begin{aligned}<br>\vec{v’} &amp;= (\vec{u}\cdot\vec{v})\vec{u} + \cos(\theta)(\vec{v} - (\vec{u}\cdot\vec{v})\vec{u}) + \sin(\theta)(\vec{u}\times\vec{v})\<br>&amp;= \cos(\theta)\vec{v} + (1 - \cos(\theta))(\vec{u}\cdot\vec{v})\vec{u} + \sin(\theta)(\vec{u}\times\vec{v})<br>\end{aligned}<br>$$<br>这样我们就得到了一般形式的旋转公式：</p><div class="note note-primary">            <p><strong>Theorem 6：3D 旋转公式（向量型，一般情况）</strong><br>3D 空间中任意一个 $\vec{v}$ 沿着单位向量 $\vec{u}$ 旋转 $\theta$ 角度之后的 $\vec{v_{\perp}‘}$ 为：<br>$$<br>\vec{v’} = \cos(\theta)\vec{v} + (1 - \cos(\theta))(\vec{u}\cdot\vec{v})\vec{u} + \sin(\theta)(\vec{u}\times\vec{v})<br>$$</p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于使用欧拉角进行旋转时会存在万向锁的问题，同时，用欧拉角进行插值也不尽方便，而基于四元数的旋转既解决了万向锁的问题，又能非常方便地进行插值。本文将对在学习过程中遇到的四元数的定义、推导、性质、插值等问题进行总结归纳。&lt;/p&gt;
&lt;h2 id=&quot;复数&quot;&gt;复数&lt;/h2&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Computer Graphics" scheme="http://example.com/categories/Computer-Graphics/"/>
    
    
    <category term="Math" scheme="http://example.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学基础-介绍</title>
    <link href="http://example.com/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80-%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-07-05T13:06:23.000Z</published>
    <updated>2025-04-17T12:55:15.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图形领域（Graphics-Areas）">图形领域（Graphics Areas）</h2><ul><li>建模（Modeling）</li><li>渲染（Rendering）</li><li>动画（Animation）</li><li>用户交互（User interaction）</li><li>虚拟现实（Virtual reality）</li><li>可视化（Visualization）</li><li>图像处理（Image processing）</li><li>三维扫描（Three-dimensional scanning）</li><li>计算摄影（Computational photography）</li></ul><h2 id="主要应用（Major-Applications）">主要应用（Major Applications）</h2><ul><li>电子游戏（Video games）</li><li>动画（Cartoons）</li><li>视觉效果（Visual effects）</li><li>动画电影（Animated films）</li><li>CAD/CAM（Computer-aided design/Computer-aided manufacturing）</li><li>仿真（Simulation）</li><li>医学成像（Medical imaging）</li><li>信息可视化（Information visualization）</li></ul><h2 id="图形API（Graphics-APIs）">图形API（Graphics APIs）</h2><p>每个图形程序都需要能够使用两个相关的API：一个用于视觉输出的图形API和一个用于从用户那里获得输入的用户界面API</p><ol><li>第一种是集成的方法，以Java为例，其中图形和用户界面工具箱时集成的、可移植的软件包，是完全标准化的并作为语言的一部分得到支持。</li><li>第二种是以Direct3D和OpenGL为代表的，其中的绘图命令是与语言相联系的软件库的一部分，而用户界面软件则是一个独立的实体。</li></ol><h2 id="图形管线（Graphics-Pipeline）">图形管线（Graphics Pipeline）</h2><p>将三维顶点位置映射到二维屏幕位置，并对三角形着色，使它们看起来很真实，并以适当的前后顺序出现。现在几乎都是用 Z-buffer 来解决绘制三角形的前后顺序问题。几何操作几乎完全在4D的齐次坐标空间中完成。</p><h2 id="数值问题（Numerical-Issues）">数值问题（Numerical Issues）</h2><p>实数有三个特殊值</p><ul><li><strong>无限大（$\infty$）</strong> 有效数字，比其他所有有效数字都大</li><li><strong>负无穷大（$-\infty$）</strong> 有效数字，比其他所有有效数字都小</li><li><strong>不是一个数字（$NaN$）</strong> 无效的数字，是由具有未定义结果的操作引起的，如零除以零。</li></ul><p>对于任何正实数 a：</p><p>$+a/(+\infty) = +0$<br>$-a/(+\infty ) = -0$<br>$+a/(-\infty ) = -0$<br>$-a/(-\infty ) = +0$<br>$\infty+\infty = +\infty$<br>$\infty-\infty = NaN$<br>$\infty\times\infty = \infty$<br>$\infty/\infty = NaN$<br>$\infty/a = \infty$<br>$\infty/0 = \infty$<br>$0/0 = NaN$</p><p>涉及无限值的布尔表达式规则如下：</p><ol><li>所有有限的有效数字都小于 $\infty$</li><li>所有有限的有效数字都大于 $-\infty$</li><li>$-\infty$ 小于 $\infty$</li></ol><p>涉及有 $NaN$ 值的表达式的规则很简单：</p><ol><li>任何包括 $NaN$ 的算术表达式的结果都是 $NaN$</li><li>任何涉及 $NaN$ 的布尔表达式都是假的</li></ol><p>对于任何正实数 a，以下涉及除以零值的规则都成立：</p><p>$+a/+0 = +\infty$<br>$-a/+0 = -\infty$</p><h2 id="效率（Efficiency）">效率（Efficiency）</h2><ol><li>尽可能以最直接的方式编写代码。根据需要即时计算中间结果，而不是存储它们。</li><li>在优化模式下进行编译</li><li>使用现有的任何分析工具寻找关键的效率瓶颈问题</li><li>检查数据结构，寻找提高定位数据的方法。尽量使数据单元大小和目标架构上的缓存/页面大小相匹配。</li><li>如果分析发现了数字计算的瓶颈，检查编译器生成的汇编代码是否有遗漏的效率问题。重写源代码来解决发现的任何问题。</li></ol><h2 id="设计和编码图形程序（Designing-and-Coding-Graphics-Programs）">设计和编码图形程序（Designing and Coding Graphics Programs）</h2><h3 id="类的设计">类的设计</h3><p>应该为几何实体（如向量和矩阵）以及图形实体（如RGB颜色和图像）编写尽可能干净又高效的类或程序。</p><ul><li><strong>vector2</strong> 一个存储 x 和 y 分量的二维向量类。应该将分量存储在一个二维数组中，这样就可以支持索引操作。还应编写向量加法、向量减法、点积、叉积、标量乘法和标量除法的操作程序。</li><li><strong>vector3</strong> 类似于 vector2 的三维向量类。</li><li><strong>hvector</strong> 具有四个分量的齐次向量。</li><li><strong>rgb</strong> 一个 RGB 颜色存储三个分量。还应编写 RGB 加法、RGB 减法、RGB 乘法，标量乘法和标量除法的操作程序。</li><li><strong>transform</strong> 一个用于变换的 4 $\times$ 4 矩阵。还应编写一个矩阵乘法和成员函数，以应用于位置、方向和表面法向量的变换。</li><li><strong>image</strong> 一个具有输出操作的 RGB 像素的二维阵列。</li></ul><h3 id="Float-VS-Double">Float VS Double</h3><p>现代架构表明，减少内存的使用和保持连贯的内存访问是效率的关键。所以建议使用单精度数据，然而，为了避免数字问题（Numerical Issues），建议使用双精度算术。这种权衡取决于程序，但在你的类中有一个默认的定义。</p><h3 id="调试图形程序">调试图形程序</h3><h4 id="科学方法">科学方法</h4><p>创建一个图像并观察它的问题所在。然后，我们对导致问题的原因提出一个假设，并对其进行测试。我们有时会觉得这种方法很好用，因为不需要发现一个错误的值或者真正确定概念性错误。我们只是通过实验轻松定位到问题的位置。</p><h4 id="将图像作为调试的输出">将图像作为调试的输出</h4><p>在许多情况下，从图形程序中获得调试信息的最简单渠道是输出图像本身。如果你想知道某个变量在每个像素上的部分计算值，你可以临时修改你的程序，把这个值直接复制到输出图像上，而跳过通常要进行的其他计算。例如，如果你怀疑某个特定的值有时超出了它的有效范围，让你的程序在发生这种情况的地方写上鲜红色的像素。其他常见的技巧包括用明显的颜色画出表面的背面（当它们不应该是可见的），用物体的ID号给图像着色，或者用像素的计算量来着色。</p><h4 id="使用调试器">使用调试器</h4><p>仍然有一些情况，特别是当科学方法似乎已经导致了矛盾的时候，这时没有什么可以替代观察到底发生了什么。麻烦的是，图形程序往往涉及同一代码的许多许多执行（例如，每个像素一次，或每个三角形一次），这使得从一开始就在调试器中步步深入完全不现实。而且最困难的错误通常只发生在复杂的输入上。</p><p>一个有用的方法是为这个错误 “设置一个陷阱（trap）”。首先，确保你的程序是确定性的–在一个单线程中运行，并确保所有的随机数都是由固定的种子计算出来的。然后，找出表现出错误的像素或三角形，并在你怀疑不正确的代码前添加一条语句，只对可疑情况执行。</p><p>如果你设置一个断点，你就可以在你感兴趣的像素被计算出来之前进入调试器。有些调试器有一个 “条件断点 “的功能，可以在不修改代码的情况下达到同样的效果。</p><p>在程序崩溃的情况下，传统的调试器对于确定崩溃的地方很有用。然后，你应该在程序中开始回溯，使用断言（asserts）和重新编译，以找到程序出错的地方。这些断言（asserts）应该留在程序中，以备将来可能添加的错误。这又意味着避免了传统的一步到位的过程，因为那不会在你的程序中加入有价值的断言（asserts）。</p><h4 id="为调试进行数据可视化">为调试进行数据可视化</h4><p>通常情况下，我们很难理解程序在做什么，因为它在最后出错之前计算了很多中间结果。这种情况类似于测量大量数据的科学实验，有一个解决办法是相同的：为自己制作好的图表和插图来理解数据的含义。例如，在光线追踪器中，你可能会写代码将光线树可视化，这样你就可以看到哪些路径对一个像素的贡献，或者在一个图像重采样程序中，你可能会做一些图来显示所有从输入中提取样本的点。花费时间编写代码来可视化你的程序的内部状态，在优化它的时候，也可以通过更好地理解它的行为来得到回报。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图形领域（Graphics-Areas）&quot;&gt;图形领域（Graphics Areas）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;建模（Modeling）&lt;/li&gt;
&lt;li&gt;渲染（Rendering）&lt;/li&gt;
&lt;li&gt;动画（Animation）&lt;/li&gt;
&lt;li&gt;用户交互（Us</summary>
      
    
    
    
    <category term="Computer Graphics" scheme="http://example.com/categories/Computer-Graphics/"/>
    
    
    <category term="Fundamental of Computer Graphics" scheme="http://example.com/tags/Fundamental-of-Computer-Graphics/"/>
    
  </entry>
  
  <entry>
    <title>使用噪声</title>
    <link href="http://example.com/posts/%E4%BD%BF%E7%94%A8%E5%99%AA%E5%A3%B0/"/>
    <id>http://example.com/posts/%E4%BD%BF%E7%94%A8%E5%99%AA%E5%A3%B0/</id>
    <published>2022-04-23T07:58:46.000Z</published>
    <updated>2025-04-17T12:55:15.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消融效果">消融效果</h2><p>**消融（dissolve）**效果常见于游戏中的角色死亡、地图烧毁等效果。在这些效果中，消融往往从不同的区域开始，并向看似随机的方向扩张，最后整个物体都将消失不见。我们将学习如何在 Unity 中实现这种效果，并得到类似下图中的效果。</p><p><img src="/posts_image/Use_Noise/Use_Noise_1.png" alt="箱子的消融效果" title="箱子的消融效果"></p><p>要实现上图中的效果，原理非常简单，概括来说就是噪声纹理+透明度测试。我们使用对噪声纹理采样的结果和某个控制消融程度的阈值比较，如果小于阈值，就使用 clip 函数把它对应的像素裁剪掉，这些部分就对应了图中被“烧毁”的区域。而镂空区域边缘的烧焦效果则是将两种颜色混合，再用 pow 函数处理后，与原纹理颜色混合后的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br>// Upgrade NOTE: replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;<br><br>Shader &quot;Custom/Chapter15/Chapter15-Dissolve&quot; &#123;<br><br>    Properties &#123;<br>        _BurnAmount (&quot;Burn Amount&quot;, Range(0.0, 1.0)) = 0.0<br>        _LineWidth (&quot;Burn Line Width&quot;, Range(0.0, 0.2)) = 0.1<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;<br>        _BurnFirstColor (&quot;Burn First Color&quot;, Color) = (1, 0, 0, 1)<br>        _BurnSecondColor (&quot;Burn Second Color&quot;, Color) = (1, 0, 0, 1)<br>        _BurnMap (&quot;Burn Map&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>    &#125;<br><br>    SubShader &#123;<br>        Pass &#123;<br>            Tags &#123;<br>                &quot;LightMode&quot; = &quot;ForwardBase&quot;<br>            &#125;<br><br>            Cull Off<br>            <br>            CGPROGRAM<br><br>            #include &quot;Lighting.cginc&quot;<br>            #include &quot;AutoLight.cginc&quot;<br><br>            #pragma multi_compile_fwdbase<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br>            <br>            fixed _BurnAmount;<br>            fixed _LineWidth;<br>            sampler2D _MainTex;<br>            sampler2D _BumpMap;<br>            fixed4 _BurnFirstColor;<br>            fixed4 _BurnSecondColor;<br>            sampler2D _BurnMap;<br>            <br>            float4 _MainTex_ST;<br>            float4 _BumpMap_ST;<br>            float4 _BurnMap_ST;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 tangent : TANGENT;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br>            <br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float2 uvMainTex : TEXCOORD0;<br>                float2 uvBumpMap : TEXCOORD1;<br>                float2 uvBurnMap : TEXCOORD2;<br>                float3 lightDir : TEXCOORD3;<br>                float3 worldPos : TEXCOORD4;<br>                SHADOW_COORDS(5)<br>            &#125;;<br><br>            v2f vert (a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br><br>                o.uvMainTex = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                o.uvBumpMap = TRANSFORM_TEX(v.texcoord, _BumpMap);<br>                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);<br><br>                TANGENT_SPACE_ROTATION;<br>                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;<br><br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br>                TRANSFER_SHADOW(o);<br>                return o;<br>            &#125;<br><br>            fixed4 frag (v2f i) : SV_TARGET &#123;<br>                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;<br>                clip(burn.r - _BurnAmount);<br>                float3 tangentLightDir = normalize(i.lightDir);<br>                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));<br><br>                fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br>                fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(tangentNormal, tangentLightDir));<br>                fixed t = 1 - smoothstep(0.0, _LineWidth, burn.r - _BurnAmount);<br>                fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);<br>                burnColor = pow(burnColor, 5);<br><br>                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br>                fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * step(0.0001, _BurnAmount));<br><br>                return fixed4(finalColor, 1);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br><br>        // Pass to render object as a shadow caster<br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;<br>            <br>            CGPROGRAM<br>            <br>            #pragma vertex vert<br>            #pragma fragment frag<br>            <br>            #pragma multi_compile_shadowcaster<br>            <br>            #include &quot;UnityCG.cginc&quot;<br>            <br>            fixed _BurnAmount;<br>            sampler2D _BurnMap;<br>            float4 _BurnMap_ST;<br>            <br>            struct v2f &#123;<br>                V2F_SHADOW_CASTER;<br>                float2 uvBurnMap : TEXCOORD1;<br>            &#125;;<br>            <br>            v2f vert(appdata_base v) &#123;<br>                v2f o;<br>                <br>                TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)<br>                <br>                o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);<br>                <br>                return o;<br>            &#125;<br>            <br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;<br>                <br>                clip(burn.r - _BurnAmount);<br>                <br>                SHADOW_CASTER_FRAGMENT(i)<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    FallBack &quot;Diffuse&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>_BurnAmount 属性用于控制消融程度，当值为 0 时，物体为正常效果，当值为 1 时，物体会完全消融。_LineWidth 属性用于控制模拟烧焦效果时的线宽，它的值越大，火焰边缘的蔓延范围越广。_MainTex 和 _BumpMap 分别对应了物体原本的漫反射纹理和法线纹理。_BurnFirstColor 和 _BurnSecondColor 对应了火焰边缘的两种颜色值。_BurnMap 则是关键的噪声纹理。</p><p>为了得到正确的光照，我们设置了 Pass 的 LightMode 和 multi_compile_fwdbase 的编译指令。值得注意的是，我们还使用 Cull 命令关闭了该 Shader 的面片剔除，也就是说，模型的正面和背面都会被渲染。这是因为，消融会导致裸露模型内部的构造，如果只渲染正面会出现错误的结果。</p><p>顶点着色器的代码很常规。我们使用宏 TRANSFORM_TEX 计算了三张纹理对应的纹理坐标，再把光源方向从模型空间变换到了切线空间。最后，为了得到阴影信息，计算了世界空间下的顶点位置和阴影纹理的采样坐标（使用了 TRANSFER_SHADOW 宏）。</p><p>在片元着色器中，我们首先对噪声纹理进行采样，并将采样结果和用于控制消融程度的属性 _BurnAmount 相减，传递给 clip 函数。当结果小于 0 时，该像素将会被剔除，从而不会显示到屏幕上。如果通过了测试，则进行正常的光照计算。我们首先根据漫反射纹理得到材质的反射率 albedo，并由此计算得到环境光照，进而得到漫反射光照。然后，我们计算了烧焦颜色 burnColor。我们想要在宽度为 _LineWidth 的范围内模拟一个烧焦的颜色变化，第一步就使用了 smoothstep 函数来计算混合系数 t。当 t 值为 1 时，表明该像素位于消融的边界处，当 t 值为 0 时，表明该像素为正常的模型颜色，而中间的插值则表示需要模拟一个烧焦效果。我们首先用 t 来混合两种火焰颜色 _BurnFirstColor 和 _BurnSecondColor，为了让效果更接近烧焦的痕迹，我们还使用 pow 函数对结果进行处理。然后，我们再次使用 t 来混合正常的光照颜色（环境光+漫反射）和烧焦颜色。我们这里又使用了 step 函数来保证当 _BurnAmount 为 0 时，不显示任何消融效果。最后，返回混合后的颜色值 finalColor。</p><p>使用透明度测试的物体的阴影需要特别处理，如果仍然使用普通的阴影 Pass，那么被剔除的区域仍然会向其他物体投射阴影，造成“穿帮”。为了让物体的阴影也能配合透明度测试产生正确的效果，我们自定义了一个投射阴影的 Pass。</p><p>在 Unity 中，用于投射阴影的 Pass 的 LightMode 需要被设置为 ShadowCaster，同时，还需要使用 #pragma multi_compile_shadowcaster 指明它需要的编译指令。</p><p>阴影投射的重点在于我们需要按正常 Pass 的处理来剔除片元或进行顶点动画，以便阴影可以和物体正常渲染的结果相匹配。在自定义的阴影投射的 Pass 中，我们通常会使用 Unity 提供的内置宏 V2F_SHADOW_CASTER、TRANSFER_SHADOW_CASTER_NORMALOFFSET（旧版本中会使用 TRANSFER_SHADOW_CASTER）和 SHADOW_CASTER_FRAGMENT 来帮助我们计算阴影投射时需要的各种变量，而我们可以只关注自定义计算的部分。在上面的代码中，我们首先在 v2f 结构体中利用 V2F_SHADOW_CASTER 来定义阴影投射需要定义的变量。随后，在顶点着色器中，我们使用 TRANSFER_SHADOW_CASTER_NORMALOFFSET 来填充 V2F_SHADOW_CASTER 在背后声明的一些变量，这是由 Unity 在背后为我们完成的。我们需要在顶点着色器中关注自定义的计算部分，这里指的就是我们需要计算噪声纹理的采样坐标 uvBurnMap。在片元着色器中，我们首先按之前的处理方法使用噪声纹理的采样结果来剔除片元，最后再利用 SHADOW_CASTER_FRAGMENT 来让 Unity 为我们完成阴影投射的部分，把结果输出到深度图和阴影映射纹理中。</p><p>通过 Unity 提供的这三个内置宏（在 UnityCG.cginc 文件中被定义），我们可以方便地自定义需要的阴影投射的 Pass，但由于这些宏需要使用一些特定的输入变量，因此我们需要保证为它们提供了这些变量。例如 TRANSFER_SHADOW_CASTER_NORMALOFFSET 会使用名称 v 作为输入结构体，v 中需要包含顶点位置 v.vertex 和顶点法线 v.normal 的信息，我们可以直接使用内置的 appdata_base 结构体，它包含了这些必须的顶点变量。如果我们需要进行顶点动画，可以在顶点着色器中直接修改 v.vertex，再传递给 TRANSFER_SHADOW_CASTER_NORMALOFFSET 即可。</p><h2 id="水波效果">水波效果</h2><p>在模拟实时水面的过程中，我们往往也会使用噪声纹理，此时，噪声纹理通常会用作一个高度图，以不断修改水面的法线方向。为了模拟水不断流动的效果，我们会使用和时间相关的变量来对噪声纹理进行采样，当得到法线信息后，再进行正常的反射+折射计算，得到最后的水面波动效果。</p><p>下面，我们将会使用一个由噪声纹理得到的法线贴图，实现一个包含菲涅耳反射的水面效果，如下图所示</p><p><img src="/posts_image/Use_Noise/Use_Noise_2.png" alt="包含菲涅耳反射的水面波动效果" title="包含菲涅耳反射的水面波动效果"></p><p>我们使用一张立方体纹理（Cubemap）作为环境纹理，模拟反射。为了模拟折射效果，我们使用 GrabPass 来获取当前屏幕的渲染纹理，并使用切线空间下的法线方向对像素的屏幕坐标进行偏移，再使用该坐标对渲染纹理进行屏幕采样，从而模拟近似的折射效果。水波的法线纹理由一张噪声纹理生成而得，而且会随着时间变化不断平移，模拟波光粼粼的效果。我们没有使用一个定值来混和反射和折射颜色，而是使用之前提到的菲涅耳系数来动态决定混合系数。我们使用如下公式来计算菲涅耳系数：<br>$$<br>fresnel = pow(1 - max(0, v \cdot n), 4)<br>$$<br>其中，$v$ 和 $n$ 分别对应了视角方向和法线方向。它们之间的夹角越小，$fresnel$ 值越小，反射越弱，折射越强。菲涅耳系数还经常会用于边缘光照的计算中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter15/Chapter15-WaterWave&quot; &#123;<br><br>    Properties &#123;<br>        _Color (&quot;Main Color&quot;, Color) = (0, 0.15, 0.115, 1)<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _WaveMap (&quot;Wave Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;<br>        _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<br>        _WaveXSpeed (&quot;Wave Horizontal Speed&quot;, Range(-0.1, 0.1)) = 0.01<br>        _WaveYSpeed (&quot;Wave Vertical Speed&quot;, Range(-0.1, 0.1)) = 0.01<br>    &#125;<br><br>    SubShader &#123;<br>        // We must be transparent, so other objects are drawn before this one.<br>        Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;<br>        <br>        // This pass grabs the screen behind the object into a texture.<br>        // We can access the result in the next pass as _RefractionTex<br>        GrabPass &#123; &quot;_RefractionTex&quot; &#125;<br><br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br>            <br>            CGPROGRAM<br>            <br>            #include &quot;UnityCG.cginc&quot;<br>            #include &quot;Lighting.cginc&quot;<br>            <br>            #pragma multi_compile_fwdbase<br>            <br>            #pragma vertex vert<br>            #pragma fragment frag<br>            <br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            sampler2D _WaveMap;<br>            float4 _WaveMap_ST;<br>            samplerCUBE _Cubemap;<br>            fixed _WaveXSpeed;<br>            fixed _WaveYSpeed;<br>            float _Distortion;<br>            sampler2D _RefractionTex;<br>            float4 _RefractionTex_TexelSize;<br>            <br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 tangent : TANGENT; <br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br>            <br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float4 scrPos : TEXCOORD0;<br>                float4 uv : TEXCOORD1;<br>                float4 TtoW0 : TEXCOORD2;  <br>                float4 TtoW1 : TEXCOORD3;  <br>                float4 TtoW2 : TEXCOORD4; <br>            &#125;;<br>            <br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                <br>                o.scrPos = ComputeGrabScreenPos(o.pos);<br>                <br>                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                o.uv.zw = TRANSFORM_TEX(v.texcoord, _WaveMap);<br>                <br>                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  <br>                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  <br>                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  <br>                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w; <br>                <br>                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  <br>                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  <br>                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  <br>                <br>                return o;<br>            &#125;<br>            <br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);<br>                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));<br>                float2 speed = _Time.y * float2(_WaveXSpeed, _WaveYSpeed);<br>                <br>                // Get the normal in tangent space<br>                fixed3 bump1 = UnpackNormal(tex2D(_WaveMap, i.uv.zw + speed)).rgb;<br>                fixed3 bump2 = UnpackNormal(tex2D(_WaveMap, i.uv.zw - speed)).rgb;<br>                fixed3 bump = normalize(bump1 + bump2);<br>                <br>                // Compute the offset in tangent space<br>                float2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;<br>                i.scrPos.xy = offset * i.scrPos.z + i.scrPos.xy;<br>                fixed3 refrCol = tex2D( _RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;<br>                <br>                // Convert the normal to world space<br>                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));<br>                fixed4 texColor = tex2D(_MainTex, i.uv.xy + speed);<br>                fixed3 reflDir = reflect(-viewDir, bump);<br>                fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb * _Color.rgb;<br>                <br>                fixed fresnel = pow(1 - saturate(dot(viewDir, bump)), 4);<br>                fixed3 finalColor = reflCol * fresnel + refrCol * (1 - fresnel);<br>                <br>                return fixed4(finalColor, 1);<br>            &#125;<br>            <br>            ENDCG<br>        &#125;<br>    &#125;<br><br><br>    FallBack &quot;Diffuse&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，_Color 用于控制水面颜色；_MainTex 是水面波纹材质纹理，默认为白色纹理；_WaveMap 是一个由噪声纹理生成的法线纹理；_Cubemap 是用于模拟反射的立方体纹理；_Distortion 则用于控制模拟折射时图像的扭曲程度；_WaveXSpeed 和 _WaveYSpeed 分别用于控制法线纹理在 X 和 Y 方向上的平移速度。</p><p>我们首先在 SubShader 的标签中将渲染队列设置成 Transparent，并把后面的 RenderType 设置为 Opaque。把 Queue 设置成 Transparent 可以确保该物体渲染时，其他所有不透明物体都已经被渲染到屏幕上了，否则就可能无法正确得到“透过水面看到的图像”。而设置 RenderType 则是为了在使用着色器替换（Shader Replacement）时，该物体可以在需要时被正确渲染。这通常发生在我们需要得到摄像机的深度和法线纹理时。随后，我们通过关键词 GrabPass 定义了一个抓取屏幕图像的 Pass。在这个 Pass 中我们定义了一个字符串，该字符串内部的名称决定了抓取得到的屏幕图像将会被存入哪个纹理中。</p><p>需要注意的是，我们还定义了 _RefractionTex 和 _RefractionTex_TexelSize 变量，这对应了在使用 GrabPass 时，指定的纹理名称。_RefractionTex_TexelSize 可以让我们得到该纹理的纹素大小，例如一个大小为 256 $\times$ 512 的纹理，它的纹素大小为(1/256, 1/512)。我们需要在对屏幕图像的采样坐标进行偏移时使用该变量。</p><p>在顶点着色器中，进行了必要的顶点坐标变换后，我们通过调用 ComputeGrabScreenPos 来得到对应被抓取屏幕图像的采样坐标。我们可以在 UnityCG.cginc 文件中找到它的声明，它的主要代码和 ComputeScreenPos 基本类似，最大的不同时针对平台差异造成的采样坐标问题进行了处理。接着，我们计算了 _MainTex 和 _BumpMap 的采样坐标，并把它们分别存储在一个 float4 类型变量的 xy 和 zw 分量中。由于我们需要在片元着色器中把法线方向从切线空间（由法线纹理采样得到）变换到世界空间下，以便对 Cubemap 进行采样，因此，我们需要在这里计算该顶点对应的从切线空间到世界空间的变换矩阵，并把该矩阵的每一行分别存储在 TtoW0、TtoW1 和 TtoW2 的 xyz 分量中。这里面使用的数学方法就是，得到切线空间下的 3 个坐标轴（x、y、z轴分别对应了切线、副切线和法线的方向）在世界空间下的表示，再把它们依次按列组成一个变换矩阵即可。TtoW0 等值的 w 分量同样被利用起来，用于存储世界空间下的顶点坐标。</p><p>在片元着色器中，我们首先通过 TtoW0 等变量的 w 分量得到世界坐标，并用该值得到该片元对应的视角方向。除此之外，我们还使用内置的 _Time.y 变量和 _WaveXSpeed、_WaveYSpeed 属性计算了法线纹理的当前偏移量，并利用该值对法线纹理进行两次采样（这是为了模拟两层交叉的水面波动的效果），对两次结果相加并归一化后得到切线空间下的法线方向。然后，我们使用该值和 _Distortion 属性以及 _RefractionTex_TexelSize 来对屏幕图像的采样坐标进行偏移，模拟折射效果。_Distortion 值越大，偏移量越大，水面背后的物体看起来变形程度越大。在这里，我们选择使用切线空间下的法线方向来进行偏移，是因为该空间下的法线可以反应顶点局部空间下的法线方向。需要注意的是，在计算偏移后的屏幕坐标时，我们把偏移量和屏幕坐标的 z 分量相乘，这是为了模拟深度越大、折射程度越大的效果。如果我们不希望产生这样的效果，可以直接把偏移值叠加到屏幕坐标上。随后，我们对 scrPos 进行了透视除法，再使用该坐标对抓取的屏幕图像 _RefractionTex 进行采样，得到模拟的折射颜色。</p><p>之后，我们把法线方向从切线空间变换到了世界空间下（使用变换矩阵的每一行，即 TtoW0、TtoW1 和 TtoW2，分别和法线方向点乘，构成新的法线方向），并据此得到视角方向相对于法线方向的反射方向。随后，使用反射方向对 Cubemap 进行采样，并把结果和主纹理颜色相乘后得到反射颜色。我们也对主文理进行了纹理动画，以模拟水波的效果。</p><p>为了混合折射和反射颜色，我们随后计算了菲涅耳系数。我们使用之前的公式来计算菲涅耳系数，并据此来混合折射和反射颜色，作为最终的输出颜色。</p><p>我们使用的噪声纹理如下图所示。我们需要的是一张法线纹理，因此我们可以从该噪声纹理的灰度值中生成需要的法线信息，这是通过在它的纹理面板中把纹理类型设置为 <strong>Normal map</strong>，并选中 <strong>Create from grayscale</strong> 来完成的。最后生成的法线纹理如下图的右图所示。</p><p><img src="/posts_image/Use_Noise/Use_Noise_3.png" alt="水波效果使用的噪声纹理" title="水波效果使用的噪声纹理"></p><h2 id="再谈全局雾效">再谈全局雾效</h2><p>我们在之前讲到了如何使用深度纹理来实现一种基于屏幕后处理的全局雾效。我们由深度纹理重建每个像素在世界空间下的位置，再使用一个基于高度的公式来计算雾效的混合系数，最后使用该系数来混合雾的颜色和原屏幕颜色。上次实现的效果是一个基于高度的均匀雾效，即在同一个高度上，雾的浓度是相同的，如下图的左图所示，然而，一些时候我们希望可以模拟一种不均匀的雾效，同时让雾不断飘动，使雾看起来更加飘渺，如下图的右图所示。而这就可以通过使用一张噪声纹理来实现。</p><p><img src="/posts_image/Use_Noise/Use_Noise_4.png" alt="雾效" title="雾效"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FogWithNoise</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader fogShader;<br><span class="hljs-keyword">private</span> Material fogMaterial = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);<br><span class="hljs-keyword">return</span> fogMaterial;<br>&#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> Camera myCamera;<br><span class="hljs-keyword">public</span> Camera camera &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">if</span> (myCamera == <span class="hljs-literal">null</span>) &#123;<br>myCamera = GetComponent&lt;Camera&gt;();<br>&#125;<br><span class="hljs-keyword">return</span> myCamera;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Transform myCameraTransform;<br><span class="hljs-keyword">public</span> Transform cameraTransform &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">if</span> (myCameraTransform == <span class="hljs-literal">null</span>) &#123;<br>myCameraTransform = camera.transform;<br>&#125;<br><br><span class="hljs-keyword">return</span> myCameraTransform;<br>&#125;<br>&#125;<br><br>[<span class="hljs-meta">Range(0.1f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fogDensity = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-keyword">public</span> Color fogColor = Color.white;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fogStart = <span class="hljs-number">0.0f</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fogEnd = <span class="hljs-number">2.0f</span>;<br><br><span class="hljs-keyword">public</span> Texture noiseTexture;<br><br>[<span class="hljs-meta">Range(-0.5f, 0.5f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fogXSpeed = <span class="hljs-number">0.1f</span>;<br><br>[<span class="hljs-meta">Range(-0.5f, 0.5f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fogYSpeed = <span class="hljs-number">0.1f</span>;<br><br>[<span class="hljs-meta">Range(0.0f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> noiseAmount = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span> &#123;<br>GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.Depth;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>Matrix4x4 frustumCorners = Matrix4x4.identity;<br><br><span class="hljs-built_in">float</span> fov = camera.fieldOfView;<br><span class="hljs-built_in">float</span> near = camera.nearClipPlane;<br><span class="hljs-built_in">float</span> aspect = camera.aspect;<br><br><span class="hljs-built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="hljs-number">0.5f</span> * Mathf.Deg2Rad);<br>Vector3 toRight = cameraTransform.right * halfHeight * aspect;<br>Vector3 toTop = cameraTransform.up * halfHeight;<br><br>Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;<br><span class="hljs-built_in">float</span> scale = topLeft.magnitude / near;<br><br>topLeft.Normalize();<br>topLeft *= scale;<br><br>Vector3 topRight = cameraTransform.forward * near + toRight + toTop;<br>topRight.Normalize();<br>topRight *= scale;<br><br>Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;<br>bottomLeft.Normalize();<br>bottomLeft *= scale;<br><br>Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;<br>bottomRight.Normalize();<br>bottomRight *= scale;<br><br>frustumCorners.SetRow(<span class="hljs-number">0</span>, bottomLeft);<br>frustumCorners.SetRow(<span class="hljs-number">1</span>, bottomRight);<br>frustumCorners.SetRow(<span class="hljs-number">2</span>, topRight);<br>frustumCorners.SetRow(<span class="hljs-number">3</span>, topLeft);<br><br>material.SetMatrix(<span class="hljs-string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);<br><br>material.SetFloat(<span class="hljs-string">&quot;_FogDensity&quot;</span>, fogDensity);<br>material.SetColor(<span class="hljs-string">&quot;_FogColor&quot;</span>, fogColor);<br>material.SetFloat(<span class="hljs-string">&quot;_FogStart&quot;</span>, fogStart);<br>material.SetFloat(<span class="hljs-string">&quot;_FogEnd&quot;</span>, fogEnd);<br><br>material.SetTexture(<span class="hljs-string">&quot;_NoiseTex&quot;</span>, noiseTexture);<br>material.SetFloat(<span class="hljs-string">&quot;_FogXSpeed&quot;</span>, fogXSpeed);<br>material.SetFloat(<span class="hljs-string">&quot;_FogYSpeed&quot;</span>, fogYSpeed);<br>material.SetFloat(<span class="hljs-string">&quot;_NoiseAmount&quot;</span>, noiseAmount);<br><br>Graphics.Blit (src, dest, material);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>fogDensity 用于控制雾的浓度，fogColor 用于控制雾的颜色。我们使用的雾效模拟函数是基于高度的，因此参数 fogStart 用于控制雾效的起始高度，fogEnd 用于控制雾效的终止高度。noiseTexture 是我们使用的噪声纹理，fogXSpeed 和 fogYSpeed 分别对应了噪声纹理在 X 和 Y 方向上的移动速度，以此来模拟雾的飘动效果。最后，noiseAmount 用于控制噪声程度，当 noiseAmount 为 0 时，表示不应用任何噪声，即得到一个均匀的基于高度的全局雾效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter15/Chapter15-FogWithNoise&quot; &#123;<br><br>    Properties &#123;<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _FogDensity (&quot;Fog Density&quot;, Float) = 1.0<br>        _FogColor (&quot;Fog Color&quot;, Color) = (1, 1, 1, 1)<br>        _FogStart (&quot;Fog Start&quot;, Float) = 0.0<br>        _FogEnd (&quot;Fog End&quot;, Float) = 1.0<br>        _NoiseTex (&quot;Noise Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _FogXSpeed (&quot;Fog Horizontal Speed&quot;, Float) = 0.1<br>        _FogYSpeed (&quot;Fog Vertical Speed&quot;, Float) = 0.1<br>        _NoiseAmount (&quot;Noise Amount&quot;, Float) = 1<br>    &#125;<br>    SubShader &#123;<br>        CGINCLUDE<br>        <br>        #include &quot;UnityCG.cginc&quot;<br>        <br>        float4x4 _FrustumCornersRay;<br>        <br>        sampler2D _MainTex;<br>        half4 _MainTex_TexelSize;<br>        sampler2D _CameraDepthTexture;<br>        half _FogDensity;<br>        fixed4 _FogColor;<br>        float _FogStart;<br>        float _FogEnd;<br>        sampler2D _NoiseTex;<br>        half _FogXSpeed;<br>        half _FogYSpeed;<br>        half _NoiseAmount;<br>        <br>        struct v2f &#123;<br>            float4 pos : SV_POSITION;<br>            float2 uv : TEXCOORD0;<br>            float2 uv_depth : TEXCOORD1;<br>            float4 interpolatedRay : TEXCOORD2;<br>        &#125;;<br>        <br>        v2f vert(appdata_img v) &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br>            <br>            o.uv = v.texcoord;<br>            o.uv_depth = v.texcoord;<br>            <br>            #if UNITY_UV_STARTS_AT_TOP<br>            if (_MainTex_TexelSize.y &lt; 0)<br>            o.uv_depth.y = 1 - o.uv_depth.y;<br>            #endif<br>            <br>            int index = 0;<br>            if (v.texcoord.x &lt; 0.5 &amp;&amp; v.texcoord.y &lt; 0.5) &#123;<br>                index = 0;<br>                &#125; else if (v.texcoord.x &gt; 0.5 &amp;&amp; v.texcoord.y &lt; 0.5) &#123;<br>                index = 1;<br>                &#125; else if (v.texcoord.x &gt; 0.5 &amp;&amp; v.texcoord.y &gt; 0.5) &#123;<br>                index = 2;<br>                &#125; else &#123;<br>                index = 3;<br>            &#125;<br>            #if UNITY_UV_STARTS_AT_TOP<br>            if (_MainTex_TexelSize.y &lt; 0)<br>            index = 3 - index;<br>            #endif<br>            <br>            o.interpolatedRay = _FrustumCornersRay[index];<br>            <br>            return o;<br>        &#125;<br>        <br>        fixed4 frag(v2f i) : SV_Target &#123;<br>            float linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));<br>            float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;<br>            <br>            float2 speed = _Time.y * float2(_FogXSpeed, _FogYSpeed);<br>            float noise = (tex2D(_NoiseTex, i.uv + speed).r - 0.5) * _NoiseAmount;<br>            <br>            float fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); <br>            fogDensity = saturate(fogDensity * _FogDensity * (1 + noise));<br>            <br>            fixed4 finalColor = tex2D(_MainTex, i.uv);<br>            finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);<br>            <br>            return finalColor;<br>        &#125;<br>        <br>        ENDCG<br>        <br>        Pass &#123;          <br>            CGPROGRAM  <br>            <br>            #pragma vertex vert  <br>            #pragma fragment frag  <br>            <br>            ENDCG<br>        &#125;<br>    &#125; <br>    FallBack Off<br>&#125;<br></code></pre></td></tr></table></figure><p>在片元着色器中，我们首先根据深度纹理来重建该像素在世界空间中的位置。然后，我们利用内置的 _Time.y 变量和 _FogXSpeed、_FogYSpeed 属性计算出当前噪声纹理的偏移量，并据此对噪声纹理进行采样，得到噪声值。随后，我们把该噪声值添加到雾效浓度的计算中，得到应用噪声后的雾效混合系数 fogDensity。最后，我们使用该系数将雾的颜色和原始颜色进行混合后返回。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;消融效果&quot;&gt;消融效果&lt;/h2&gt;
&lt;p&gt;**消融（dissolve）**效果常见于游戏中的角色死亡、地图烧毁等效果。在这些效果中，消融往往从不同的区域开始，并向看似随机的方向扩张，最后整个物体都将消失不见。我们将学习如何在 Unity 中实现这种效果，并得到类似下图</summary>
      
    
    
    
    <category term="Unity Shader" scheme="http://example.com/categories/Unity-Shader/"/>
    
    
    <category term="Texture" scheme="http://example.com/tags/Texture/"/>
    
  </entry>
  
  <entry>
    <title>非真实感渲染</title>
    <link href="http://example.com/posts/%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/"/>
    <id>http://example.com/posts/%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93/</id>
    <published>2022-04-16T02:57:42.000Z</published>
    <updated>2025-04-17T12:55:15.937Z</updated>
    
    <content type="html"><![CDATA[<p>尽管游戏渲染一般都是以**照相写实主义（photorealism）<strong>作为主要目标，但也有许多游戏使用了</strong>非真实感渲染（Non-Photorealistic Rendering，NPR）**的方法来渲染游戏画面。非真实感渲染的一个主要目标是，使用一些渲染方法使得画面达到和某些特殊的绘画风格相似的效果，例如卡通、水彩风格等。</p><h2 id="卡通风格的渲染">卡通风格的渲染</h2><p>卡通风格是游戏中常见的一种渲染风格。使用这种风格的游戏画面通常有一些共有的特点，例如物体都被黑色的线条描边，以及分明的明暗变化等。</p><p>要实现卡通渲染有很多方法，其中之一就是使用**基于色调的着色技术（tone-based shading）。在实现中，我们往往会使用漫反射系数对一张一维纹理进行采样，以控制漫反射的色调，高光效果也和之前学习的光照不同。在卡通风格中，模型的高光往往是一块块分界明显的纯色区域。</p><p>除了光照模型不同外，卡通风格通常还需要在物体边缘部分绘制轮廓。之前我们使用屏幕后处理技术对屏幕图像进行描边，这次我们将介绍基于模型的描边方法，这种方法的实现更加简单，而且在很多情况下也能得到不错的效果。</p><h3 id="渲染轮廓线">渲染轮廓线</h3><p>在实时渲染中，轮廓线的渲染是应用非常广泛的一种效果。近 20 年来，有许多绘制模型轮廓线的方法被先后提出来。在《Real Time Rendering，third edition》一书中，作者把这些方法分成了 5 种类型。</p><ul><li>基于观察角度和表面法线的轮廓线渲染。这种方法使用视角方向和表面法线的点乘结果来得到轮廓线的信息。这种方法简单快速，可以在一个 Pass 中就得到渲染结果，但局限性很大，很多模型渲染出来的描边效果都不尽如人意。</li><li>过程式几何轮廓线渲染。这种方法的核心是使用两个 Pass 渲染。第一个 Pass 渲染背面的面片，并使用某些技术让它的轮廓可见；第二个 Pass 再正常渲染正面的面片。这种方法的优点在于快速有效，并且适用于绝大多数表面平滑的模型，但它的缺点是不适合类似于立方体这样平整的模型。</li><li>基于图像处理的轮廓线渲染。这种方法的优点在于，可以适用于任何种类的模型。但它也有自身的局限所在，一些深度和法线变化很小的轮廓无法被检测出来，例如桌子上的纸张。</li><li>基于轮廓边检测的轮廓线渲染。上面提到的各种方法，一个最大的问题是，无法控制轮廓线的风格渲染。对与一些情况，我们希望可以渲染出独特风格的轮廓线，例如水墨风格等。为此，我们希望可以检测出精确的轮廓边，然后直接渲染它们。检测一条边是否是轮廓边的公式很简单，我们只需要检查和这条边相邻的两个三角面片是否满足以下条件：<br>$$<br>(n_0 \cdot v &gt; 0) \neq (n_1 \cdot v &gt; 0)<br>$$<br>其中，$n_0$ 和 $n_1$ 分别表示两个相邻三角面片的法向，$v$ 是从视角到该边上任意顶点的方向。上述公式的本质在于检查两个相邻的三角面片是否一个朝正面、一个朝背面。我们可以在几何着色器（Geometry Shader）的帮助下实现上面的检测过程。当然，这种方法也有缺点，除了实现相对复杂外，它还会有动画连贯性的问题。也就是说，由于是逐帧单独提取轮廓，所以在帧与帧之间会出现跳跃性。</li><li>最后一个种类就是混合了上述的几种渲染方法，例如，首先找到精确的轮廓边，把模型和轮廓边渲染到纹理中，再使用图像处理的方法识别出轮廓线，并在图像空间下进行风格化渲染。</li></ul><p>下面，我们将使用过程式几何轮廓线渲染的方法来对模型进行轮廓描边。我们将使用两个 Pass 渲染模型：在第一个 Pass 中，我们会使用轮廓线颜色渲染整个背面的面片，并在视角空间下把模型顶点沿着法线方向向外扩张一段距离，以此来让背部轮廓线可见。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">viewPos = viewPos + viewNormal * _Outline;<br></code></pre></td></tr></table></figure><p>但是，如果直接使用顶点法线进行扩展，对于一些内凹的模型，就可能发生背面面片遮挡正面面片的情况。为了尽可能防止出现这样的情况，在扩张背面顶点之前，我们首先对顶点法线的 z 分量进行处理，使它们等于一个定值，然后把法线归一化后再对顶点进行扩张。这样的好处在于，扩展后的背面更加扁平化，从而降低了遮挡正面面片的可能性。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">viewNormal.z = -0.5;<br>viewNormal = normalize(viewNormal);<br>viewPos = viewPos + viewNormal * _Outline;<br></code></pre></td></tr></table></figure><h3 id="添加高光">添加高光</h3><p>前面提到过，卡通风格中的高光往往是模型上一块块分界明显的纯色区域。为了实现这种效果，我们就不能再使用之前学习的光照模型。回顾一下，在之前实现 Blinn-Phong 模型的过程中，我们使用法线点乘光照方向以及视角方向和的一半，再和另一个参数进行指数操作得到高光反射系数。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float spec = pow(max(0, dot(normal, halfDir)), _Gloss)<br></code></pre></td></tr></table></figure><p>对于卡通渲染需要的高光反射光照模型，我们同样需要计算 normal 和 halfDir 的点乘结果，但不同的是，我们把该值和一个阈值进行比较，如果小于该阈值，则高光反射系数为 0，否则返回 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float spec = dot(worldNormal, worldHalfDir);<br>spec = step(threshold, spec);<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用 CG 的 <strong>step 函数</strong>来实现和阈值比较的目的。step 函数接受两个参数，第一个参数是参考值，第二个参数是待比较的数值。如果第二个参数大于等于第一个参数，则返回 1，否则返回 0。</p><p>但是，这种粗暴的判断方法会在高光区域的边界造成锯齿，如下图所示。出现这种问题的原因是，高光区域的边缘不是平滑渐变的，而是由 0 突变到 1。要想对其进行抗锯齿处理，我们可以在边界处很小的一块区域内，进行平滑处理。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float spec = dot(worldNormal, worldHalfDir);<br>spec = lerp(0, 1, smoothstep(-w, w, spec - threshold));<br></code></pre></td></tr></table></figure><p><img src="/posts_image/Non-Photorealistic_Rendering/Non-Photorealistic_Rendering_1.png" alt="抗锯齿" title="抗锯齿"></p><p>在上面的代码中，我们没有像之前一样直接使用 step 函数返回 0 或 1，而是首先使用了 CG 的 <strong>smoothstep 函数</strong>。其中，w 是一个很小的值，当 spec - threshold 小于 -w 时，返回 0，大于 w 时，返回 1，否则在 0 到 1 之间进行插值。这样的效果是，我们可以在 [-w, w] 区间内，即高光区域的边界处，得到一个从 0 到 1 平滑变化的 spec 值，从而实现抗锯齿的目的。尽管我们可以把 w 设为一个很小的定值，但在本例中，我们选择使用邻域像素之间的近似导数值，这可以通过 CG 的 <strong>fwidth 函数</strong> 来得到。</p><h3 id="实现">实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br>// Upgrade NOTE: replaced &#x27;_World2Object&#x27; with &#x27;unity_WorldToObject&#x27;<br>// Upgrade NOTE: replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;<br><br>Shader &quot;Custom/Chapter14/Chapter14-ToonShading&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (1,1,1,1)<br>        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Ramp (&quot;Ramp Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Outline (&quot;Outline&quot;, Range(0, 1)) = 0.1<br>        _OutlineColor (&quot;Outline Color&quot;, Color) = (0, 0, 0, 1)<br>        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)<br>        _SpecularScale (&quot;Specular Scale&quot;, Range(0, 0.1)) = 0.01<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot; &#125;<br>        Pass &#123;<br>            NAME &quot;OUTLINE&quot;<br><br>            Cull Front<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br>            <br>            #include &quot;UnityCG.cginc&quot;<br><br>            float _Outline;<br>            fixed4 _OutlineColor;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>            &#125;;<br><br>            v2f vert (a2v v) &#123;<br>                v2f o;<br>                float4 pos = mul(UNITY_MATRIX_MV, v.vertex);<br>                float3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);<br>                normal.z = -0.5;<br>                pos = pos + float4(normalize(normal), 0) * _Outline;<br>                o.pos = mul(UNITY_MATRIX_P, pos);<br>                return o;<br>            &#125;<br><br>            float4 frag(v2f i) : SV_TARGET &#123;<br>                return float4(_OutlineColor.rgb, 1);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br><br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>            Cull Back<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #pragma multi_compile_fwdbase<br><br>            #include &quot;UnityCG.cginc&quot;<br>            #include &quot;Lighting.cginc&quot;<br>            #include &quot;AutoLight.cginc&quot;<br>            #include &quot;UnityShaderVariables.cginc&quot;<br><br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            sampler2D _Ramp;<br>            fixed4 _Specular;<br>            fixed _SpecularScale;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>                float4 tangent : TANGENT;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : POSITION;<br>                float2 uv : TEXCOORD0;<br>                float3 worldNormal : TEXCOORD1;<br>                float3 worldPos : TEXCOORD2;<br>                SHADOW_COORDS(3)<br>            &#125;;<br><br>            v2f vert (a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                TRANSFER_SHADOW(o);<br>                return o;<br>            &#125;<br><br>            float4 frag(v2f i) : SV_TARGET &#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));<br>                fixed3 worldHalfDir = normalize(worldLightDir + worldViewDir);<br><br>                fixed4 c = tex2D(_MainTex, i.uv);<br>                fixed3 albedo = c.rgb * _Color.rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br>                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br>                fixed diff = dot(worldNormal, worldLightDir);<br>                diff = (diff * 0.5 + 0.5) * atten;<br><br>                fixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb;<br><br>                fixed spec = dot(worldNormal, worldHalfDir);<br>                fixed w = fwidth(spec) * 2.0;<br>                fixed3 specular = _Specular.rgb * lerp(0, 1, smoothstep(-w, w, spec + _SpecularScale -1)) * step(0.0001, _SpecularScale);<br><br>                return fixed4(ambient + diffuse + specular, 1.0);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Diffuse&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>_Ramp 是用于控制漫反射色调的渐变纹理，_Outline 用于控制轮廓线宽度，_OutlineColor 对应了轮廓线颜色，_Specular 是高光反射颜色，_SpecularScale 用于控制计算高光反射时使用的阈值。</p><p>在第一个 Pass 中渲染轮廓线。这个 Pass 只渲染背面的三角面片，因此我们使用 Cull 指令把正面的三角面片剔除。我们还使用 NAME 命令为该 Pass 定义了名称。这是因为，描边在非真实感渲染中是非常常见的效果，为该 Pass 定义名称可以让我们在后面的使用中不需要再重复编写此 Pass，而只需要调用它的名字即可。在顶点着色器中我们首先把顶点和法线变换到视角空间下，这是为了让描边可以在观察空间达到最好的效果。随后，我们设置法线的 z 分量，对其归一化后再将顶点沿其方向扩张，得到扩张后的顶点坐标。对法线的处理是为了尽可能避免背面扩张后的顶点挡住正面的面片。最后，我们把顶点从视角空间变换到裁剪空间。片元着色器代码非常简单，我们只需要用轮廓线颜色渲染整个背面即可。</p><p>在第二个 Pass 中定义光照模型，以渲染模型的正面。首先，我们计算了光照模型中需要的各个方向矢量，并对它们进行了归一化处理。然后，我们计算了材质的反射率 albedo 和环境光照 ambient。接着，我们使用内置的 UNITY_LIGHT_ATTENUATION 宏来计算当前世界坐标下的阴影值。随后，我们计算了半兰伯特漫反射系数，并和阴影值相乘得到最终的漫反射系数。我们使用这个漫反射系数对渐变纹理 _Ramp 进行采样，并将结果和材质的反射率、光照颜色相乘，作为最后的漫反射光照。高光反射的计算和上面介绍的方法一致，我们使用 fwidth 对高光区域的边界进行抗锯齿处理，并将计算而得的高光反射系数和高光反射颜色相乘，得到高光反射的光照部分。值得注意的是，我们在最后还使用了step(0.0001, _SpecularScale)，这是为了在 _SpecularScale 为 0 时，可以完全消除高光反射的光照。最后，返回环境光照、漫反射光照和高光反射光照叠加的结果。</p><p><img src="/posts_image/Non-Photorealistic_Rendering/Non-Photorealistic_Rendering_2.png" alt="卡通风格的渲染效果" title="卡通风格的渲染效果"></p><h2 id="素描风格的渲染">素描风格的渲染</h2><p>另一个非常流行的非真实感渲染是素描风格的渲染。我们可以使用提前生成的素描纹理来实现实时的素描风格渲染，这些纹理组成了一个**色调艺术映射（Tonal Art Map，TAM），如下图所示。在图中，从左到右纹理中的笔触逐渐增多，用于模拟不同光照下的漫反射效果，从上到下则对应了每张纹理的多级渐远纹理（mipmaps）。这些多级渐远纹理的生成并不是简单的对上一层纹理进行降采样，而是需要保持笔触之间的间隔，以便更真实地模拟素描效果。</p><p><img src="/posts_image/Non-Photorealistic_Rendering/Non-Photorealistic_Rendering_3.png" alt="一个TAM的例子" title="一个TAM的例子"></p><p>本节将会实现简化版的算法，不考虑多级渐远纹理的生成，而是直接使用 6 张素描纹理进行渲染。在渲染阶段，我们首先在顶点着色阶段计算逐顶点的光照，根据光照结果来决定 6 张纹理的混合权重，并传递给片元着色器。然后，在片元着色器中根据这些权重来混合 6 张纹理的采样结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br>// Upgrade NOTE: replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;<br><br>Shader &quot;Custom/Chapter14/Chapter14-Hatching&quot; &#123;<br><br>    Properties &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (1,1,1,1)<br>        _TileFactor (&quot;Tile Factor&quot;, Float) = 1<br>        _Outline (&quot;Outline&quot;, Range(0, 1)) = 0.1<br>        _Hatch0 (&quot;Hatch 0&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Hatch1 (&quot;Hatch 1&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Hatch2 (&quot;Hatch 2&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Hatch3 (&quot;Hatch 3&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Hatch4 (&quot;Hatch 4&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Hatch5 (&quot;Hatch 5&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>    &#125;<br><br>    SubShader &#123;<br>        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;<br><br>        UsePass &quot;Custom/Chapter14/Chapter14-ToonShading/OUTLINE&quot;<br><br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br>            <br>            CGPROGRAM<br>            <br>            #pragma vertex vert<br>            #pragma fragment frag <br>            <br>            #pragma multi_compile_fwdbase<br>            <br>            #include &quot;UnityCG.cginc&quot;<br>            #include &quot;Lighting.cginc&quot;<br>            #include &quot;AutoLight.cginc&quot;<br>            #include &quot;UnityShaderVariables.cginc&quot;<br><br>            fixed4 _Color;<br>            float _TileFactor;<br>            sampler2D _Hatch0;<br>            sampler2D _Hatch1;<br>            sampler2D _Hatch2;<br>            sampler2D _Hatch3;<br>            sampler2D _Hatch4;<br>            sampler2D _Hatch5;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float4 tangent : TANGENT;<br>                float3 normal : NORMAL;<br>                float2 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float2 uv : TEXCOORD0;<br>                fixed3 hatchWeights0 : TEXCOORD1;<br>                fixed3 hatchWeights1 : TEXCOORD2;<br>                float3 worldPos : TEXCOORD3;<br>                SHADOW_COORDS(4)<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.uv = v.texcoord.xy * _TileFactor;<br>                fixed3 worldLightDir = normalize(WorldSpaceLightDir(v.vertex));<br>                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);<br>                fixed diff = max(0, dot(worldLightDir, worldNormal));<br><br>                o.hatchWeights0 = fixed3(0, 0, 0);<br>                o.hatchWeights1 = fixed3(0, 0, 0);<br><br>                float hatchFactor = diff * 7.0;<br><br>                if (hatchFactor &gt; 6.0) &#123;<br>                    //Pure white, do nothing<br>                    &#125; else if (hatchFactor &gt; 5.0) &#123;<br>                    o.hatchWeights0.x = hatchFactor - 5.0;<br>                    &#125; else if (hatchFactor &gt; 4.0) &#123;<br>                    o.hatchWeights0.x = hatchFactor - 4.0;<br>                    o.hatchWeights0.y = 1.0 - o.hatchWeights0.x;<br>                    &#125; else if (hatchFactor &gt; 3.0) &#123;<br>                    o.hatchWeights0.y = hatchFactor - 3.0;<br>                    o.hatchWeights0.z = 1.0 - o.hatchWeights0.y;<br>                    &#125; else if (hatchFactor &gt; 2.0) &#123;<br>                    o.hatchWeights0.z = hatchFactor - 2.0;<br>                    o.hatchWeights1.x = 1.0 - o.hatchWeights0.z;<br>                    &#125; else if (hatchFactor &gt; 1.0) &#123;<br>                    o.hatchWeights1.x = hatchFactor - 1.0;<br>                    o.hatchWeights1.y = 1.0 - o.hatchWeights1.x;<br>                    &#125; else &#123;<br>                    o.hatchWeights1.y = hatchFactor;<br>                    o.hatchWeights1.z = 1.0 - o.hatchWeights1.y;<br>                &#125;<br><br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br>                TRANSFER_SHADOW(o);<br><br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET &#123;<br>                fixed4 hatchTex0 = tex2D(_Hatch0, i.uv) * i.hatchWeights0.x;<br>                fixed4 hatchTex1 = tex2D(_Hatch1, i.uv) * i.hatchWeights0.y;<br>                fixed4 hatchTex2 = tex2D(_Hatch2, i.uv) * i.hatchWeights0.z;<br>                fixed4 hatchTex3 = tex2D(_Hatch3, i.uv) * i.hatchWeights1.x;<br>                fixed4 hatchTex4 = tex2D(_Hatch4, i.uv) * i.hatchWeights1.y;<br>                fixed4 hatchTex5 = tex2D(_Hatch5, i.uv) * i.hatchWeights1.z;<br><br>                fixed4 whiteColor = fixed4(1,1,1,1) * (1 - i.hatchWeights0.x - i.hatchWeights0.y - i.hatchWeights0.z - i.hatchWeights1.x - i.hatchWeights1.y - i.hatchWeights1.z);<br>                fixed4 hatchColor = hatchTex0 + hatchTex1 + hatchTex2 + hatchTex3 + hatchTex4 + hatchTex5 + whiteColor;<br><br>                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br>                return fixed4(hatchColor.rgb * _Color.rgb * atten, 1.0);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    FallBack &quot;Diffuse&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中，_Color 是用于控制模型颜色的属性。_TileFactor 是纹理的平铺系数，_TileFactor 越大，模型上的素描线条越密。_Hatch0 至 _Hatch5 对应了渲染时使用的 6 张素描纹理，它们的线条密度依次增大。由于一共声明了 6 张纹理，这意味着需要 6 个混合权重，我们把它们存储在两个 fixed3 类型的变量（hatchWeights0 和 hatchWeights1）中。为了添加阴影效果，我们还声明了 worldPos 变量，并使用 SHADOW_COORDS 宏声明了阴影纹理的采样坐标。</p><p>在顶点着色器中，我们首先对顶点进行了基本的坐标变换。然后，使用 _TileFactor 得到了纹理采样坐标。在计算 6 张纹理的混合权重之前，我们首先需要计算逐顶点光照。因此，我们使用世界空间下的光照方向和法线方向得到漫反射系数 diff。之后，我们把权重值初始化为 0，并把 diff 缩放到[0, 7]范围，得到 hatchFactor。我们把[0, 7]的区间均匀划分为 7 个子区间，通过判断 hatchFactor 所处的子区间来计算对应的纹理混合权重。最后，我们计算了顶点的世界坐标，并使用 TRANSFER_SHADOW 宏来计算阴影纹理的采样坐标。</p><p>在片元着色器中，当得到了 6 张纹理的混合权重后，我们对每张纹理进行采样并和它们对应的权重值相乘得到每张纹理的采样颜色。我们还计算了纯白在渲染中的贡献度，这是通过从 1 中减去所有 6 张纹理的权重来得到的。这是因为素描中往往有留白的部分，因此我们希望在最后的渲染中光照最亮的部分是纯白色的。最后，我们混合了各个颜色值，并和阴影值 atten、模型颜色 _Color 相乘后返回最终的渲染结果。</p><p><img src="/posts_image/Non-Photorealistic_Rendering/Non-Photorealistic_Rendering_4.png" alt="素描风格的渲染效果" title="素描风格的渲染效果"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;尽管游戏渲染一般都是以**照相写实主义（photorealism）&lt;strong&gt;作为主要目标，但也有许多游戏使用了&lt;/strong&gt;非真实感渲染（Non-Photorealistic Rendering，NPR）**的方法来渲染游戏画面。非真实感渲染的一个主要目标是，使用</summary>
      
    
    
    
    <category term="Unity Shader" scheme="http://example.com/categories/Unity-Shader/"/>
    
    
    <category term="Rendering" scheme="http://example.com/tags/Rendering/"/>
    
  </entry>
  
  <entry>
    <title>深度和法线纹理</title>
    <link href="http://example.com/posts/%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86/"/>
    <id>http://example.com/posts/%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86/</id>
    <published>2022-03-21T03:25:19.000Z</published>
    <updated>2025-04-17T12:55:15.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取深度和法线纹理">获取深度和法线纹理</h2><h3 id="背后的原理">背后的原理</h3><p>深度纹理实际上就是一张渲染纹理，只不过它里面存储的像素值不是颜色值，而是一个高精度的深度值。由于被存储在一张纹理中，深度纹理里的深度值范围是[0, 1]，而且通常是非线性分布的。这些深度值来自于顶点变换后得到的归一化的设备坐标（Normalized Device Coordinates，NDC）。想要在屏幕上绘制一个模型，需要把模型顶点在顶点着色器中乘以 MVP 变换矩阵，将顶点从模型空间变换到齐次裁剪坐标系下。在变换的最后一步，我们使用一个投影矩阵来变换顶点，如果我们使用的是透视投影类型的摄像机，那这个投影矩阵就是非线性的。</p><p>下图显示了 Unity 中透视投影对顶点的变换过程。最左侧的图显示了投影变换前，即观察空间下视锥体的结构及相应的顶点位置，中间的图显示了应用透视裁剪矩阵后的变换结果，即顶点着色器阶段输出的顶点变换结果，最右侧的图则是底层硬件进行了透视除法后得到的归一化的设备坐标。需要注意的是，这里的投影过程是建立在 Unity 对坐标系的假定上的，也就是说，我们针对的是观察空间为右手坐标系，使用列矩阵在矩阵右侧进行相乘，且变换到 NDC 后 z 分量范围将在[-1, 1]之间的情况。而在类似 DirectX 这样的图形接口中，变换后 z 分量范围将在[0, 1]之间。如果需要在其他图形接口下实现本章的类似效果，需要对一些计算参数做出相应变化。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_1.png" alt="透视投影" title="透视投影"></p><p>下图显示了在使用正交摄像机时投影变换的过程。同样，变换后会得到一个范围为[-1, 1]的立方体。正交投影使用的变换矩阵是线性的。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_2.png" alt="正交投影" title="正交投影"></p><p>在得到 NDC 后，深度纹理中的像素值就可以很方便地计算得到了，这些深度值就对应了 NDC 中顶点坐标的 z 分量的值。由于 NDC 中 z 分量的范围在[-1, 1]，为了让这些值能够存储在一张图像中，我们需要使用下面的公式对其进行映射：<br>$$<br>d = 0.5 \cdot z_{ndc} + 0.5<br>$$<br>其中，$d$ 对应了深度纹理中的像素值，$z_{ndc}$ 对应了 NDC 坐标中的 z 分量的值。</p><p>那么 Unity 如何得到这样一张深度纹理呢？在 Unity 中，深度纹理可以直接来自于真正的深度缓存，也可以由一个单独的 Pass 渲染而得，这取决于使用的渲染路径和硬件。通常来讲，当使用延迟渲染路径（包括遗留的渲染路径）时，深度纹理理所当然的可以访问到，因为延迟渲染会把这些信息渲染到 G-buffer 中。而当无法直接获取深度缓存时，深度和法线纹理是通过一个单独的 Pass 渲染而得的。具体实现是，Unity 会使用着色器替换（Shader Replacement）技术选择那些渲染类型（即 SubShader 的 RenderType 标签）为 Opaque 的物体，判断它们使用的渲染队列是否小于等于 2500（内置的 Background、Geometry 和 AlphaTest 渲染队列均在此范围内），如果满足条件，就把它渲染到深度和法线纹理中。因此，想要让物体能够出现在深度和法线纹理中，就必须在 Shader 中<strong>设置正确的 RenderType 标签</strong>。</p><p>在 Unity 中，我们可以选择让一个摄像机生成一张深度纹理或是一张深度+法线纹理。当只需要一张单独的深度纹理时，Unity 会直接获取深度缓存或是按之前讲到的着色器替换技术，选取需要的不透明物体，并使用它投射阴影时使用的 Pass（即 LightMode 被设置为 ShadowCaster 的 Pass）来得到深度纹理。如果 Shader 中不包含这样一个 Pass，那么这个物体就不会出现在深度纹理中（当然，它也不能向其他物体投射阴影）。深度纹理的精度通常是 24 位或 16 位，这取决于使用的深度缓存的精度。如果选择生成一张深度+法线纹理，Unity 会创建一张和屏幕分辨率相同、精度为 32 位（每个通道为 8 位）的纹理，其中观察空间下的法线信息会被编码进纹理的 R 和 G 通道，而深度信息会被编码进 B 和 A 通道。法线信息的获取在延迟渲染中是可以非常容易就得到的，Unity 只需要合并深度和法线缓存即可。而在前向渲染中，默认情况下是不会创建法线缓存的，因此 Unity 底层使用了一个单独的 Pass 把整个场景再次渲染一遍来完成。</p><h3 id="如何获取">如何获取</h3><p>在 Unity 中，获取深度纹理是非常简单的，我们在脚本中设置摄像机的 depthTextureMode 后，就可以在 Shader 中直接访问特定的纹理属性。例如我们可以通过下面的代码来获取深度纹理：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">camera.depthTextureMode = DepthTextureMode.Depth;<br></code></pre></td></tr></table></figure><p>一旦设置好了上面的摄像机模式后，我们就可以在 Shader 中通过声明 _CameraDepthTexture 变量来访问它。</p><p>同理，如果想要获取深度+法线纹理，我们只需要在代码中这样设置：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">camera.depthTextureMode = DepthTextureMode.DepthNormals;<br></code></pre></td></tr></table></figure><p>然后在 Shader 中通过声明 _CameraDepthNormalsTexture 变量来访问它。</p><p>我们还可以组合这些模式，让一个摄像机同时产生一张深度和深度+法线纹理：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">camera.depthTextureMode |= DepthTextureMode.Depth;<br>camera.depthTextureMode |= DepthTextureMode.DepthNormals;<br></code></pre></td></tr></table></figure><p>我们还可以在摄像机的 Camera 组件上看到当前摄像机是否需要渲染深度或深度+法线纹理。当在 Shader 中访问到深度纹理 _CameraDepthTexture 后，我们就可以使用当前像素的纹理坐标对它进行采样。绝大多数情况下，我们直接使用 tex2D 函数采样即可，但在某些平台（例如 PS3 和 PSP2 ）上，我们需要一些特殊处理。Unity 为我们提供了一个统一的宏 SAMPLE_DEPTH_TEXTURE，用来处理这些由于平台差异造成的问题。而我们只需要在 Shader 中使用 SAMPLE_DEPTH_TEXTURE 宏对深度纹理进行采样，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv);<br></code></pre></td></tr></table></figure><p>其中，i.uv 是一个 float2 类型的变量，对应了当前像素的纹理坐标。类似的宏还有 SAMPLE_DEPTH_TEXTURE_PROJ 和 SAMPLE_DEPTH_TEXTURE_LOD。SAMPLE_DEPTH_TEXTURE_PROJ 宏同样接受两个参数——深度纹理和一个 float3 或 float4 类型的纹理坐标，它的内部使用了 tex2Dproj 这样的函数进行投影纹理采样，纹理坐标的前两个分量首先会除以最后一个分量，再进行纹理采样。如果提供了第四个分量，还会进行一次比较，通常用于阴影的实现中。SAMPLE_DEPTH_TEXTURE_PROJ 的第二个参数通常是由顶点着色器输出插值而得的屏幕坐标，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float d = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.scrPos));<br></code></pre></td></tr></table></figure><p>其中，i.scrPos 是在顶点着色器中通过调用 ComputeScreenPos(o.pos) 得到的屏幕坐标。上述这些宏的定义我们可以在 Unity 内置的 HLSLSupport.cginc 文件中找到。</p><p>当通过纹理采样得到深度值后，这些深度值往往是非线性的，这种非线性来自于透视投影使用的裁剪矩阵。然而，在我们的计算过程中通常需要线性的深度值，因此我们需要把投影后的深度值变换到线性空间下，例如视角空间下的深度值。那么，我们应该如何进行这个转换呢？实际上，我们只需要倒推顶点变换的过程即可。下面我们以透视投影为例，推导如何由深度纹理中的深度信息计算得到视角空间下的深度值。</p><p>当我们使用透视投影的裁剪矩阵 $P_{clip}$ 对视角空间下的一个顶点进行变换后，裁剪空间下的顶点的 z 和 w 分量为：</p><p>$$<br>z_{clip} = -z_{view}\frac{Far + Near}{Far - Near} - \frac{2 \cdot Near \cdot Far}{Far - Near}<br>$$<br>$$<br>w_{clip} = -z_{view}<br>$$</p><p>其中，$Far$ 和 $Near$ 分别是远近裁剪平面的距离。然后，我们通过齐次除法就可以得到 NDC 下的 z 分量：</p><p>$$<br>z_{ndc} = \frac{z_{clip}}{w_{clip}} = \frac{Far + Near}{Far - Near} + \frac{2 \cdot Near \cdot Far}{(Far - Near) \cdot z_{view}}<br>$$</p><p>深度纹理中的深度值是通过下面的公式由 NDC 计算而得的：<br>$$<br>d = 0.5 \cdot z_{ndc} + 0.5<br>$$<br>由上面的这些式子，我们可以推导出用 $d$ 表示而得的 $z_{view}$ 的表达式：<br>$$<br>z_{view} = \frac{1}{\frac{Far - Near}{Near \cdot Far}d - \frac{1}{Near}}<br>$$<br>由于在 Unity 使用的视角空间中，摄像机正向对应的 z 值均为负值，因此为了得到深度值的正数表示，我们需要对上面的结果取反，最后得到的结果如下：<br>$$<br>z_{view}^{'} = \frac{1}{\frac{Near - Far}{Near \cdot Far}d + \frac{1}{Near}}<br>$$<br>它的取值范围就是视锥体深度范围，即[Near, Far]。如果我们想得到范围在[0, 1]之间的深度值，只需要把上面得到的结果除以 Far 即可。这样，0 就表示该点与摄像机位于同一位置，1 表示该点位于视锥体的远裁剪平面上。结果如下：<br>$$<br>z_{01} = \frac{1}{\frac{Near - Far}{Near}d + \frac{Far}{Near}}<br>$$</p><p>Unity 提供了两个辅助函数来为我们进行上述的计算过程——LinearEyeDepth 和 Linear01Depth。LinearEyeDepth 负责把深度纹理采样结果转换到视角空间下的深度值，也就是我们上面得到的 $z_{view}^{'}$。而 Linear01Depth 则会返回一个范围在[0, 1]的线性深度值，也就是我们上面得到的 $z_{01}$。这两个函数内部使用了内置的 _ZBufferParams 变量来得到远近裁剪平面的距离。</p><p>如果我们需要获取深度+法线纹理，可以直接使用 tex2D 函数对 _CameraDepthNormalsTexture 进行采样，得到里面存储的深度和法线信息。Unity 提供了辅助函数来为我们对这个采样结果进行解码，从而得到深度值和法线方向。这个函数是 DecodeDepthNormal，它在 UnityCG.cginc 里被定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">inline void DecodeDepthNormal(float4 enc, out float depth, out float3 normal)&#123;<br>    depth = DecodeFloatRG(enc.zw);<br>    normal = DecodeViewNormalStereo(enc);<br>&#125;<br></code></pre></td></tr></table></figure><p>DecodeDepthNormal 的第一个参数是对深度+法线纹理的采样结果，这个采样结果是 Unity 对深度和法线信息编码后的结果，它的 xy 分量存储的是视角空间下的法线信息，而深度信息被编码进了 zw 分量。通过调用 DecodeDepthNormal 函数对采样结果解码后，我们就可以得到解码后的深度值和法线。这个深度值是范围在[0, 1]的线性深度值（这与单独的深度纹理中存储的深度值不同），而得到的法线则是视角空间下的法线方向。同样，我们也可以通过调用 DecodeFloatRG 和 DecodeViewNormalStereo 来解码深度+法线纹理中的深度和法线信息。</p><h3 id="查看深度和法线纹理">查看深度和法线纹理</h3><p>下图显示了使用帧调试器查看到的深度纹理和深度+法线纹理。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_3.png" alt="帧调试器查看深度和法线纹理" title="帧调试器查看深度和法线纹理"></p><p>使用帧调试器查看到的深度纹理是非线性空间的深度值，而深度+法线纹理都是由 Unity 编码后的结果。有时，显示出线性空间下的深度信息或解码后的法线方向会更加有用。此时，我们可以自行在片元着色器中输出转换或解码后的深度和法线值，如下图示。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_4.png" alt="线性空间下的深度纹理和解码后并被映射到[0, 1]范围内的视角空间下的法线纹理" title="线性空间下的深度纹理和解码后并被映射到[0, 1]范围内的视角空间下的法线纹理"></p><p>我们可以使用类似下面的代码来输出线性深度值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv);<br>float linearDepth = Linear01Depth(depth);<br>return fixed4(linearDepth, linearDepth, linearDepth, 1.0);<br></code></pre></td></tr></table></figure><p>或是输出法线方向：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">fixed3 normal = DecodeViewNormalStereo(tex2D(_CameraDepthNormalsTexture, i.uv).xy);<br>return fixed4(normal * 0.5 + 0.5, 1.0);<br></code></pre></td></tr></table></figure><p>在查看深度纹理时，得到的画面有可能几乎是全黑或全白的。这时候可以把摄像机的远裁剪平面的距离（Unity 默认为 1000）调小，使视锥体的范围刚好覆盖场景的所在区域。这是因为，由于投影变换时需要覆盖从近裁剪平面到远裁剪平面的所有深度区域，当远裁剪平面的距离过大时，就会导致离摄像机较近的距离被映射到非常小的深度值，如果场景是一个封闭的区域（如上图所示），那么这就会导致画面看起来几乎是全黑的。相反，如果场景是一个开放区域，且物体离摄像机的距离较远，就会导致画面几乎是全白的。</p><h2 id="再谈运动模糊">再谈运动模糊</h2><p>我们以前学习了如何通过混合多张屏幕图像来模拟运动模糊的效果。但是，另一种应用更加广泛的技术则是使用速度映射图。速度映射图中存储了每个像素的速度，然后使用这个速度来决定模糊的方向和大小。速度缓冲的生成有多种方法，一种方法是把场景中所有物体的速度渲染到一张纹理中。但这种方法的缺点在于需要修改场景中所有物体的 Shader 代码，使其添加计算速度的代码并输出到一个渲染纹理中。</p><p>《GPU Gems3》在第27章中介绍了一种生成速度映射图的方法。这种方法利用深度纹理在片元着色器中为每个像素计算其在世界空间下的位置，这是通过使用当前的视角 * 投影矩阵的逆矩阵对 NDC 下的顶点坐标进行变换得到的。当得到世界空间中的顶点坐标后，我们使用前一帧的视角 * 投影矩阵对其进行变换，得到该位置在前一帧中的 NDC 坐标。然后，我们计算前一帧和当前帧的位置差，生成该像素的速度。这种方法的优点是可以在一个屏幕后处理步骤中完成整个效果的模拟，但缺点是需要在片元着色器中进行两次矩阵乘法的操作，对性能有所影响。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MotionBlurWithDepthTexture</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader motionBlurShader;<br><span class="hljs-keyword">private</span> Material motionBlurMaterial = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);<br><span class="hljs-keyword">return</span> motionBlurMaterial;<br>&#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> Camera myCamera;<br><span class="hljs-keyword">public</span> Camera camera &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">if</span> (myCamera == <span class="hljs-literal">null</span>) &#123;<br>myCamera = GetComponent&lt;Camera&gt;();<br>&#125;<br><span class="hljs-keyword">return</span> myCamera;<br>&#125;<br>&#125;<br><br>[<span class="hljs-meta">Range(0.0f, 1.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> blurSize = <span class="hljs-number">0.5f</span>;<br><br><span class="hljs-keyword">private</span> Matrix4x4 previousViewProjectionMatrix;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span> &#123;<br>camera.depthTextureMode |= DepthTextureMode.Depth;<br><br>previousViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_BlurSize&quot;</span>, blurSize);<br><br>material.SetMatrix(<span class="hljs-string">&quot;_PreviousViewProjectionMatrix&quot;</span>, previousViewProjectionMatrix);<br>Matrix4x4 currentViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;<br>Matrix4x4 currentViewProjectionInverseMatrix = currentViewProjectionMatrix.inverse;<br>material.SetMatrix(<span class="hljs-string">&quot;_CurrentViewProjectionInverseMatrix&quot;</span>, currentViewProjectionInverseMatrix);<br>previousViewProjectionMatrix = currentViewProjectionMatrix;<br><br>Graphics.Blit (src, dest, material);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面的 OnRenderImage 函数很简单，我们首先需要计算和传递运动模糊使用的各个属性。本例需要使用两个变换矩阵——前一帧的视角 * 投影矩阵以及当前帧的视角 * 投影矩阵的逆矩阵。因此，我们通过调用 camera.worldToCameraMatrix 和 camera.projectionMatrix 来分别得到当前摄像机的视角矩阵和投影矩阵。对它们相乘后取逆，得到当前帧的视角 * 投影矩阵的逆矩阵，并传递给材质。然后，我们把取逆前的结果存储在 previousViewProjectionMatrix 变量中，以便在下一帧时传递给材质的 _PreviousViewProjectionMatrix 属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter13/Chapter13-MotionBlurWithDepthTexture&quot; &#123;<br><br>    Properties &#123;<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _BlurSize (&quot;Blur Size&quot;, Float) = 1.0<br>    &#125;<br><br>    SubShader &#123;<br>        CGINCLUDE<br>        #include &quot;UnityCG.cginc&quot;<br><br>        sampler2D _MainTex;<br>        half4 _MainTex_TexelSize;<br>        sampler2D _CameraDepthTexture;<br>        float4x4 _CurrentViewProjectionInverseMatrix;<br>        float4x4 _PreviousViewProjectionMatrix;<br>        half _BlurSize;<br><br><br>        struct v2f &#123;<br>            float4 pos : SV_POSITION;<br>            half2 uv : TEXCOORD0;<br>            half2 uv_depth : TEXCOORD1;<br>        &#125;;<br><br>        v2f vert(appdata_img v) &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br><br>            o.uv = v.texcoord;<br>            o.uv_depth = v.texcoord;<br><br>            #if UNITY_UV_STARTS_AT_TOP<br>            if (_MainTex_TexelSize.y &lt; 0)<br>                o.uv_depth.y = 1 - o.uv_depth.y;<br>            #endif<br><br>            return o;<br>        &#125;<br><br>        fixed4 frag(v2f i) : SV_Target &#123;<br>            //Get the depth buffer value at this pixel.<br>            float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth);<br>            //H is the viewport position at this pixel in the range -1 to 1.<br>            float4 H = float4(i.uv.x * 2 - 1, i.uv.y * 2 - 1, d * 2 - 1, 1);<br>            //Transform by the view-projection inverse<br>            float4 D = mul(_CurrentViewProjectionInverseMatrix, H);<br>            //Divide by w to get the world position.<br>            float4 worldPos = D / D.w;<br><br>            //current viewport position<br>            float4 currentPos = H;<br>            //Use the world position, and transform by the previous view-projection matrix.<br>            float4 previousPos = mul(_PreviousViewProjectionMatrix, worldPos);<br>            //Convert to nonhomogeneous points [-1, 1] by dividing by w.<br>            previousPos /= previousPos.w;<br><br>            //Use this frame&#x27;s position and last frame&#x27;s to compute the pixel velocity.<br>            float2 velocity = (currentPos.xy - previousPos.xy) / 2.0f;<br><br>            float2 uv = i.uv;<br>            float4 c = tex2D(_MainTex, uv);<br>            uv += velocity * _BlurSize;<br>            for (int it = 1; it &lt; 3; it++, uv += velocity * _BlurSize) &#123;<br>                float4 currentColor = tex2D(_MainTex, uv);<br>                c += currentColor;<br>            &#125;<br>            c /= 3;<br><br>            return fixed4(c.rgb, 1.0);<br>        &#125;<br>        ENDCG<br><br>        Pass &#123;<br>            ZTest Always Cull Off ZWrite Off<br>            CGPROGRAM<br>            #pragma vertex vert<br>            #pragma fragment frag<br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    FallBack Off<br>&#125;<br></code></pre></td></tr></table></figure><p>_MainTex 对应了输入的渲染纹理，_BlurSize 是模糊图像时使用的参数。虽然在脚本里设置了材质的 _PreviousViewprojectionMatrix 和 _CurrentViewProjectionInverseMatrix 属性，但并没有在 Properties 块中声明它们。这是因为 Unity 没有提供矩阵类型的属性，但我们仍然可以在 CG 代码块中定义这些矩阵，并从脚本中设置它们。</p><p>除了定义在 Properties 声明的 _MainTex 和 _BlurSize 属性，我们还声明了其他三个变量。_CameraDepthTexture 是 Unity 传递给我们的深度纹理，而 _CurrentViewProjectionInverseMatrix 和 _PreviousViewProjectionMatrix 是由脚本传递而来的矩阵。除此之外，我们还声明了 _MainTex_TexelSize 变量，它对应了主纹理的纹素大小，我们需要使用该变量来对深度纹理的采样坐标进行平台差异化处理。</p><p>由于在本例中，我们需要同时处理多张渲染纹理，因此在 DirectX 这样的平台上，我们需要处理平台差异导致的图像翻转问题。在上面的代码中，我们对深度纹理的采样坐标进行了平台差异化处理，以便在类似 DirectX 的平台上，在开启了抗锯齿的情况下仍然可以得到正确的结果。</p><p>我们首先需要利用深度纹理和当前帧的视角 * 投影矩阵的逆矩阵来求得该像素在世界空间下的坐标。过程开始于对深度纹理的采样，我们使用内置的 SAMPLE_DEPTH_TEXTURE 宏和纹理坐标对深度纹理进行采样，得到了深度值 $d$。$d$ 是由 NDC 下的坐标映射而来的。我们想要构建像素的 NDC 坐标 $H$，就需要把这个深度值重新映射回 NDC。这个映射很简单，只需要使用原映射的反函数即可，即 $d$ * 2 - 1。同样，NDC 的 xy 分量可以由像素的纹理坐标映射而来（NDC 下的 xyz 分量范围均为[-1, 1]）。当得到 NDC 下的坐标 $H$ 后，我们就可以使用当前帧的视角 * 投影矩阵的逆矩阵对其进行变换，并把结果值除以它的 w 分量来得到世界空间下的坐标表示 worldPos。</p><p>一旦得到了世界空间下的坐标，我们就可以使用前一帧的视角 * 投影矩阵对它进行变换，得到前一帧在 NDC 下的坐标 previousPos。然后，我们计算前一帧和当前帧在屏幕空间下的位置差，得到该像素的速度 velocity。当得到该像素的速度后，我们就可以使用该速度值对它的邻域像素进行采样，相加后取平均值得到一个模糊的效果。采样时我们还使用了 _BlurSize 来控制采样距离。</p><p>本次实现的运动模糊适用于场景静止、摄像机快速运动的情况，这是因为我们在计算时只考虑了摄像机的运动。因此，如果把这些代码应用到一个物体快速运动而摄像机静止的场景，会发现不会产生任何运动模糊效果。如果我们想要对快速移动的物体产生运动模糊的效果，就需要生成更加精确的速度映射图。我们可以在 Unity 自带的 ImageEffect 包中找到更多的运动模糊的实现方法。</p><p>本次选择在片元着色器中使用逆矩阵来重建每个像素在世界空间下的位置。但是，这种做法往往会影响性能，下面我们会介绍一种更快速的由深度纹理重建世界坐标的方法。</p><h2 id="全局雾效">全局雾效</h2><p>**雾效（Fog）**是游戏里经常使用的一种效果。Unity 内置的雾效可以产生基于距离的线性或指数雾效。然而，要想在自己编写的顶点/片元着色器中实现这些雾效，我们需要在 Shader 中添加 #pragma multi_compile_fog 指令，同时还需要使用相关的内置宏，例如 UNITY_FOG_COORDS、UNITY_TRANSFER_FOG 和 UNTIY_APPLY_FOG 等。这种方法的缺点在于，我们不仅需要为场景中所有物体添加相关的渲染代码，而且能够实现的效果也非常有限。当我们需要对雾效进行一些个性化操作时，例如使用基于高度的雾效等，仅仅使用 Unity 内置的雾效就变得不再可行。</p><p>我们将学习一种基于屏幕后处理的全局雾效的实现。使用这种方法，我们不需要更改场景内渲染的物体所使用的 Shader 代码，而仅仅依靠一次屏幕后处理的步骤即可。这种方法的自由性很高，我们可以方便地模拟各种雾效，例如均匀的雾效、基于距离的线性/指数雾效等。在学习完本节后，我们可以得到类似下图中的效果。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_5.png" alt="全局雾效" title="全局雾效"></p><p>基于屏幕后处理的全局雾效的关键是，根据深度纹理来重建每个像素在世界空间下的位置。尽管我们在模拟运动模糊时已经实现了这个要求，即构建出当前像素的 NDC 坐标，再通过当前摄像机的视角 * 投影矩阵的逆矩阵来得到世界空间下的像素坐标，但是，这样的实现需要在片元着色器中进行矩阵乘法的操作，而这通常会影响游戏性能。我们将学习一个快速从深度纹理中重建世界坐标的方法。这种方法首先对图像空间下的视锥体射线（从摄像机出发，指向图像上的某点的射线）进行插值，这条射线存储了该像素在世界空间下到摄像机的方向信息。然后我们把该射线和线性化后的视角空间下的深度值相乘，再加上摄像机的世界位置，就可以得到该像素在世界空间下的位置。当我们得到世界坐标后，就可以轻松地使用各个公式来模拟全局雾效了。</p><h3 id="重建世界坐标">重建世界坐标</h3><p>在开始动手写代码之前，我们首先来了解如何从深度纹理中重建世界坐标。我们知道，坐标系中的一个顶点坐标可以通过它相对于另一个顶点坐标的偏移量来求得。重建像素的世界坐标也是基于这样的思想。我们只需要知道摄像机在世界空间下的位置，以及世界空间下该像素相对于摄像机的偏移量，把它们相加就可以得到该像素的世界坐标。整个过程可以使用下面的代码来表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float4 worldPos = _WorldSpaceCameraPos + linearDepth * interpolatedRay;<br></code></pre></td></tr></table></figure><p>其中，_WorldSpaceCameraPos 是摄像机在世界空间下的位置，这可以由 Unity 的内置变量直接访问得到。而 linearDepth * interpolatedRay 则可以计算得到该像素相对于摄像机的偏移量，linearDepth 是由深度纹理得到的线性深度值，interpolatedRay 是由顶点着色器输出并插值后得到的射线，它不仅包含了该像素到摄像机的方向，也包含了距离信息。linearDepth 的获取我们已经详细解释过了，因此我们下面着重解释 interpolatedRay 的求法。</p><p>interpolatedRay 来源于对近裁剪平面的 4 个角的某个特定向量的插值，这 4 个向量包含了它们到摄像机的方向和距离信息，我们可以利用摄像机的近裁剪平面距离、FOV、纵横比计算而得。下图显示了计算时使用的一些辅助向量。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_6.png" alt="计算 interpolatedRay" title="计算 interpolatedRay"></p><p>为了方便计算，我们可以先计算两个向量——toTop 和 toRight，它们是起点位于近裁剪平面中心、分别指向摄像机正上方和正右方的向量。它们的计算公式如下：<br>$$<br>halfHeight = Near \times \tan{\frac{FOV}{2}}<br>$$<br>$$<br>toTop = camera.up \times halfHeight<br>$$<br>$$<br>toRight = camera.right \times halfHeight \cdot aspect<br>$$<br>其中，Near 是近裁剪平面的距离，FOV 是竖直方向的视角范围，camera.up、camera.right 分别对应了摄像机的正上方和正右方。</p><p>当得到这两个辅助向量后，我们就可以计算 4 个角相对于摄像机的方向了。我们以左上角为例（见上图中的 TL 点），它的计算公式如下：</p><p>$$<br>TL = camera.forward \cdot Near + toTop - toRight<br>$$</p><p>同理，其他 3 个角的计算也是类似的：<br>$$<br>TR = camera.forward \cdot Near + toTop + toRight<br>$$<br>$$<br>BL = camera.forward \cdot Near - toTop - toRight<br>$$<br>$$<br>BR = camera.forward \cdot Near - toTop + toRight<br>$$</p><p>注意，上面求得的 4 个向量不仅包含了方向信息，它们的模对应了 4 个点打扫摄像机的空间距离。由于我们得到的线性深度值并非是点到摄像机的欧式距离，而是在 z 方向上的距离，因此，我们不能直接使用深度值和 4 个角的单位方向的乘积来计算它们到摄像机的偏移量，如下图所示。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_7.png" alt="采样得到的深度值并非是点到摄像机的欧式距离" title="采样得到的深度值并非是点到摄像机的欧式距离"></p><p>想要把深度值转换成到摄像机的欧式距离也很简单，我们以 TL 点为例，根据相似三角形原理，TL 所在的射线上，像素的深度值和它到摄像机的实际距离的比等于近裁剪平面的距离和 TL 向量的模的比，即<br>$$<br>\frac{depth}{dist} = \frac{Near}{|TL|}<br>$$<br>由此可得，我们需要的 TL 距离摄像机的欧式距离 dist：<br>$$<br>dist = \frac{|TL|}{Near} \times depth<br>$$<br>由于 4 个点相互对称，因此其他 3 个向量的模和 TL 相等，即我们可以使用同一个因子和单位向量相乘，得到它们对应的向量值：<br>$$<br>scale = \frac{|TL|}{|Near|}<br>$$<br>$$<br>Ray_{TL} = \frac{TL}{|TL|} \times scale, Ray_{TR} = \frac{TR}{|TR|} \times scale<br>$$<br>$$<br>Ray_{BL} = \frac{BL}{|BL|} \times scale, Ray_{BR} = \frac{BR}{|BR|} \times scale<br>$$</p><p>屏幕后处理的原理是使用特定的材质去渲染一个刚好填充整个屏幕的四边形面片。这个四边形面片的 4 个顶点就对应了近裁剪平面的 4 个角。因此，我们可以把上面的计算结果传递给顶点着色器，顶点着色器根据当前的位置选择它所对应的向量，然后再将其输出，经插值后传递给片元着色器得到 interpolatedRay，我们就可以直接利用一开始提到的公式重建该像素在世界空间下的位置了。</p><h3 id="雾的计算">雾的计算</h3><p>在简单的雾效实现中，我们需要计算一个雾效系数 f，作为混合原始颜色和雾的颜色的混合系数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float3 afterFog = f * fogColor + (1 - f) * origColor;<br></code></pre></td></tr></table></figure><p>这个雾效系数 f 有很多计算方法。在 Unity 内置的雾效实现中，支持三种雾的计算方式——线性（Linear）、指数（Exponential）以及指数的平方（Exponential Squared）。当给定距离 z 后，f 的计算公式分别如下：</p><p>Linear：</p><p>$f = \frac{d_{max} - |z|}{d_{max} - d_{min}}$，$d_{min}$ 和 $d_{max}$ 分别表示受雾影响的最小距离和最大距离。</p><p>Exponential：</p><p>$f = e^{-d \cdot |z|}$，$d$ 是控制雾的浓度的参数。</p><p>Exponential Squared：</p><p>$f = e^{-(d - |z|)^2}$，$d$ 是控制雾的浓度的参数。</p><p>本次我们将使用类似线性雾的计算方式，计算基于高度的雾效。具体方法是，当给定一点在世界空间下的高度 y 后，f 的计算公式为：</p><p>$f = \frac{H_{end} - y}{H_{end} - H_{start}}$，$H_{start}$ 和 $H_{end}$ 分别表示受雾影响的起始高度和终止高度。</p><h3 id="实现">实现</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FogWithDepthTexture</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader fogShader;<br><span class="hljs-keyword">private</span> Material fogMaterial = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);<br><span class="hljs-keyword">return</span> fogMaterial;<br>&#125;  <br>&#125;<br><br><span class="hljs-keyword">private</span> Camera myCamera;<br><span class="hljs-keyword">public</span> Camera camera &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">if</span> (myCamera == <span class="hljs-literal">null</span>) &#123;<br>myCamera = GetComponent&lt;Camera&gt;();<br>&#125;<br><span class="hljs-keyword">return</span> myCamera;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Transform myCameraTransform;<br><span class="hljs-keyword">public</span> Transform cameraTransform &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">if</span> (myCameraTransform == <span class="hljs-literal">null</span>) &#123;<br>myCameraTransform = camera.transform;<br>&#125;<br><br><span class="hljs-keyword">return</span> myCameraTransform;<br>&#125;<br>&#125;<br><br>[<span class="hljs-meta">Range(0.0f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fogDensity = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-keyword">public</span> Color fogColor = Color.white;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fogStart = <span class="hljs-number">0.0f</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fogEnd = <span class="hljs-number">2.0f</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span> &#123;<br>camera.depthTextureMode |= DepthTextureMode.Depth;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>Matrix4x4 frustumCorners = Matrix4x4.identity;<br><br><span class="hljs-built_in">float</span> fov = camera.fieldOfView;<br><span class="hljs-built_in">float</span> near = camera.nearClipPlane;<br><span class="hljs-built_in">float</span> aspect = camera.aspect;<br><br><span class="hljs-built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="hljs-number">0.5f</span> * Mathf.Deg2Rad);<br>Vector3 toRight = cameraTransform.right * halfHeight * aspect;<br>Vector3 toTop = cameraTransform.up * halfHeight;<br><br>Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;<br><span class="hljs-built_in">float</span> scale = topLeft.magnitude / near;<br><br>topLeft.Normalize();<br>topLeft *= scale;<br><br>Vector3 topRight = cameraTransform.forward * near + toRight + toTop;<br>topRight.Normalize();<br>topRight *= scale;<br><br>Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;<br>bottomLeft.Normalize();<br>bottomLeft *= scale;<br><br>Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;<br>bottomRight.Normalize();<br>bottomRight *= scale;<br><br>frustumCorners.SetRow(<span class="hljs-number">0</span>, bottomLeft);<br>frustumCorners.SetRow(<span class="hljs-number">1</span>, bottomRight);<br>frustumCorners.SetRow(<span class="hljs-number">2</span>, topRight);<br>frustumCorners.SetRow(<span class="hljs-number">3</span>, topLeft);<br><br>material.SetMatrix(<span class="hljs-string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);<br><br>material.SetFloat(<span class="hljs-string">&quot;_FogDensity&quot;</span>, fogDensity);<br>material.SetColor(<span class="hljs-string">&quot;_FogColor&quot;</span>, fogColor);<br>material.SetFloat(<span class="hljs-string">&quot;_FogStart&quot;</span>, fogStart);<br>material.SetFloat(<span class="hljs-string">&quot;_FogEnd&quot;</span>, fogEnd);<br><br>Graphics.Blit (src, dest, material);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>fogDensity 用于控制雾的浓度，fogColor 用于控制雾的颜色。我们使用的雾效模拟函数是基于高度的，因此参数 fogStart 用于控制雾效的起始高度，fogEnd 用于控制雾效的终止高度。</p><p>OnRenderImage 首先计算了近裁剪平面的四个角对应的向量，并把它们存储在一个矩阵类型的变量（frustumCorners）中。计算过程我们已经详细解释过了，代码只是套用了之前讲过的公式而已。我们按一定顺序把这四个方向存储到了 frustumCorners 不同的行中，这个顺序是非常重要的，因为这决定了我们在顶点着色器中使用哪一行作为该点的待插值向量。随后，我们把结果和其他参数传递给材质，并调用 Graphics.Blit(src, dest, material) 把渲染结果显示在屏幕上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter13/Chapter13-FogWithDepthTexture&quot; &#123;<br><br>    Properties &#123;<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _FogDensity (&quot;Fog Density&quot;, Float) = 1.0<br>        _FogColor (&quot;Fog Color&quot;, Color) = (1, 1, 1, 1)<br>        _FogStart (&quot;Fog Start&quot;, Float) = 0.0<br>        _FogEnd (&quot;Fog End&quot;, Float) = 1.0<br>    &#125;<br><br>    SubShader &#123;<br>        CGINCLUDE<br>        #include &quot;UnityCG.cginc&quot;<br><br>        float4x4 _FrustumCornersRay;<br><br>        sampler2D _MainTex;<br>        half4 _MainTex_TexelSize;<br>        sampler2D _CameraDepthTexture;<br>        half _FogDensity;<br>        fixed4 _FogColor;<br>        float _FogStart;<br>        float _FogEnd;<br><br>       <br><br>        struct v2f &#123;<br>            float4 pos : SV_POSITION;<br>            half2 uv : TEXCOORD0;<br>            half2 uv_depth : TEXCOORD1;<br>            float4 interpolatedRay : TEXCOORD2;<br>        &#125;;<br><br>        v2f vert(appdata_img v) &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br>            o.uv = v.texcoord;<br>            o.uv_depth = v.texcoord;<br><br>            #if UNITY_UV_STARTS_AT_TOP<br>            if(_MainTex_TexelSize.y &lt; 0)<br>                o.uv_depth.y = 1 - o.uv_depth.y;<br>            #endif<br><br>            int index = 0;<br>            if (v.texcoord.x &lt; 0.5 &amp;&amp; v.texcoord.y &lt; 0.5) &#123;<br>                index = 0;<br>            &#125; else if (v.texcoord.x &gt; 0.5 &amp;&amp; v.texcoord.y &lt; 0.5) &#123;<br>                index = 1;<br>            &#125; else if (v.texcoord.x &gt; 0.5 &amp;&amp; v.texcoord.y &gt; 0.5) &#123;<br>                index = 2;<br>            &#125; else &#123;<br>                index = 3;<br>            &#125;<br><br>            #if UNITY_UV_STARTS_AT_TOP<br>            if(_MainTex_TexelSize.y &lt; 0)<br>                index = 3 - index;<br>            #endif<br><br>            o.interpolatedRay = _FrustumCornersRay[index];<br>            return o;<br>        &#125;<br><br>        fixed4 frag(v2f i) : SV_Target &#123;<br>            float linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));<br>            float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;<br><br>            float fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart);<br>            fogDensity = saturate(fogDensity * _FogDensity);<br><br>            fixed4 finalColor = tex2D(_MainTex, i.uv);<br>            finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);<br><br>            return finalColor;<br>        &#125;<br>        ENDCG<br><br>        Pass &#123;<br>            ZTest Always Cull Off ZWrite Off<br>            CGPROGRAM<br>            #pragma vertex vert<br>            #pragma fragment frag<br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    FallBack Off<br>&#125;<br></code></pre></td></tr></table></figure><p>在 v2f 结构体中，我们除了定义顶点位置、屏幕图像和深度纹理的纹理坐标外，还定义了 interpolatedRay 变量存储插值后的像素向量。在顶点着色器中，我们对深度纹理的采样坐标进行了平台差异化除了。更重要的是，我们要决定该点对应了 4 个角中的哪个角。我们采用的方法是判断它的纹理坐标。我们知道，在 Unity 中，纹理坐标的(0, 0)点对应了左下角，而(1, 1)点对应了右上角。我们据此来判断该顶点对应的索引，这个对应关系和我们在脚本中对 frustumCorners 的赋值顺序是一致的。实际上，不同平台的纹理坐标不一定是满足上面的条件的，例如 DirectX 和 Metal 这样的平台，左上角对应了(0, 0)点，但大多数情况下 Unity 会把这些平台下的屏幕图像进行翻转，因此我们仍然可以利用这个条件。但如果在类似 DirectX 的平台上开启了抗锯齿，Unity 就不会进行这个翻转。为了此时仍然可以得到相应顶点位置的索引值，我们对索引值也进行了平台差异化处理，以便在必要时也对索引值进行翻转。最后，我们使用索引值来获取 _FrustumCornersRay 中对应的行作为该顶点的 interpolatedRay 值。</p><p>首先我们需要重建该像素在世界空间中的位置。为此，我们首先使用 SAMPLE_DEPTH_TEXTURE 对深度纹理进行采样，再使用 LinearEyeDepth 得到视角空间下的线性深度值。之后，与 interpolatedRay 相乘后再和世界空间下的摄像机位置相加，即可得到世界空间下的位置。</p><p>得到世界坐标后，模拟雾效就变得非常容易。在本例中，我们选择实现基于高度的雾效模拟，我们根据材质属性 _FogEnd 和 _FogStart 计算当前的像素高度 worldPos.y 对应的雾效系数 fogDensity，再和参数 _FogDensity 相乘后，利用 saturate 函数截取到[0, 1]范围内，作为最后的雾效系数。然后，我们使用该系数将雾的颜色和原始颜色进行混合后返回。</p><h2 id="再谈边缘检测">再谈边缘检测</h2><p>我们曾介绍如何使用 Sobel 算子对屏幕图像进行边缘检测，实现描边的效果。但是，这种直接利用颜色信息进行边缘检测的方法会产生很多我们不希望得到的边缘线，如下图所示；</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_8.png" alt="直接对颜色图像进行边缘检测的结果" title="直接对颜色图像进行边缘检测的结果"></p><p>可以看出，物体的纹理、阴影等位置也被描上黑边，而这往往不是我们希望看到的。我们将学习如何在深度和法线纹理上进行边缘检测，这些图像不会受纹理和光照的影响，而仅仅保存了当前渲染物体的模型信息，通过这样的方式检测出来的边缘更加可靠。我们将实现类似下图中的效果。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_9.png" alt="在深度和法线纹理上进行更健壮的边缘检测" title="在深度和法线纹理上进行更健壮的边缘检测"></p><p>与使用 Sobel 算子不同，我们将使用 Roberts 算子来进行边缘检测。它使用的卷积核如下图所示。</p><p><img src="/posts_image/DepthAndNormalTexture/DepthAndNormalTexture_10.png" alt="Roberts算子" title="Roberts算子"></p><p>Roberts 算子的本质就是计算左上角和右下角的差值，乘以右上角和左下角的差值，作为评估边缘的依据。在下面的实现中，我们也会按这样的方式，取对角方向的深度或法线值，比较它们之间的插值，如果超过某个阈值（可由参数控制），就认为它们之间存在一条边。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EdgeDetectNormalsAndDepth</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader edgeDetectShader;<br><span class="hljs-keyword">private</span> Material edgeDetectMaterial = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);<br><span class="hljs-keyword">return</span> edgeDetectMaterial;<br>&#125;  <br>&#125;<br><br>[<span class="hljs-meta">Range(0.0f, 1.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> edgesOnly = <span class="hljs-number">0.0f</span>;<br><br><span class="hljs-keyword">public</span> Color edgeColor = Color.black;<br><br><span class="hljs-keyword">public</span> Color backgroundColor = Color.white;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> sampleDistance = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> sensitivityDepth = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> sensitivityNormals = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span> &#123;<br>GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.DepthNormals;<br>&#125;<br><br>[<span class="hljs-meta">ImageEffectOpaque</span>]<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_EdgeOnly&quot;</span>, edgesOnly);<br>material.SetColor(<span class="hljs-string">&quot;_EdgeColor&quot;</span>, edgeColor);<br>material.SetColor(<span class="hljs-string">&quot;_BackgroundColor&quot;</span>, backgroundColor);<br>material.SetFloat(<span class="hljs-string">&quot;_SampleDistance&quot;</span>, sampleDistance);<br>material.SetVector(<span class="hljs-string">&quot;_Sensitivity&quot;</span>, <span class="hljs-keyword">new</span> Vector4(sensitivityNormals, sensitivityDepth, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>));<br><br>Graphics.Blit(src, dest, material);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>sampleDistance 用于控制对深度+法线纹理采样时，使用的采样距离。从视觉上看，sampleDistance 值越大，描边越宽。sensitivityDepth 和 sensitivityNormals 将会影响当邻域的深度值或法线值相差多少时，会被认为存在一条边界。如果把灵敏度调得很大，那么可能即使是深度或法线上很小的变化也会形成一条边。</p><p>需要注意的是，这里我们为 OnRenderImage 函数添加了[ImageEffectOpaque]属性。在默认情况下，OnRenderImage 函数会在所有的不透明和透明的 Pass 执行完毕后被调用，以便对场景中所有游戏对象都产生影响。但有时，我们希望在不透明的 Pass（即渲染队列小于等于 2500 的 Pass，内置的 Background、Geometry 和 AlphaTest 渲染队列均在此范围内）执行完毕后立即调用该函数，而不对透明物体（渲染队列为 Transparent 的 Pass）产生影响，此时，我们可以在 OnRenderImage 函数前添加 ImageEffectOpaque 属性来实现这样的目的。在本例中，我们只希望对不透明物体进行描边，而不希望透明物体也被描边，因此需要添加该属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter13/Chapter13-EdgeDetectNormalAndDepth&quot; &#123;<br><br>    Properties &#123;<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _EdgeOnly (&quot;Edge Only&quot;, Float) = 1.0<br>        _EdgeColor (&quot;Edge Color&quot;, Color) = (0, 0, 0, 1)<br>        _BackgroundColor (&quot;Background Color&quot;, Color) = (1, 1, 1, 1)<br>        _SampleDistance (&quot;Sample Distance&quot;, Float) = 1.0<br>        _Sensitivity (&quot;Sensitivity&quot;, Vector) = (1, 1, 1, 1)<br>    &#125;<br><br>    SubShader &#123;<br>        CGINCLUDE<br>        #include &quot;UnityCG.cginc&quot;<br><br>        sampler2D _MainTex;<br>        half4 _MainTex_TexelSize;<br>        fixed _EdgeOnly;<br>        fixed4 _EdgeColor;<br>        fixed4 _BackgroundColor;<br>        float _SampleDistance;<br>        half4 _Sensitivity;<br>        sampler2D _CameraDepthNormalsTexture;<br><br>        struct v2f &#123;<br>            float4 pos : SV_POSITION;<br>            half2 uv[5] : TEXCOORD0;<br>        &#125;;<br><br>        v2f vert(appdata_img v) &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br><br>            half2 uv = v.texcoord;<br>            o.uv[0] = uv;<br><br>            #if UNITY_UV_STARTS_AT_TOP<br>            if (_MainTex_TexelSize.y &lt; 0)<br>            uv.y = 1 - uv.y;<br>            #endif<br><br>            o.uv[1] = uv + _MainTex_TexelSize.xy * half2(1, 1) * _SampleDistance;<br>            o.uv[2] = uv + _MainTex_TexelSize.xy * half2(-1, -1) * _SampleDistance;<br>            o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 1) * _SampleDistance;<br>            o.uv[4] = uv + _MainTex_TexelSize.xy * half2(1, -1) * _SampleDistance;<br>            return o;<br>        &#125;<br><br><br>        half CheckSame(half4 center, half4 sample) &#123;<br>            half2 centerNormal = center.xy;<br>            float centerDepth = DecodeFloatRG(center.zw);<br>            half2 sampleNormal = sample.xy;<br>            float sampleDepth = DecodeFloatRG(sample.zw);<br><br>            //difference in normals<br>            //do not bother decoding normal - there&#x27;s no need here<br>            half2 diffNormal = abs(centerNormal - sampleNormal) * _Sensitivity.x;<br>            int isSameNormal = (diffNormal.x + diffNormal.y) &lt; 0.1;<br>            //difference in depth<br>            float diffDepth  = abs(centerDepth - sampleDepth) * _Sensitivity.y;<br>            //scale the required threshold by the distance<br>            int isSameDepth = diffDepth &lt; 0.1 * centerDepth;<br><br>            //return:<br>            //1 - if normals and depth are similar enough<br>            //0 - otherwise<br>            return isSameNormal * isSameDepth ? 1.0 : 0.0;<br>        &#125;<br><br>        fixed4 fragRobertsCrossDepthAndNormal(v2f i) : SV_Target &#123;<br>            half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[1]);<br>            half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[2]);<br>            half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[3]);<br>            half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[4]);<br><br>            half edge = 1.0;<br>            edge *= CheckSame(sample1, sample2);<br>            edge *= CheckSame(sample3, sample4);<br><br>            fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[0]), edge);<br>            fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);<br><br>            return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly); <br>        &#125;<br>        ENDCG<br><br>        Pass &#123;<br>            ZTest Always Cull Off ZWrite Off<br>            CGPROGRAM<br>            #pragma vertex vert<br>            #pragma fragment fragRobertsCrossDepthAndNormal<br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    FallBack Off<br>&#125;<br></code></pre></td></tr></table></figure><p>_Sensitivity 的 xy 分量分别对应了法线和深度的检测灵敏度，zw分量则没有实际用途。我们在 v2f 结构体中定义了一个维数为 5 的纹理坐标数组。这个数组的第一个坐标存储了屏幕颜色图像的采样纹理。我们对深度纹理的采样坐标进行了平台差异化处理，在必要情况下对它的竖直方向进行了翻转。数组中剩余的 4 个坐标则存储了使用 Roberts 算子时需要采样的纹理坐标，我们还使用了 _SampleDistance 来控制采样距离。通过把计算采样纹理坐标的代码从片元着色器中转移到顶点着色器中，可以减少运算，提高性能。由于从顶点着色器到片元着色器的插值是线性的，因此这样的转移并不会影响纹理坐标的计算结果。</p><p>在片元着色器中我们首先使用 4 个纹理坐标对深度+法线纹理进行采样，再调用 CheckSame 函数来分别计算对角线上两个纹理值的插值。CheckSame 函数的返回值要么是 0，要么是 1，返回 0 时表明这两点之间存在一条边界，反之则返回 1。</p><p>CheckSame 首先对输入参数进行处理，得到两个采样点的法线和深度值。值得注意的是，这里我们并没有解码得到真正的法线值，而是直接使用了 xy 分量。这是因为我们只需要比较两个采样值之间的差异度，而并不需要知道它们真正的法线值。然后，我们把两个采样点的对应值相减并取绝对值，再乘以灵敏度参数，把差异值的每个分量相加再和一个阈值比较，如果它们的和小于阈值，则返回 1，说明差异不明显，不存在一条边界；否则返回 0。最后，我们把法线和深度的检查结果相乘，作为组合后的返回值。当通过 CheckSame 函数得到边缘信息后，片元着色器就利用该值进行颜色混合。</p><p>本次实现的描边效果是基于整个屏幕空间进行的，也就是说，场景内的所有物体都会被添加描边效果。但有时，我们希望只对特定的物体进行描边，例如当玩家选中场景中的某个物体后，我们想要在该物体周围添加一层描边效果。这时，我们可以使用 Unity 提供的 Graphics.DrawMesh 或 Graphics.DrawMeshNow 函数把需要描边的物体再次渲染一遍（在所有不透明物体渲染完毕之后），然后再使用本节提到的边缘检测算法计算深度或法线纹理中每个像素的梯度值，判断它们是否小于某个阈值，如果是，就在 Shader 中使用 clip() 函数将该像素剔除掉，从而显示出原来的物体颜色。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;获取深度和法线纹理&quot;&gt;获取深度和法线纹理&lt;/h2&gt;
&lt;h3 id=&quot;背后的原理&quot;&gt;背后的原理&lt;/h3&gt;
&lt;p&gt;深度纹理实际上就是一张渲染纹理，只不过它里面存储的像素值不是颜色值，而是一个高精度的深度值。由于被存储在一张纹理中，深度纹理里的深度值范围是[0, 1]，</summary>
      
    
    
    
    <category term="Unity Shader" scheme="http://example.com/categories/Unity-Shader/"/>
    
    
    <category term="Texture" scheme="http://example.com/tags/Texture/"/>
    
  </entry>
  
  <entry>
    <title>屏幕后处理</title>
    <link href="http://example.com/posts/%E5%B1%8F%E5%B9%95%E5%90%8E%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/posts/%E5%B1%8F%E5%B9%95%E5%90%8E%E5%A4%84%E7%90%86/</id>
    <published>2022-03-04T02:19:05.000Z</published>
    <updated>2025-04-17T12:55:15.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建立一个基本的屏幕后处理脚本系统">建立一个基本的屏幕后处理脚本系统</h2><p>屏幕后处理，通常指的是在渲染完整个场景得到屏幕图像后，再对这个图像进行一系列操作，实现各种屏幕特效。使用这种技术，可以为游戏画面添加更多的艺术效果，例如景深（Depth of Field）、运动模糊（Motion Blur）等。</p><p>因此，想要实现屏幕后处理的基础在于得到渲染后的屏幕图像，即抓取屏幕，而 Unity 为我们提供了这样一个方便的接口——<strong>OnRenderImage 函数</strong>。它的函数声明如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)<br></code></pre></td></tr></table></figure><p>当我们在脚本中声明此函数后，Unity 会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中，通过函数中的一系列操作后，再把目标渲染纹理，即第二个参数对应的渲染纹理显示到屏幕上。在 OnRenderImage 函数中，我们通常是利用 <strong>Graphics.Blit 函数</strong>来完成对渲染纹理的处理。它有 3 种函数声明：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Blit</span>(<span class="hljs-params">Texture src, RenderTexture dest</span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Blit</span>(<span class="hljs-params">Texture src, RenderTexture dest, Material mat, <span class="hljs-built_in">int</span> pass = <span class="hljs-number">-1</span></span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Blit</span>(<span class="hljs-params">Texture src, Material mat, <span class="hljs-built_in">int</span> pass = <span class="hljs-number">-1</span></span>)</span>;<br></code></pre></td></tr></table></figure><p>其中，参数 src 对应了源纹理，在屏幕后处理技术中，这个参数通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理。参数 dest 是目标渲染纹理，如果它的值为 null 就会直接将结果显示在屏幕上。参数 mat 是我们使用的材质，这个材质使用的 Unity Shader 将会进行各种屏幕后处理操作，而 src 纹理将会被传递给 Shader 中名为 _MainTex 的纹理属性。参数 pass 的默认值为 -1，表示将会依次调用 Shader 内的所有 Pass。否则，只会调用给定索引的 Pass。</p><p>在默认情况下，OnRenderImage 函数会在所有的不透明和透明的 Pass 执行完毕后被调用，以便对场景中所有游戏对象都产生影响。但有时，我们希望在不透明的 Pass（即渲染队列小于等于 2500 的 Pass，内置的 Background、Geometry 和 AlphaTest 渲染队列均在此范围内）执行完毕后立即调动 OnRenderImage 函数，从而不对透明物体产生任何影响。此时，我们可以在 OnRenderImage 函数前添加 ImageEffectOpaque 属性来实现这样的目的。</p><p>要在 Unity 中实现屏幕后处理效果，过程通常如下：我们首先需要在摄像机中添加一个用于屏幕后处理的脚本。在这个脚本中，我们会实现 OnRenderImage 函数来获取当前屏幕的渲染纹理。然后，再调用 Graphics.Blit 函数使用特定的 Unity Shader 来对当前图像进行处理，再把返回的渲染纹理显示到屏幕上。对于一些复杂的屏幕特效，我们可能需要多次调用 Graphics.Blit 函数来对上一步的输出结果进行下一步处理。</p><p>但是，在进行屏幕后处理之前，我们需要检查一系列条件是否满足，例如当前平台是否支持渲染纹理和屏幕特效，是否支持当前使用的 Unity Shader 等。为此，我们创建了一个用于屏幕后处理效果的基类，在实现各种屏幕特效时，我们只需要继承自该基类，再实现派生类中不同的操作即可。PostEffectsBase.cs 的主要代码如下。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br>[<span class="hljs-meta">ExecuteInEditMode</span>]<br>[<span class="hljs-meta">RequireComponent (typeof(Camera))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PostEffectsBase</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br><span class="hljs-comment">// Called when start</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CheckResources</span>()</span> &#123;<br><span class="hljs-built_in">bool</span> isSupported = CheckSupport();<br><br><span class="hljs-keyword">if</span> (isSupported == <span class="hljs-literal">false</span>) &#123;<br>NotSupported();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Called in CheckResources to check support on this platform</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CheckSupport</span>()</span> &#123;<br><span class="hljs-keyword">if</span> (SystemInfo.supportsImageEffects == <span class="hljs-literal">false</span> || SystemInfo.supportsRenderTextures == <span class="hljs-literal">false</span>) &#123;<br>Debug.LogWarning(<span class="hljs-string">&quot;This platform does not support image effects or render textures.&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// Called when the platform doesn&#x27;t support this effect</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NotSupported</span>()</span> &#123;<br>enabled = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>CheckResources();<br>&#125;<br><br><span class="hljs-comment">// Called when need to create the material used by this effect</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Material <span class="hljs-title">CheckShaderAndCreateMaterial</span>(<span class="hljs-params">Shader shader, Material material</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (shader == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)<br><span class="hljs-keyword">return</span> material;<br><br><span class="hljs-keyword">if</span> (!shader.isSupported) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>material = <span class="hljs-keyword">new</span> Material(shader);<br>material.hideFlags = HideFlags.DontSave;<br><span class="hljs-keyword">if</span> (material)<br><span class="hljs-keyword">return</span> material;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>CheckShaderAndCreateMaterial 函数接受两个参数，第一个参数指定了该特效需要使用的 Shader，第二个参数则是用于后期处理的材质。该函数首先检查 Shader 的可用性，检查通过后就返回一个使用了该 Shader 的材质，否则返回 null。</p><h2 id="调整屏幕的亮度、饱和度和对比度">调整屏幕的亮度、饱和度和对比度</h2><p>首先编写 BrightnessSaturationAndContrast.cs 脚本。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BrightnessSaturationAndContrast</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader briSatConShader;<br><span class="hljs-keyword">private</span> Material briSatConMaterial;<br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);<br><span class="hljs-keyword">return</span> briSatConMaterial;<br>&#125;  <br>&#125;<br><br>[<span class="hljs-meta">Range(0.0f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> brightness = <span class="hljs-number">1.0f</span>;<br><br>[<span class="hljs-meta">Range(0.0f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> saturation = <span class="hljs-number">1.0f</span>;<br><br>[<span class="hljs-meta">Range(0.0f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> contrast = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span>(<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_Brightness&quot;</span>, brightness);<br>material.SetFloat(<span class="hljs-string">&quot;_Saturation&quot;</span>, saturation);<br>material.SetFloat(<span class="hljs-string">&quot;_Contrast&quot;</span>, contrast);<br><br>Graphics.Blit(src, dest, material);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每当 OnRenderImage 函数被调用时，它会检查材质是否可用。如果可用，就把参数传递给材质，再调用 Graphics.Blit 进行处理；否则，直接把原图像显示到屏幕上，不做任何处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter12/Chapter12-BrightnessSaturationAndContrast&quot;<br>&#123;<br>    <br>    Properties &#123;<br>_MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>// _Brightness (&quot;Brightness&quot;, Float) = 1<br>// _Saturation(&quot;Saturation&quot;, Float) = 1<br>// _Contrast(&quot;Contrast&quot;, Float) = 1<br>&#125;<br>SubShader &#123;<br>Pass &#123;  <br>ZTest Always Cull Off ZWrite Off<br><br>CGPROGRAM  <br>#pragma vertex vert  <br>#pragma fragment frag  <br>  <br>#include &quot;UnityCG.cginc&quot;  <br>  <br>sampler2D _MainTex;  <br>half _Brightness;<br>half _Saturation;<br>half _Contrast;<br>  <br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>half2 uv: TEXCOORD0;<br>&#125;;<br>  <br>v2f vert(appdata_img v) &#123;<br>v2f o;<br><br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.uv = v.texcoord;<br> <br>return o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>fixed4 renderTex = tex2D(_MainTex, i.uv);  <br>  <br>// Apply brightness<br>fixed3 finalColor = renderTex.rgb * _Brightness;<br><br>// Apply saturation<br>fixed luminance = 0.2125 * renderTex.r + 0.7154 * renderTex.g + 0.0721 * renderTex.b;<br>fixed3 luminanceColor = fixed3(luminance, luminance, luminance);<br>finalColor = lerp(luminanceColor, finalColor, _Saturation);<br><br>// Apply contrast<br>fixed3 avgColor = fixed3(0.5, 0.5, 0.5);<br>finalColor = lerp(avgColor, finalColor, _Contrast);<br><br>return fixed4(finalColor, renderTex.a);  <br>&#125;  <br>  <br>ENDCG<br>&#125;  <br>&#125;<br><br>Fallback Off<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们提到 Graphics.Blit(src, dest, material) 将把第一个参数传递给 Shader 中名为 _MainTex 的属性，因此我们必须声明一个名为 _MainTex 的纹理属性。除此之外，我们还声明了用于调整亮度、饱和度和对比度的属性。这些值将会由脚本传递而得。事实上，我们可以省略 Properties 中的属性声明，Properties 中声明的属性仅仅是为了显示在材质面板中，但对于屏幕特效来说，它们使用的材质都是临时创建的，我们也不需要在材质面板上调整参数，而是直接从脚本传递给 Unity Shader。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">ZTest Always Cull Off ZWrite Off<br></code></pre></td></tr></table></figure><p>屏幕后处理实际上是在场景中绘制了一个与屏幕同宽同高的四边形面片，为了防止它对其他物体产生影响，我们需要设置相关的渲染状态，在这里我们关闭了深度写入，是为了防止它“挡住”在其后面被渲染的物体。例如，如果当前的 OnRenderImage 函数在所有不透明的 Pass 执行完毕后立即被调用，不关闭深度写入就会影响后面透明的 Pass 的渲染。这些状态设置可以认为是用于屏幕后处理的 Shader 的“标配”。</p><p>首先，我们得到对原屏幕图像（存储在 _MainTex 中)的采样结果 renderTex。然后利用 _Brightness 属性来调整亮度。亮度的调整非常简单，我们只需要把原颜色乘以亮度系数 _Brightness 即可。然后，我们计算该像素对应的亮度值（luminance），这是通过对每个颜色乘以一个特定的系数再相加得到的。我们使用该亮度值创建了一个饱和度为 0 的颜色值，并使用 _Saturation 属性在其和上一步得到的颜色之间进行插值，从而得到希望的饱和度颜色。对比度的处理类似，我们首先创建一个对比度为 0 的颜色值（各分量均为 0.5），再使用 _Contrast 属性在其和上一步得到的颜色之间进行插值，从而得到最终的处理结果。</p><p><img src="/posts_image/Post_Processing/Post_Processing_1.png" alt="调整屏幕的亮度、饱和度和对比度" title="调整屏幕的亮度、饱和度和对比度"></p><h2 id="边缘检测">边缘检测</h2><p>边缘检测的原理是利用一些边缘检测算子对图像进行**卷积（convolution）**操作，我们首先来了解什么是卷积。</p><h3 id="什么是卷积">什么是卷积</h3><p>在图像处理中，卷积操作指的就是使用一个**卷积核（kernel）**对一张图像中的每个像素进行一系列操作。卷积核通常是一个四方形网格结构（例如 2 $\times$ 2、3 $\times$ 3 的方形区域），该区域内每个方格都有一个权重值。当对图像中的某个像素进行卷积时，我们会把卷积核的中心放置于该像素上，如下图所示，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到的结果就是该位置的新像素值。</p><p><img src="/posts_image/Post_Processing/Post_Processing_2.png" alt="卷积核与卷积" title="卷积核与卷积"></p><p>这样的计算过程虽然简单，但可以实现很多常见的图像处理效果，例如图像模糊、边缘检测等。例如，如果我们想要对图像进行均值模糊，可以使用一个 3 $\times$ 3 的卷积核，核内每个元素的值均为 1/9。</p><h3 id="常见的边缘检测算子">常见的边缘检测算子</h3><p>卷积操作的神奇之处在于选择的卷积核。那么，用于边缘检测的卷积核（也被称为边缘检测算子）应该是什么样子的？在回答这个问题之前，我们可以首先回想一下边到底是如何形成的。如果相邻像素之间存在差别明显的颜色、亮度、纹理等属性，我们就会认为它们之间应该有一条边界。这种相邻像素之间的差值可以用**梯度（gradient）**来表示，可以想像得到，边缘处的梯度绝对值会比较大。基于这样的理解，有几种不同的边缘检测算子被先后提出来。</p><p><img src="/posts_image/Post_Processing/Post_Processing_3.png" alt="3 种常见的边缘检测算子" title="3 种常见的边缘检测算子"></p><p>3 种常见的边缘检测算子如上图所示，它们都包含了两个方向的卷积核，分别用于检测水平方向和竖直方向上的边缘信息。在进行边缘检测时，我们需要对每个像素分别进行一次卷积计算，得到两个方向上的梯度值 $G_x$ 和 $G_y$，而整体的梯度可按下面的公式计算而得：</p><p>$$<br>G = \sqrt{G_x^2 + G_y^2}<br>$$</p><p>由于上述计算包含了开根号操作，出于性能的考虑，我们有时会使用绝对值操作来代替开根号操作：</p><p>$$<br>G = |G_x| + |G_y|<br>$$</p><p>当得到梯度 $G$ 后，我们就可以据此来判断哪些像素对应了边缘（梯度值越大，越有可能是边缘点）。</p><h3 id="实现">实现</h3><p>我们首先来编写 EdgeDetection 脚本。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EdgeDetection</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader edgeDetectShader;<br><span class="hljs-keyword">private</span> Material edgeDetectMaterial = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);<br><span class="hljs-keyword">return</span> edgeDetectMaterial;<br>&#125;  <br>&#125;<br><br>[<span class="hljs-meta">Range(0.0f, 1.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> edgesOnly = <span class="hljs-number">0.0f</span>;<br><br><span class="hljs-keyword">public</span> Color edgeColor = Color.black;<br><br><span class="hljs-keyword">public</span> Color backgroundColor = Color.white;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_EdgeOnly&quot;</span>, edgesOnly);<br>material.SetColor(<span class="hljs-string">&quot;_EdgeColor&quot;</span>, edgeColor);<br>material.SetColor(<span class="hljs-string">&quot;_BackgroundColor&quot;</span>, backgroundColor);<br><br>Graphics.Blit(src, dest, material);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当 edgesOnly 值为 0 时，边缘将会叠加在原渲染图像上；当 edgesOnly 值为 1 时，则会只显示边缘，不显示原渲染图像。其中，背景颜色由 backgroundColor 指定，边缘颜色由 edgeColor 指定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter12/Chapter12-EdgeDetection&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _EdgeOnly (&quot;Edge Only&quot;, Float) = 1.0<br>        _EdgeColor (&quot;Edge Color&quot;, Color) = (0, 0, 0, 1)<br>        _BackgroundColor (&quot;Background Color&quot;, Color) = (1, 1, 1, 1)<br>    &#125;<br>    SubShader<br>    &#123;<br>        Pass &#123;<br>            ZTest Always Cull Off ZWrite Off<br><br>            CGPROGRAM<br>            #pragma vertex vert<br>            #pragma fragment fragSobel<br>            #include &quot;UnityCG.cginc&quot;<br><br>            sampler2D _MainTex;<br>            half4 _MainTex_TexelSize;<br>            fixed _EdgeOnly;<br>            fixed4 _EdgeColor;<br>            fixed4 _BackgroundColor;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                half2 uv[9] : TEXCOORD0; <br>            &#125;;<br><br>            fixed luminance(fixed4 color) &#123;<br>                return 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b;<br>            &#125;<br><br>            half Sobel(v2f i) &#123;<br>                const half Gx[9] = &#123;-1, -2, -1 ,0, 0, 0, 1, 2, 1&#125;;<br>                const half Gy[9] = &#123;-1, 0, 1, -2, 0, 2, -1, 0, 1&#125;;<br>                half texColor;<br>                half edgeX = 0;<br>                half edgeY = 0;<br>                for(int it = 0; it &lt; 9; it++)&#123;<br>                    texColor = luminance(tex2D(_MainTex, i.uv[it]));<br>                    edgeX += texColor * Gx[it];<br>                    edgeY += texColor * Gy[it];<br>                &#125;<br>                half edge = 1 - abs(edgeX) - abs(edgeY);<br>                return edge;<br>            &#125;<br><br>            v2f vert(appdata_img v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                half2 uv = v.texcoord;<br><br>                o.uv[0] = uv + _MainTex_TexelSize.xy * half2(-1, -1);<br>                o.uv[1] = uv + _MainTex_TexelSize.xy * half2(0, -1);<br>                o.uv[2] = uv + _MainTex_TexelSize.xy * half2(1, -1);<br>                o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 0);<br>                o.uv[4] = uv + _MainTex_TexelSize.xy * half2(0, 0);<br>                o.uv[5] = uv + _MainTex_TexelSize.xy * half2(1, 0);<br>                o.uv[6] = uv + _MainTex_TexelSize.xy * half2(-1, 1);<br>                o.uv[7] = uv + _MainTex_TexelSize.xy * half2(0, 1);<br>                o.uv[8] = uv + _MainTex_TexelSize.xy * half2(1, 1);<br><br>                return o;<br>            &#125;<br><br>            fixed4 fragSobel(v2f i) : SV_TARGET &#123;<br>                half edge = Sobel(i);<br>                fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4]), edge);<br>                fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);<br>                return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);<br>            &#125;<br>            <br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack Off<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们声明了一个变量 _MainTex_TexelSize，xxx_TexelSize 是 Unity 为我们提供的访问 xxx 纹理对应的每个纹素的大小。由于卷积需要对相邻区域内的纹理进行采样，因此我们需要利用 _MainTex_TexelSize 来计算各个相邻区域的纹理坐标。</p><p>我们在 v2f 结构体中定义了一个维数为 9 的纹理数组，对应了使用 Sobel 算子采样时需要的 9 个邻域纹理坐标。通过把计算采样纹理坐标的代码从片元着色器中转移到顶点着色器中，可以减少运算，提高性能。由于从顶点着色器到片元着色器到插值是线性的，因此这样的转移并不会影响纹理坐标的计算结果。</p><p>我们调用 Sobel 函数计算当前像素的梯度值 edge，并利用该值分别计算了背景为原图和纯色下的颜色值，然后利用 _EdgeOnly 在两者之间插值得到最终的像素值。Sobel 函数利用 Sobel 算子对原图进行边缘检测。在 Sobel 函数中，我们定义了水平方向和竖直方向使用的卷积核 $G_x$ 和 $G_y$。接着，我们依次对 9 个像素进行采样，计算它们的亮度值，再与卷积核 $G_x$ 和 $G_y$ 中对应的权重相乘后，叠加到各自的梯度值上。最后，我们从 1 中减去水平方向和竖直方向的梯度值的绝对值，得到 edge。edge 值越小，表明该位置越可能是一个边缘点。至此，边缘检测过程结束。</p><p>需要注意的是，本次实现的边缘检测仅仅利用了屏幕的颜色信息，而在实际应用中，物体的纹理、阴影等信息均会影响边缘检测的结果，使得结果包含许多非预期的描边。为了得到更加准确的边缘信息，我们往往会在屏幕的深度纹理和法线纹理上进行边缘检测。</p><p><img src="/posts_image/Post_Processing/Post_Processing_4.png" alt="边缘检测结果" title="边缘检测结果"></p><p><img src="/posts_image/Post_Processing/Post_Processing_5.png" alt="只显示边缘的效果" title="只显示边缘的效果"></p><h2 id="高斯模糊">高斯模糊</h2><p>模糊的实现有很多方法，例如均值模糊和中值模糊。均值模糊同样使用了卷积操作，它使用的卷积核中的各个元素值都相等，且相加等于 1，也就是说，卷积后得到的像素值是其邻域内各个像素值的平均值。而中值模糊则是选择邻域内对所有像素排序后的中值替换掉原颜色。一个更高级的模糊方法是高斯模糊。</p><h3 id="高斯滤波">高斯滤波</h3><p>高斯模糊同样利用了卷积计算，它使用的卷积核名为高斯核。高斯核是一个正方形大小的滤波核，其中每个元素的计算都是基于下面的高斯方程：<br>$$<br>G(x, y) = \frac{1}{2\pi\sigma^2}e^{-\frac{x^2 + y^2}{2\sigma^2}}<br>$$</p><p>其中，$\sigma$ 是标准方差（一般取值为 1），$x$ 和 $y$ 分别对应了当前位置到卷积核中心的整数距离。要构建一个高斯核，我们只需要计算高斯核中各个位置对应的高斯值。为了保证滤波后的图像不会变暗，我们需要对高斯核中的权重进行归一化，即让每个权重除以所有权重的和，这样可以保证所有权重的和为 1。因此，高斯函数中 $e$ 前面的系数实际不会对结果有任何影响。下图显示了一个标准方差为 1 的 5 $\times$ 5 大小的高斯核。</p><p><img src="/posts_image/Post_Processing/Post_Processing_6.png" alt="标准方差为 1 的高斯核" title="标准方差为 1 的高斯核"></p><p>高斯方程很好地模拟了邻域每个像素对当前处理像素的影响程度——距离越近，影响越大。高斯核的维数越高，模糊程度越大。使用一个 N $\times$ N 的高斯核对图像进行卷积滤波，就需要 N $\times$ N $\times$ W $\times$ H（W 和 H 分别是图像的宽和高）次纹理采样。当 N 的大小不断增加时，采样次数会变得非常巨大。幸运的是，我们可以把这个二维高斯函数拆分为两个一维函数。也就是说，我们可以使用两个一维的高斯核先后对图像进行滤波，它们得到的结果和直接使用二维高斯核是一样的，但采样次数只需要 2 $\times$ N $\times$ W $\times$ H。我们可以进一步观察到，两个一维高斯核中包含了很多重复的权重。对于一个大小为 5 的一维高斯核，我们实际只需要记录 3 个权重值即可。</p><p>我们将使用上述 5 $\times$ 5 的高斯核对原图像进行高斯模糊。我们将先后调用两个 Pass，第一个 Pass 将会使用竖直方向的一维高斯核对图像进行滤波，第二个 Pass 再使用水平方向的一维高斯核对图像进行滤波，得到最终的目标图像。在实现中，我们还将利用图像缩放来进一步提高性能，并通过调整高斯滤波的应用次数来控制模糊程度（次数越多，图像越模糊）。</p><h3 id="实现-2">实现</h3><p>我们首先来编写 GaussianBlur.cs 脚本。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GaussianBlur</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader gaussianBlurShader;<br><span class="hljs-keyword">private</span> Material gaussianBlurMaterial = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial);<br><span class="hljs-keyword">return</span> gaussianBlurMaterial;<br>&#125;  <br>&#125;<br><br><span class="hljs-comment">// Blur iterations - larger number means more blur.</span><br>[<span class="hljs-meta">Range(0, 4)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> iterations = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// Blur spread for each iteration - larger value means more blur</span><br>[<span class="hljs-meta">Range(0.2f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> blurSpread = <span class="hljs-number">0.6f</span>;<br><br>[<span class="hljs-meta">Range(1, 8)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> downSample = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 1st edition: just apply blur</span><br><span class="hljs-comment">//void OnRenderImage(RenderTexture src, RenderTexture dest) &#123;</span><br><span class="hljs-comment">//if (material != null) &#123;</span><br><span class="hljs-comment">//int rtW = src.width;</span><br><span class="hljs-comment">//int rtH = src.height;</span><br><span class="hljs-comment">//RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//// Render the vertical pass</span><br><span class="hljs-comment">//Graphics.Blit(src, buffer, material, 0);</span><br><span class="hljs-comment">//// Render the horizontal pass</span><br><span class="hljs-comment">//Graphics.Blit(buffer, dest, material, 1);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//RenderTexture.ReleaseTemporary(buffer);</span><br><span class="hljs-comment">//&#125; else &#123;</span><br><span class="hljs-comment">//Graphics.Blit(src, dest);</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//&#125; </span><br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 2nd edition: scale the render texture</span><br><span class="hljs-comment">//void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;</span><br><span class="hljs-comment">//if (material != null) &#123;</span><br><span class="hljs-comment">//int rtW = src.width/downSample;</span><br><span class="hljs-comment">//int rtH = src.height/downSample;</span><br><span class="hljs-comment">//RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="hljs-comment">//buffer.filterMode = FilterMode.Bilinear;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//// Render the vertical pass</span><br><span class="hljs-comment">//Graphics.Blit(src, buffer, material, 0);</span><br><span class="hljs-comment">//// Render the horizontal pass</span><br><span class="hljs-comment">//Graphics.Blit(buffer, dest, material, 1);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//RenderTexture.ReleaseTemporary(buffer);</span><br><span class="hljs-comment">//&#125; else &#123;</span><br><span class="hljs-comment">//Graphics.Blit(src, dest);</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 3rd edition: use iterations for larger blur</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">int</span> rtW = src.width/downSample;<br><span class="hljs-built_in">int</span> rtH = src.height/downSample;<br><br>RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br>buffer0.filterMode = FilterMode.Bilinear;<br><br>Graphics.Blit(src, buffer0);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; iterations; i++) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_BlurSize&quot;</span>, <span class="hljs-number">1.0f</span> + i * blurSpread);<br><br>RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// Render the vertical pass</span><br>Graphics.Blit(buffer0, buffer1, material, <span class="hljs-number">0</span>);<br><br>RenderTexture.ReleaseTemporary(buffer0);<br>buffer0 = buffer1;<br>buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// Render the horizontal pass</span><br>Graphics.Blit(buffer0, buffer1, material, <span class="hljs-number">1</span>);<br><br>RenderTexture.ReleaseTemporary(buffer0);<br>buffer0 = buffer1;<br>&#125;<br><br>Graphics.Blit(buffer0, dest);<br>RenderTexture.ReleaseTemporary(buffer0);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>blurSpread 和 downSample 都是出于性能的考虑。在高斯核维数不变的情况下，_BlurSize 越大，模糊程度越高，但采样数却不会收到影响，但过大的 _BlurSize 值会造成虚影。而 downSample 越大，需要处理的像素数越少，同时也能进一步提高模糊程度，但过大的 downSample 可能会使图像像素化。</p><p>第一版中，我们利用 RenderTexture.GetTemporary 函数分配了一块与屏幕图像大小相同的缓冲区。这是因为，高斯模糊需要调用两个 Pass，我们需要使用一块中间缓存来存储第一个 Pass 执行完毕后得到的模糊结果。如代码所示，我们首先调用 Graphics.Blit(src, buffer, material, 0)，使用 Shader 中的第一个 Pass（即使用竖直方向的一维高斯核进行滤波）对 src 进行处理，并将结果存储在了 buffer 中。然后，再调用 Graphics.Blit(buffer, dest, material, 1)，使用 Shader 中的第二个 Pass（即使用水平方向的一维高斯核进行滤波）对 buffer 进行处理，返回最终的屏幕图像。最后，我们还需要调用 RenderTexture.ReleaseTemporary 来释放之前分配的缓存。</p><p>第二版中，我们在声明缓冲区的大小时，使用了小于原屏幕分辨率的尺寸，并将该临时渲染纹理的滤波模式设置为双线性。这样，在调用第一个 Pass 时，我们需要处理的像素个数就是原来的几分之一。对图像进行降采样不仅可以减少需要处理的像素的个数，提高性能，而且适当的降采样往往还可以得到更好的模糊效果。尽管 downSample 值越大，性能越好，但过大的 downSample 可能会造成图像像素化。</p><p>最后一个版本中，我们考虑了高斯模糊的迭代次数。上面的代码显示了如何利用两个临时缓存在迭代之间进行交替的过程。在迭代开始前，我们首先定义了第一个缓存 buffer0，并把 src 中的图像缩放后存储到 buffer0 中。在迭代过程中，我们又定义了第二个缓存 buffer1。在执行第一个 Pass 时，输入是 buffer0，输出是 buffer1，完毕后首先把 buffer0 释放，再把结果值 buffer1 存储到 buffer0 中，重新分配 buffer1，然后再调用第二个 Pass，重复上述过程。迭代完成后，buffer0 将存储最终的图像，我们再利用 Graphics.Blit(buffer0, dest) 把上述结果显示到屏幕上，并释放缓存。</p><p>下面，我们来实现 Shader 部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter12/Chapter12-GaussianBlur&quot; &#123;<br><br>    Properties &#123;<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _BlurSize (&quot;Blur Size&quot;, Float) = 1.0<br>    &#125;<br><br>    SubShader &#123;<br>        CGINCLUDE<br>        #include &quot;UnityCG.cginc&quot;<br><br>        sampler2D _MainTex;<br>        half4 _MainTex_TexelSize;<br>        float _BlurSize;<br><br>        struct v2f &#123;<br>            float4 pos : SV_POSITION;<br>            half2 uv[5] : TEXCOORD0;<br>        &#125;;<br><br>        v2f vertBlurVertical(appdata_img v) &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br>            half2 uv = v.texcoord;<br><br>            o.uv[0] = uv;<br>            o.uv[1] = uv + float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize;<br>            o.uv[2] = uv - float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize;<br>            o.uv[3] = uv + float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize;<br>            o.uv[4] = uv - float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize;<br>            return o;<br>        &#125;<br><br>        v2f vertBlurHorizontal(appdata_img v) &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br>            half2 uv = v.texcoord;<br><br>            o.uv[0] = uv;<br>            o.uv[1] = uv + float2(0.0, _MainTex_TexelSize.x * 1.0) * _BlurSize;<br>            o.uv[2] = uv - float2(0.0, _MainTex_TexelSize.x * 1.0) * _BlurSize;<br>            o.uv[3] = uv + float2(0.0, _MainTex_TexelSize.x * 2.0) * _BlurSize;<br>            o.uv[4] = uv - float2(0.0, _MainTex_TexelSize.x * 2.0) * _BlurSize;<br>            return o;<br>        &#125;<br><br>        fixed4 fragBlur(v2f i) : SV_Target &#123;<br>            float weight[3] = &#123;0.4026, 0.2442, 0.0545&#125;;<br>            fixed3 sum = tex2D(_MainTex, i.uv[0]).rgb * weight[0];<br><br>            for(int it = 1; it &lt; 3; it++) &#123;<br>                sum += tex2D(_MainTex, i.uv[it]).rgb * weight[it];<br>                sum += tex2D(_MainTex, i.uv[2 * it]).rgb * weight[it];<br>            &#125;<br>            return fixed4(sum, 1.0);<br>        &#125;<br><br><br>        ENDCG<br><br>        ZTest Always Cull Off ZWrite Off<br><br>        Pass &#123;<br>            Name &quot;GAUSSIAN_BLUR_VERTICAL&quot;<br><br>            CGPROGRAM<br><br>            #pragma vertex vertBlurVertical<br>            #pragma fragment fragBlur<br><br>            ENDCG<br>        &#125;<br><br>        Pass &#123;<br>            Name &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;<br><br>            CGPROGRAM<br><br>            #pragma vertex vertBlurHorizontal<br>            #pragma fragment fragBlur<br><br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    FallBack Off<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在 SubShader 块中用 CGINCLUDE 和 ENDCG 语义来定义一系列代码，这些代码不需要包含在任何 Pass 语义块中，在使用时，我们只需要在 Pass 中直接指定需要使用的顶点着色器和片元着色器函数名即可。CGINCLUDE 类似于 C++ 中头文件的功能。由于高斯模糊需要定义两个 Pass，但它们使用的片元着色器代码是完全相同的，使用 CGINCLUDE 可以避免我们编写两个完全一样的 frag 函数。</p><p>我们利用了 5 $\times$ 5 大小的高斯核对原图像进行高斯模糊，而一个 5 $\times$ 5 的二维高斯核可以拆分成两个大小为 5 的一维高斯核，因此我们只需要计算 5 个纹理坐标即可。为此，我们在 v2f 结构体中定义了一个 5 维的纹理坐标数组。数组的第一个坐标存储了当前的采样纹理，而剩余的四个坐标则是高斯模糊中对邻域采样时使用的纹理坐标。我们还和属性 _BlurSize 相乘来控制采样距离。在高斯核维数不变的情况下，_BlurSize 越大，模糊程度越高，但采样数却不会受到影响。但过大的 _BlurSize 值会造成虚影，这可能并不是我们希望的。通过把计算采样纹理坐标的代码从片元着色器中转移到顶点着色器中，可以减少运算，提高性能。由于从顶点着色器到片元着色器的插值是线性的，因此这样的转移并不会影响纹理坐标的计算结果。</p><p>一个 5 $\times$ 5 的二维高斯核可以拆分成两个大小为 5 的一维高斯核，并且由于它的对称性，我们只需要记录 3 个高斯权重，也就是代码中的 weight 变量。我们首先声明了各个邻域像素对应的权重 weight，然后将结果值 sum 初始化为当前的像素值乘以它的权重值。根据对称性，我们进行了两次迭代，每次迭代包含了两次纹理采样，并把像素值和权重相乘后的结果叠加到 sum 中。最后，函数返回滤波结果 sum。</p><p>我们为两个 Pass 使用了 NAME 语义定义了它们的名字。这是因为，高斯模糊是非常常见的图像处理操作，很多屏幕特效都是建立在它的基础上的，例如 Bloom 效果。为 Pass 定义名字，可以在其他 Shader 中直接通过它们的名字来使用该 Pass，而不需要再重复编写代码。</p><p><img src="/posts_image/Post_Processing/Post_Processing_7.png" alt="高斯模糊后的效果" title="高斯模糊后的效果"></p><h2 id="Bloom-效果">Bloom 效果</h2><p>Bloom 特效是游戏中常见的一种屏幕效果。这种特效可以模拟真实摄像机的一种图像效果，它让画面中较亮的区域“扩散”到周围的区域中，造成一种朦胧的效果。Bloom 的实现原理非常简单：我们首先根据与一个阈值提取出图像中的较亮区域，把它存储在一张渲染纹理中，再利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线扩散的效果，最后再将其和原图像进行混合，得到最终的效果。</p><p>我们首先来编写 Bloom.cs 脚本。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bloom</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader bloomShader;<br><span class="hljs-keyword">private</span> Material bloomMaterial = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>bloomMaterial = CheckShaderAndCreateMaterial(bloomShader, bloomMaterial);<br><span class="hljs-keyword">return</span> bloomMaterial;<br>&#125;  <br>&#125;<br><br><span class="hljs-comment">// Blur iterations - larger number means more blur.</span><br>[<span class="hljs-meta">Range(0, 4)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> iterations = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// Blur spread for each iteration - larger value means more blur</span><br>[<span class="hljs-meta">Range(0.2f, 3.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> blurSpread = <span class="hljs-number">0.6f</span>;<br><br>[<span class="hljs-meta">Range(1, 8)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> downSample = <span class="hljs-number">2</span>;<br><br>[<span class="hljs-meta">Range(0.0f, 4.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> luminanceThreshold = <span class="hljs-number">0.6f</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_LuminanceThreshold&quot;</span>, luminanceThreshold);<br><br><span class="hljs-built_in">int</span> rtW = src.width/downSample;<br><span class="hljs-built_in">int</span> rtH = src.height/downSample;<br><br>RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br>buffer0.filterMode = FilterMode.Bilinear;<br><br>Graphics.Blit(src, buffer0, material, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; iterations; i++) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_BlurSize&quot;</span>, <span class="hljs-number">1.0f</span> + i * blurSpread);<br><br>RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// Render the vertical pass</span><br>Graphics.Blit(buffer0, buffer1, material, <span class="hljs-number">1</span>);<br><br>RenderTexture.ReleaseTemporary(buffer0);<br>buffer0 = buffer1;<br>buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// Render the horizontal pass</span><br>Graphics.Blit(buffer0, buffer1, material, <span class="hljs-number">2</span>);<br><br>RenderTexture.ReleaseTemporary(buffer0);<br>buffer0 = buffer1;<br>&#125;<br><br>material.SetTexture (<span class="hljs-string">&quot;_Bloom&quot;</span>, buffer0);  <br>Graphics.Blit (src, dest, material, <span class="hljs-number">3</span>);  <br><br>RenderTexture.ReleaseTemporary(buffer0);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>由于 Bloom 效果是建立在高斯模糊的基础上的，因此脚本中提供的参数和高斯模糊中的几乎完全一样，我们只增加了一个新的参数 luminanceThreshold 来控制提取较亮区域时使用的阈值大小；尽管在绝大多数情况下，图像的亮度不会超过 1，但如果我们开启了 HDR，硬件会允许我们把颜色值存储在一个更高精度范围的缓冲中，此时像素的亮度值可能会超过 1。因此，在这里我们把 luminanceThreshold 的值规定在 [0, 4] 范围内。</p><p>Bloom 效果需要 3 个步骤：首先，提取图像中较亮的区域，因此，我们没有直接对 src 进行降采样，而是通过调用 Graphics.Blit(src, buffer0, material, 0) 来使用 Shader 中的第一个 Pass 提取图像中较亮区域，提取到的较亮区域将存储在 buffer0 中。然后，我们进行高斯模糊迭代处理，这些 Pass 对应了 Shader 的第二个和第三个 Pass。模糊后的较亮区域将会存储在 buffer0 中，此时，我们再把 buffer0 传递给材质中的 _Bloom 纹理属性，并调用 Graphics.Blit(src, dest, material, 3) 使用 Shader 中的第四个 Pass 来进行最后的混合，将结果存储在目标渲染纹理 dest 中。最后，释放临时缓存。</p><p>下面我们来实现 Shader 的部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter12/Chapter12-Bloom&quot; &#123;<br><br>    Properties &#123;<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Bloom (&quot;Bloom (RGB)&quot;, 2D) = &quot;black&quot; &#123;&#125;<br>        _LuminanceThreshold (&quot;Luminance Threshold&quot;, Float) = 0.5<br>        _BlurSize (&quot;Blur Size&quot;, Float) = 1.0<br>    &#125;<br><br>    SubShader &#123;<br>        CGINCLUDE<br>        #include &quot;UnityCG.cginc&quot;<br><br>        sampler2D _MainTex;<br>        half4 _MainTex_TexelSize;<br>        sampler2D _Bloom;<br>        float _LuminanceThreshold;<br>        float _BlurSize;<br><br>        struct v2f &#123;<br>            float4 pos : SV_POSITION;<br>            half2 uv : TEXCOORD0;<br>        &#125;;<br><br>        v2f vertExtractBright (appdata_img v) &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br>            o.uv = v.texcoord;<br>            return o;<br>        &#125;<br><br>        fixed luminance (fixed4 color) &#123;<br>            return 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b;<br>        &#125;<br><br>        fixed4 fragExtractBright (v2f i) : SV_Target &#123;<br>            fixed4 c = tex2D(_MainTex, i.uv);<br>            fixed val = clamp(luminance(c) - _LuminanceThreshold, 0.0, 1.0);<br>            return c * val;<br>        &#125;<br><br>        struct v2fBloom &#123;<br>            float4 pos : SV_POSITION;<br>            half4 uv : TEXCOORD0;<br>        &#125;;<br><br>        v2fBloom vertBloom (appdata_img v) &#123;<br>            v2fBloom o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br>            o.uv.xy = v.texcoord;<br>            o.uv.zw = v.texcoord;<br><br>            #if UNITY_UV_STARTS_AT_TOP<br>            if(_MainTex_TexelSize.y &lt; 0.0)<br>                o.uv.w = 1.0 - o.uv.w;<br>            #endif<br><br>            return o;<br>        &#125;<br><br>        fixed4 fragBloom (v2fBloom i) : SV_TARGET &#123;<br>            return tex2D(_MainTex, i.uv.xy) + tex2D(_Bloom, i.uv.zw);<br>        &#125;<br><br>        ENDCG<br><br>        ZTest Always Cull Off ZWrite Off<br><br>        Pass &#123;<br><br>            CGPROGRAM<br>            #pragma vertex vertExtractBright<br>            #pragma fragment fragExtractBright<br>            ENDCG<br>        &#125;<br><br>        UsePass &quot;Custom/Chapter12/Chapter12-GaussianBlur/GAUSSIAN_BLUR_VERTICAL&quot;<br>        UsePass &quot;Custom/Chapter12/Chapter12-GaussianBlur/GAUSSIAN_BLUR_HORIZONTAL&quot;<br><br>        Pass &#123;<br>            CGPROGRAM<br>            #pragma vertex vertBloom<br>            #pragma fragment fragBloom<br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    FallBack Off<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用的顶点着色器与之前的有所不同，我们定义了两个纹理坐标，并存储在同一个类型为 half4 的变量 uv 中。它的 xy 分量对应了 _MainTex，即原图像的纹理坐标。而它的 zw 分量是 _Bloom，即模糊后的较亮区域的纹理坐标。我们需要对这个纹理坐标进行平台差异化处理。第二个和第三个 Pass 我们直接使用了上面高斯模糊中定义的两个 Pass，这是通过 UsePass 语义指明它们的 Pass 名来实现的。需要注意的是，由于 Unity 内部会把所有 Pass 的 Name 转换成大写字母表示，因此在使用 UsePass 命令时我们必须使用大写形式的名字。</p><p><img src="/posts_image/Post_Processing/Post_Processing_8.png" alt="Bloom 效果" title="Bloom 效果"></p><h2 id="运动模糊">运动模糊</h2><p>运动模糊是真实世界中的摄像机的一种效果。如果在摄像机曝光时，拍摄场景发生了变化，就会产生模糊的画面。运动模糊在我们的日常生活中是非常常见的，只要留心观察，就可以发现无论是体育报道还是各个电影里，都有运动模糊的身影。运动模糊效果可以让物体运动看起来更加真实平滑，但在计算机产生的图像中，由于不存在曝光这一物理现象，渲染出来的图像往往都是棱角分明，缺少运动模糊。在一些诸如赛车类型的游戏中，为画面添加运动模糊是一种常见的处理方法。</p><p>运动模糊的实现有多种方法。一种实现方法是利用一块<strong>积累缓存（accumulation buffer）<strong>来混合多张连续的图像。当物体快速移动产生多张图像后，我们取它们之间的平均值作为最后的运动模糊图像。然而，这种暴力的方法对性能的消耗很大，因为想要获取多张帧图像往往意味着我们需要在同一帧里渲染多次场景。另一种应用广泛的方法是创建和使用</strong>速度缓存（velocity buffer）</strong>，这个缓存中存储了各个像素当前的运动速度，然后利用该值来决定模糊的方向和大小。</p><p>在本次实现中，我们将使用类似上述第一种方法来模拟运动模糊的效果。我们不需要在一帧中把场景渲染多次，但需要保存之前的渲染结果，不断把当前的渲染图像叠加到之前的渲染图像中，从而产生一种运动轨迹的视觉效果。这种方法与原始的利用累计缓存的方法相比性能更好，但模糊效果可能会略有影响。</p><p>我们首先来编写 MotionBlur.cs 脚本。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MotionBlur</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader motionBlurShader;<br><span class="hljs-keyword">private</span> Material motionBlurMaterial = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>motionBlurMaterial = CheckShaderAndCreateMaterial(motionBlurShader, motionBlurMaterial);<br><span class="hljs-keyword">return</span> motionBlurMaterial;<br>&#125;  <br>&#125;<br><br>[<span class="hljs-meta">Range(0.0f, 0.9f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> blurAmount = <span class="hljs-number">0.5f</span>;<br><br><span class="hljs-keyword">private</span> RenderTexture accumulationTexture;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span> &#123;<br>DestroyImmediate(accumulationTexture);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// Create the accumulation texture</span><br><span class="hljs-keyword">if</span> (accumulationTexture == <span class="hljs-literal">null</span> || accumulationTexture.width != src.width || accumulationTexture.height != src.height) &#123;<br>DestroyImmediate(accumulationTexture);<br>accumulationTexture = <span class="hljs-keyword">new</span> RenderTexture(src.width, src.height, <span class="hljs-number">0</span>);<br>accumulationTexture.hideFlags = HideFlags.HideAndDontSave;<br>Graphics.Blit(src, accumulationTexture);<br>&#125;<br><br><span class="hljs-comment">// We are accumulating motion over frames without clear/discard</span><br><span class="hljs-comment">// by design, so silence any performance warnings from Unity</span><br>accumulationTexture.MarkRestoreExpected();<br><br>material.SetFloat(<span class="hljs-string">&quot;_BlurAmount&quot;</span>, <span class="hljs-number">1.0f</span> - blurAmount);<br><br>Graphics.Blit (src, accumulationTexture, material);<br>Graphics.Blit (accumulationTexture, dest);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>blurAmount 的值越大，运动拖尾的效果就越明显，为了防止拖尾效果完全替代当前帧的渲染结果，我们把它的值截取在 0.0~0.9 范围内。我们在脚本不运行时，即调用 OnDisable 函数时，立即销毁 accumulationTexture。这是因为，我们希望在下一次开始应用运动模糊时重新叠加图像。在确认材质可用后，我们首先判断用于混合图像的 accumulationTexture 是否满足条件。我们不仅判断它是否为空，还判断它是否与当前的屏幕分辨率相等，如果不满足，就说明我们需要重新创建一个适合于当前分辨率的 accumulationTexture 变量。创建完毕后，由于我们会自己控制该变量的销毁，因此可以把它的 hideFlags 设置为 HideFlags.HideAndDontSave，这意味着这个变量不会显示在 Hierarchy 中，也不会保存到场景中。然后，我们使用当前的帧图像初始化 accumulationTexture（使用 Graphics.Blit(src, accumulationTexture) 代码）。</p><p>当得到了有效的 accumulationTexture 变量后，我们调用了 accumulationTexture.MarkRestoreExpected 函数来表明我们需要进行一个渲染纹理的恢复操作。**恢复操作（restore operation）**发生在渲染到纹理而该纹理又没有被提前清空或销毁的情况下。在本例中，我们每次调用 OnRenderImage 时都需要把当前的帧图像和 accumulationTexture 中的图像混合，accumulationTexture 纹理不需要提前清空，因为它保存了我们之前的混合结果。然后，我们将参数传递给材质，并调用 Graphics.Blit(src, accumulationTexture, material) 把当前的屏幕图像 src 叠加到 accumulationTexture 中。最后使用 Graphics.Blit(accumulationTexture, dest) 把结果显示到屏幕上。</p><p>下面，我们来实现 Shader 部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter12/Chapter12-MotionBlur&quot; &#123;<br><br>    Properties &#123;<br>        _MainTex (&quot;Base (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _BlurAmount (&quot;Blur Amount&quot;, Float) = 1.0<br>    &#125;<br><br>    SubShader &#123;<br>        CGINCLUDE<br>        #include &quot;UnityCG.cginc&quot;<br><br>        sampler2D _MainTex;<br>        fixed _BlurAmount;<br><br>        struct v2f &#123;<br>            float4 pos : SV_POSITION;<br>            float2 uv : TEXCOORD0;<br>        &#125;;<br><br>        v2f vert(appdata_img v) &#123;<br>            v2f o;<br>            o.pos = UnityObjectToClipPos(v.vertex);<br>            o.uv = v.texcoord;<br>            return o;<br>        &#125;<br><br>        fixed4 fragRGB (v2f i) : SV_Target &#123;<br>            return fixed4(tex2D(_MainTex, i.uv).rgb, _BlurAmount);<br>        &#125;<br><br>        half4 fragA (v2f i) : SV_Target &#123;<br>            return tex2D(_MainTex, i.uv);<br>        &#125;<br><br>        ENDCG<br>        <br>        ZTest Always Cull Off ZWrite Off<br><br>        Pass &#123;<br>            Blend SrcAlpha OneMinusSrcAlpha<br><br>            ColorMask RGB<br><br>            CGPROGRAM<br>            #pragma vertex vert<br>            #pragma fragment fragRGB<br>            ENDCG<br>        &#125;<br><br>        Pass &#123;<br>            Blend One Zero<br>            ColorMask A<br>            CGPROGRAM<br>            #pragma vertex vert<br>            #pragma fragment fragA<br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    FallBack Off<br>&#125;<br></code></pre></td></tr></table></figure><p>RGB 通道版本的片元着色器对当前图像进行采样，并将其 A 通道的值设为 _BlurAmount，以便在后面混合时可以使用它的透明通道进行混合。A 通道版本的代码就更简单了，直接返回采样结果。实际上，这个版本只是为了维护渲染纹理的透明通道值，不让其受到混合时使用的透明度值的影响。然后，我们定义了运动模糊所需的 Pass。在本例中我们需要两个 Pass，一个用于更新渲染纹理的 RGB 通道，第一个用于更新 A 通道。之所以要把 A 通道和 RGB 通道分开，是因为在更新 RGB 时我们需要设置它的 A 通道来混合图像，但又不希望 A 通道的值写入渲染纹理中。</p><p>本次是对运动模糊的一种简单实现。我们混合了连续帧之间的图像，这样得到一张具有模糊拖尾的图像。然而，当物体运动速度过快时，这种方法可能会造成单独的帧图像变得可见。以后我们会学习如何利用深度纹理重建速度来模拟运动的模糊效果。</p><p><img src="/posts_image/Post_Processing/Post_Processing_9.png" alt="运动模糊效果" title="运动模糊效果"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;建立一个基本的屏幕后处理脚本系统&quot;&gt;建立一个基本的屏幕后处理脚本系统&lt;/h2&gt;
&lt;p&gt;屏幕后处理，通常指的是在渲染完整个场景得到屏幕图像后，再对这个图像进行一系列操作，实现各种屏幕特效。使用这种技术，可以为游戏画面添加更多的艺术效果，例如景深（Depth of F</summary>
      
    
    
    
    <category term="Unity Shader" scheme="http://example.com/categories/Unity-Shader/"/>
    
    
    <category term="Post Processing" scheme="http://example.com/tags/Post-Processing/"/>
    
  </entry>
  
  <entry>
    <title>动画效果</title>
    <link href="http://example.com/posts/%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/"/>
    <id>http://example.com/posts/%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/</id>
    <published>2022-02-24T12:04:54.000Z</published>
    <updated>2025-04-17T12:55:15.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Unity-Shader-中的内置变量（时间篇）">Unity Shader 中的内置变量（时间篇）</h2><p>动画效果往往都是把时间添加到一些变量的计算中，以便在时间变化时画面也可以随之变化。Unity Shader 提供了一系列关于时间的内置变量来允许我们方便地在 Shader 中访问运行时间，实现各种动画效果。下表给出了这些内置的时间变量。</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">_Time</td><td style="text-align:left">float4</td><td style="text-align:left">t 是自该场景加载开始所经过的时间，4 个分量的值分别是(t/20, t, 2t, 3t)</td></tr><tr><td style="text-align:left">_SinTime</td><td style="text-align:left">float4</td><td style="text-align:left">t 是时间的正弦值，4 个分量的值分别是(t/8, t/4, t/2, t)</td></tr><tr><td style="text-align:left">_CosTime</td><td style="text-align:left">float4</td><td style="text-align:left">t 是时间的余弦值，4 个分量的值分别是(t/8, t/4, t/2, t)</td></tr><tr><td style="text-align:left">unity_DeltaTime</td><td style="text-align:left">float4</td><td style="text-align:left">dt 是时间增量，4 个分量的值分别是(dt, 1/dt, smoothDt, 1/smoothDt)</td></tr></tbody></table><h2 id="纹理动画">纹理动画</h2><p>纹理动画在游戏中的应用非常广泛。尤其在各种资源都比较局限的移动平台上，我们往往会使用纹理动画来代替复杂的粒子系统等模拟各种动画效果。</p><h3 id="序列帧动画">序列帧动画</h3><p>最常见的纹理动画之一就是序列帧动画。序列帧动画的原理非常简单，它像放电影一样，依次播放一系列关键帧图像，当播放速度达到一定数值时，看起来就是一个连续的动画。它的优点在于灵活性很强，我们不需要进行任何物理计算就可以得到非常细腻的动画效果。而它的缺点也很明显，由于序列帧中每张关键帧图像都不一样，因此要制作一张出色的序列帧纹理所需要的美术工程量也比较大。</p><p>要想实现序列帧动画，我们要先提供一张包含了关键帧图像的图像。</p><p><img src="/posts_image/Animation_Effects/Animation_Effects_1.png" alt="序列帧图像" title="序列帧图像"></p><p>上述图像包含了 8 $\times$ 8 张关键帧图像，它们的大小相同，而且播放顺序为从左到右、从上到下。下图给出了不同时刻播放的不同动画效果。</p><p><img src="/posts_image/Animation_Effects/Animation_Effects_2.png" alt="使用序列帧动画来实现爆炸效果" title="使用序列帧动画来实现爆炸效果"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter11/Chapter11-ImageSequenceAnimation&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)<br>        _MainTex (&quot;Image Sequence&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _HorizontalAmount (&quot;Horizontal Amount&quot;, Float) = 8<br>        _VerticalAmount (&quot;Vertical Amount&quot;, Float) = 8<br>        _Speed (&quot;Speed&quot;, Range(1, 100)) = 30<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;<br><br>        Pass &#123;<br>            Tags &#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;<br>            ZWrite Off<br>            Blend SrcAlpha OneMinusSrcAlpha<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;UnityCG.cginc&quot;<br><br>            fixed4 _Color;<br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            float _HorizontalAmount;<br>            float _VerticalAmount;<br>            float _Speed;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float2 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float2 uv : TEXCOORD0;<br>            &#125;;<br>            <br>            v2f vert(a2v v)&#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET<br>            &#123;<br>                float time = floor(_Time.y * _Speed);<br>                float row = floor(time / _HorizontalAmount);<br>                float column = time - row * _HorizontalAmount;<br><br>                //half2 uv = float2(i.uv.x / _HorizontalAmount, i.uv.y / _VerticalAmount);<br>                //uv.x += column / _HorizontalAmount;<br>                //uv.y -= row / _VerticalAmount;<br>                half2 uv = i.uv + half2(column, -row);<br>                uv.x /= _HorizontalAmount;<br>                uv.y /= _VerticalAmount;<br><br>                fixed4 c = tex2D(_MainTex, uv);<br>                c.rgb *= _Color;<br><br>                return c;<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Transparent/VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>_MainTex 就是包含了所有关键帧图像的纹理。_HorizontalAmount 和 _VerticalAmount 分别代表了该图像在水平方向和竖直方向包含的关键帧图像的个数。而 _Speed 属性用于控制序列帧动画的播放速度。由于序列帧图像通常包含了透明通道，因此可以被当成是一个半透明对象。在这里我们使用半透明的“标配”来设置它的 SubShader 标签，即把 Queue 和 RenderType 设置成 Transparent，把 IgnoreProjector 设置为 True。在 Pass 中，我们使用 Blend 命令来开启并设置混合模式，同时关闭了深度写入。</p><p>要播放帧动画，从本质上来说，我们需要计算出每个时刻需要播放的关键帧在纹理中的位置。而由于序列帧纹理都是按行按列排列的，因此这个位置可以认为是该关键帧所在的行列索引数。因此，在片元着色器代码的前三行中我们计算了行列数，其中使用了 Unity 内置时间变量 _Time，_Time.y 就是自该场景加载后所经过的时间。我们首先把 _Time.y 和速度属性 _Speed  相乘来得到模拟的时间，并使用 CG 的 floor 函数对结果值取整来得到整数时间 time。然后，使用 time 除以 _HorizontalAmount 的结果值的商来作为当前对应的行索引，除法结果的余数则是列索引。接下来，我们需要使用行列索引值来构建真正的采样坐标。由于序列帧图像包含了许多关键帧图像，这意味着采样坐标需要映射到每个关键帧图像的坐标范围内。我们可以首先把原纹理坐标 i.uv 按行数和列数进行等分，得到每个子图像的纹理坐标范围。然后，我们需要使用当前的行列数对上面的结果进行偏移，得到当前子图像的纹理坐标。需要注意的是，对竖直方向的坐标偏移需要使用减法，这是因为在 Unity 中纹理坐标竖直方向的顺序（从下到上逐渐增大）和序列帧纹理中的顺序（播放顺序是从上到下）是相反的。这对应了上面代码中注释掉的代码部分。我们可以把上述过程中的除法整合到一起，就得到了注释下方的代码。这样，我们就得到了真正的纹理采样坐标。</p><h3 id="滚动的背景">滚动的背景</h3><p>很多 2D 游戏都使用了不断滚动的背景来模拟游戏角色在场景中的穿梭，这些背景往往包含了多个层（layers）来模拟一种视差效果。而这些背景的实现往往就是利用了纹理动画。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter11/Chapter11-ScrollingBackground&quot;<br>&#123;<br>    Properties<br>    &#123;<br>       _MainTex (&quot;Base Layer (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>       _DetailTex (&quot;2nd Layer (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>       _ScrollX (&quot;Base layer Scroll Speed&quot;, Float) = 1.0<br>       _Scroll2X (&quot;2nd layer Scroll Speed&quot;, Float) = 1.0<br>       _Multiplier (&quot;Layer Multiplier&quot;, Float) = 1<br>    &#125;<br>    SubShader<br>    &#123;<br>        Tags &#123;&quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;<br>        Pass &#123;<br>            Tags &#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;<br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;UnityCG.cginc&quot;<br>            <br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            sampler2D _DetailTex;<br>            float4 _DetailTex_ST;<br>            float _ScrollX;<br>            float _Scroll2X;<br>            float _Multiplier;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float4 uv : TEXCOORD0;<br>            &#125;;<br><br>            v2f vert(a2v v)&#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                //frac函数返回标量或每个矢量中各分量的小数部分<br>                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex) + frac(float2(_ScrollX, 0.0) * _Time.y);<br>                o.uv.zw = TRANSFORM_TEX(v.texcoord, _DetailTex) + frac(float2(_Scroll2X, 0.0) * _Time.y);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET<br>            &#123;<br>                fixed4 firstLayer = tex2D(_MainTex, i.uv.xy);<br>                fixed4 secondLayer = tex2D(_DetailTex, i.uv.zw);<br>                fixed4 c = lerp(firstLayer, secondLayer, secondLayer.a);<br>                c.rgb *= _Multiplier;<br>                return c;<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中，_MainTex 和 _DetailTex 分别是第一层（较远）和第二层（较近）的背景纹理，而 _ScrollX 和 _Scroll2X 对应了各自的水平滚动速度。_Multiplier 参数则用于控制纹理的整体亮度。我们首先进行了最基本的顶点变换，把顶点从模型空间变换到裁剪空间中。然后我们计算了两层背景纹理的纹理坐标。为此，我们首先利用 TRANSFORM_TEX 来得到初始的纹理坐标。然后，我们利用内置的 _Time.y 变量在水平方向上对纹理坐标进行偏移，以此来达到滚动的效果。我们把两张纹理的纹理坐标存储在同一个变量 o.uv 中，以减少占用的插值寄存器空间。</p><p>我们首先分别利用 i.uv.xy 和 <a href="http://i.uv.zw">i.uv.zw</a> 对两张背景纹理进行采样。然后，使用第二层纹理的透明通道来混合两张纹理，这使用了 CG 的 lerp 函数。最后，我们使用 _Multiplier 参数和输出颜色进行相乘，以调整背景亮度。</p><p><img src="/posts_image/Animation_Effects/Animation_Effects_3.png" alt="无限滚动的背景" title="无限滚动的背景"></p><h2 id="顶点动画">顶点动画</h2><h3 id="流动的河流">流动的河流</h3><p>河流的模拟是顶点动画最常见的应用之一。它的原理通常就是使用正弦函数等来模拟水流的波动效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter11/Chapter11-Water&quot;<br>&#123;<br>    Properties &#123;<br>_MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>_Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)<br>_Magnitude (&quot;Distortion Magnitude&quot;, Float) = 1<br> _Frequency (&quot;Distortion Frequency&quot;, Float) = 1<br> _InvWaveLength (&quot;Distortion Inverse Wave Length&quot;, Float) = 10<br> _Speed (&quot;Speed&quot;, Float) = 0.5<br>&#125;<br>SubShader &#123;<br>// Need to disable batching because of the vertex animation<br>Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;<br><br>Pass &#123;<br>Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>ZWrite Off<br>Blend SrcAlpha OneMinusSrcAlpha<br>Cull Off<br><br>CGPROGRAM  <br>#pragma vertex vert <br>#pragma fragment frag<br><br>#include &quot;UnityCG.cginc&quot; <br><br>sampler2D _MainTex;<br>float4 _MainTex_ST;<br>fixed4 _Color;<br>float _Magnitude;<br>float _Frequency;<br>float _InvWaveLength;<br>float _Speed;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float2 uv : TEXCOORD0;<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br>v2f o;<br><br>float4 offset;<br>offset.yzw = float3(0.0, 0.0, 0.0);<br>offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;<br>o.pos = UnityObjectToClipPos(v.vertex + offset);<br><br>o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>o.uv +=  float2(0.0, _Time.y * _Speed);<br><br>return o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>fixed4 c = tex2D(_MainTex, i.uv);<br>c.rgb *= _Color.rgb;<br><br>return c;<br>&#125; <br><br>ENDCG<br>&#125;<br>&#125;<br>FallBack &quot;Transparent/VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中，_MainTex 是河流纹理，_Color 用于控制整体颜色，_Magnitude 用于控制水流波动的幅度，_Frequency 用于控制波动频率，_InvWaveLength 用于控制波长的倒数（_InvWaveLength 越大，波长越小），_Speed 用于控制河流纹理的移动速度。在上面的设置中，我们除了为透明效果设置 Queue、IgnoreProjector 和 RenderType 外，还设置了一个新的标签——<strong>DisableBatching</strong>。一些 SubShader 在使用 Unity 的批处理功能时会出现问题，这时可以通过该标签来直接指明是否对该 SubShader 使用批处理。而这些需要特殊处理的 Shader 通常就是指包含了模型空间的顶点动画的 Shader。这是因为，批处理会合并所有相关的模型，而这些模型各自的模型空间就会丢失。而在本例中，我们需要在物体的模型空间下对顶点位置进行偏移。因此，在这里需要取消对该 Shader 的批处理操作。</p><p>我们关闭了深度写入，开启并设置了混合模式，并关闭了剔除功能。这是为了让水流的每个面都能显示。</p><p>我们首先计算顶点位移量。我们只希望对顶点的 x 方向进行位移，因此 yzw 的位移量被设置为 0。然后，我们利用 _Frequency 属性和内置的 _Time.y 变量来控制正弦函数的频率。为了让不同位置具有不同的位移，我们对上述结果加上了模型空间下的位置分量，并乘以 _InvWaveLength 来控制波长。最后，我们对结果值乘以 _Magnitude 属性来控制波动幅度，得到最终的位移。剩下的工作，我们只需要把位移量添加到顶点位置上，在进行正常的顶点变换即可。我们还进行了纹理动画，即使用 _Time.y 和 _Speed 来控制在水平方向上的纹理动画。</p><p><img src="/posts_image/Animation_Effects/Animation_Effects_4.png" alt="使用顶点动画来模拟 2D 的河流" title="使用顶点动画来模拟 2D 的河流"></p><h3 id="广告牌">广告牌</h3><p>另一种常见的顶点动画就是<strong>广告牌技术（Billboarding）</strong>。广告牌技术会根据视角方向来旋转一个被纹理着色的多边形（通常就是简单的四边形，这个多边形就是广告牌），使得多边形看起来好像总是面对着摄像机。广告牌技术被用于很多应用，比如渲染烟雾、云朵、闪光效果等。</p><p>广告牌技术的本质就是构建旋转矩阵，而我们知道一个变换矩阵需要三个基向量。广告牌技术使用的基向量通常就是<strong>表面法线（normal）、指向上的方向（up）<strong>以及</strong>指向右的方向（right）</strong>。除此之外，我们还需要指定一个<strong>锚点（anchor location）</strong>，这个锚点在旋转过程中是固定不变的，以此来确定多边形在空间中的位置。</p><p>广告牌技术的难点在于，如何根据需求来构建 3 个互相正交的基向量。计算过程通常是，我们首先会通过初始计算得到目标的表面法线（例如就是视角方向）和指向上的方向，而两者往往是不垂直的。但是，两者其中之一是固定的，例如当模拟草丛时，我们希望广告牌的指向上的方向永远是(0, 1, 0)，而法线方向应该随视角发生变化；而当模拟粒子效果时，我们希望广告牌的法线方向是固定的，即总是指向视角方向，指向上的方向则可以发生变化。我们假设法线方向是固定的，首先，我们根据初始的表面法线和指向上的方向来计算出目标方向的指向右的方向（通过叉积操作）：<br>$$<br>right = up \times normal<br>$$<br>对其归一化后，再由法线方向和指向右的方向计算出正交的指向上的方向即可：<br>$$<br>up’ = normal \times right<br>$$<br>至此，我们就可以得到用于旋转的三个正交基了。下图给出了上述计算过程的图示。如果指向上的方向是固定的，计算过程也是类似的。</p><p><img src="/posts_image/Animation_Effects/Animation_Effects_5.png" alt="计算正交基的过程" title="计算正交基的过程"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter11/Chapter11-Billboard&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)<br>        _VerticalBillboarding (&quot;Vertical Restraints&quot;, Range(0, 1)) = 1<br>    &#125;<br>    SubShader<br>    &#123;<br>        // Need to disable batching because of the vertex animation<br>        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;<br><br>        Pass &#123;<br>            Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;<br>            ZWrite Off<br>            Blend SrcAlpha OneMinusSrcAlpha<br>            Cull Off<br><br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br>            <br>            #include &quot;Lighting.cginc&quot;<br><br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            fixed4 _Color;<br>            fixed _VerticalBillboarding;<br><br>            struct a2v &#123;<br>float4 vertex : POSITION;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float2 uv : TEXCOORD0;<br>&#125;;<br><br>            v2f vert (a2v v) &#123;<br>v2f o;<br><br>// Suppose the center in object space is fixed<br>float3 center = float3(0, 0, 0);<br>float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, 1));<br>float3 normalDir = viewer - center;<br>// If _VerticalBillboarding equals 1, we use the desired view dir as the normal dir<br>// Which means the normal dir is fixed<br>// Or if _VerticalBillboarding equals 0, the y of normal is 0<br>// Which means the up dir is fixed<br>normalDir.y =normalDir.y * _VerticalBillboarding;<br>normalDir = normalize(normalDir);<br>// Get the approximate up dir<br>// If normal dir is already towards up, then the up dir is towards front<br>float3 upDir = abs(normalDir.y) &gt; 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);<br>float3 rightDir = normalize(cross(upDir, normalDir));<br>upDir = normalize(cross(normalDir, rightDir));<br><br>// Use the three vectors to rotate the quad<br>float3 centerOffs = v.vertex.xyz - center;<br>float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;<br>              <br>o.pos = UnityObjectToClipPos(float4(localPos, 1));<br>o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br><br>return o;<br>&#125;<br><br>fixed4 frag (v2f i) : SV_Target &#123;<br>fixed4 c = tex2D (_MainTex, i.uv);<br>c.rgb *= _Color.rgb;<br><br>return c;<br>&#125;<br><br>ENDCG<br>        &#125;<br><br>    &#125;<br>    FallBack &quot;Transparent/VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中，_MainTex 是广告牌显示的透明纹理，_Color 用于控制显示整体颜色，_VerticalBillboarding 则用于调整是固定法线还是固定指向上的方向，即约束垂直方向的程度。在广告牌技术中，我们需要使用物体的模型空间下的位置来作为锚点进行计算，为了让模型各自的模型空间不丢失，我们需要取消对该 Shader 的批处理操作。我们关闭了深度写入，开启并设置了混合模式，并关闭了剔除功能，这是为了让广告牌的每个面都能显示。</p><p>顶点着色器是我们的核心，所有的计算都是再模型空间下进行的。我们首先选择模型空间的原点作为广告牌的锚点，并利用内置变量获取模型空间下的视角位置，然后开始计算 3 个正交矢量。首先，我们根据观察位置和锚点计算目标法线方向，并根据 _VerticalBillboarding 属性来控制垂直方向上的约束度。当 _VerticalBillboarding 为 1 时，意味着法线方向固定为视角方向；当 _VerticalBillboarding 为 0 时，意味着向上方向固定为(0, 1, 0)。最后，我们需要对计算得到的法线方向进行归一化操作来得到单位矢量。接着，我们得到了粗略的向上方向。为了防止法线方向和向上方向平行（如果平行，那么叉积得到的结果将是错误的），我们对法线方向的 y 分量进行判断，以得到合适的向上方向。然后，根据法线方向和粗略的向上方向得到向右方向，并对结果进行归一化。但由于此时向上的方向还是不准确的，我们又根据准确的法线方向和向右方向得到最后的向上方向。这样，我们得到了所需的 3 个正交基向量。我们根据原始的位置相对于锚点的偏移量以及 3 个正交基矢量，以计算得到新的顶点位置，最后，把模型空间的顶点位置变换到裁剪空间中。</p><p>需要说明的是，在上面的例子中，我们使用的是 Unity 自带的四边形（Quad）来作为广告牌，而不能使用自带的平面（Plane）。这是因为，我们的代码是建立在一个竖直摆放的多边形的基础上的，也就是说，这个多边形的顶点结构需要满足在模型空间下是竖直排列的。只有这样，我们才能使用 v.vertex 来计算得到正确的相对于中心的位置偏移量。</p><p><img src="/posts_image/Animation_Effects/Animation_Effects_6.png" alt="广告牌效果" title="广告牌效果"></p><h3 id="注意事项">注意事项</h3><p>顶点动画虽然非常灵活有效，但有一些注意事项需要在此提醒一下。</p><p>首先，如果我们在模型空间下进行了一些顶点动画，那么批处理往往就会破坏这种动画效果。这时，我们可以通过 SubShader 中的 DisableBatching 标签来强制取消对该 Unity Shader 的批处理。然而，取消批处理会带来一定的性能下降，增加了 Draw Call，因此我们应该尽量避免使用模型空间的中心来作为锚点，我们可以利用顶点颜色来存储每个顶点到锚点的距离值，这种做法在商业游戏中很常见。</p><p>其次，如果我们想要对包含了顶点动画的物体添加阴影，那么如果仍然使用内置的 Diffuse 等包含的阴影的 Pass 来渲染，就得不到正确的阴影效果（这里指的是无法向其他物体正确地投射阴影）。这是因为，Unity 的阴影绘制需要调用一个 ShadowCasterPass，而如果直接使用这些内置的 ShadowCasterPass，这个 Pass 中并没有进行相关的顶点动画，因此 Unity 会仍然按照原来的顶点位置来计算阴影，这并不是我们希望看到的。这时，我们就需要提供一个自定义的 ShadowCasterPass，在这个 Pass 中，我们将进行同样的顶点变换过程。需要注意的是，在前面的实现中，如果涉及半透明物体我们都把 Fallback 设置成了 Transparent/VertexLit，而 Transparent/VertexLit 没有定义 ShadowCasterPass，因此也就不会产生阴影。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter11/Chapter11-VertexAnimationWithShadow&quot;<br>&#123;<br>    Properties &#123;<br>_MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>_Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)<br>_Magnitude (&quot;Distortion Magnitude&quot;, Float) = 1<br> _Frequency (&quot;Distortion Frequency&quot;, Float) = 1<br> _InvWaveLength (&quot;Distortion Inverse Wave Length&quot;, Float) = 10<br> _Speed (&quot;Speed&quot;, Float) = 0.5<br>&#125;<br>SubShader &#123;<br>// Need to disable batching because of the vertex animation<br>Tags &#123;&quot;DisableBatching&quot;=&quot;True&quot;&#125;<br><br>Pass &#123;<br>Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>Cull Off<br><br>CGPROGRAM  <br>#pragma vertex vert <br>#pragma fragment frag<br><br>#include &quot;UnityCG.cginc&quot; <br><br>sampler2D _MainTex;<br>float4 _MainTex_ST;<br>fixed4 _Color;<br>float _Magnitude;<br>float _Frequency;<br>float _InvWaveLength;<br>float _Speed;<br><br>struct a2v &#123;<br>    float4 vertex : POSITION;<br>    float4 texcoord : TEXCOORD0;<br>&#125;;<br><br>struct v2f &#123;<br>    float4 pos : SV_POSITION;<br>    float2 uv : TEXCOORD0;<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br>v2f o;<br><br>float4 offset;<br>offset.yzw = float3(0.0, 0.0, 0.0);<br>offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;<br>o.pos = UnityObjectToClipPos(v.vertex + offset);<br><br>o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br>o.uv +=  float2(0.0, _Time.y * _Speed);<br><br>return o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>fixed4 c = tex2D(_MainTex, i.uv);<br>c.rgb *= _Color.rgb;<br><br>return c;<br>&#125; <br><br>ENDCG<br>&#125;<br><br>// Pass to render object as a shadow caster<br>Pass &#123;<br>Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;<br><br>CGPROGRAM<br><br>#pragma vertex vert<br>#pragma fragment frag<br><br>#pragma multi_compile_shadowcaster<br><br>#include &quot;UnityCG.cginc&quot;<br><br>float _Magnitude;<br>float _Frequency;<br>float _InvWaveLength;<br>float _Speed;<br><br>struct v2f &#123; <br>    V2F_SHADOW_CASTER;<br>&#125;;<br><br>v2f vert(appdata_base v) &#123;<br>v2f o;<br><br>float4 offset;<br>offset.yzw = float3(0.0, 0.0, 0.0);<br>offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;<br>v.vertex = v.vertex + offset;<br><br>TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)<br><br>return o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>    SHADOW_CASTER_FRAGMENT(i)<br>&#125;<br>ENDCG<br>&#125;<br>&#125;<br>FallBack &quot;VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/posts_image/Animation_Effects/Animation_Effects_7.png" alt="为变形物体绘制正确的阴影" title="为变形物体绘制正确的阴影"></p><p>阴影投射的重点在于我们需要按正常 Pass 的处理来剔除片元或进行顶点动画，以便阴影可以和物体正常渲染的结果相匹配。在自定义的阴影投射的 Pass 中，我们通常会使用 Unity 提供的内置宏 V2F_SHADOW_CASTER、TRANSFER_SHADOW_CASTER_NORMALOFFSET（旧版本中会使用 TRANSFER_SHADOW_CASTER）和 SHADOW_CASTER_FRAGMENT 来计算阴影投射时需要的各种变量，而我们可以只关注自定义计算的部分。在上面的代码中，我们首先在 v2f 结构体中利用 V2F_SHADOW_CASTER 来定义阴影投射所需要定义的变量。随后，在顶点着色器中，我们首先按之前对顶点的处理方法计算顶点的偏移量，不同的是，我们直接把偏移值加到顶点位置变量中，再使用 TRANSFER_SHADOW_CASTER_NORMALOFFSET 来让 Unity 为我们完成剩下的事情。再片元着色器中，我们直接使用 SHADOW_CASTER_FRAGMENT 来让 Unity 自动完成阴影投射的部分，把结果输出到深度图和阴影映射纹理中。</p><p>通过 Unity 提供的这 3 个内置宏（在 UnityCG.cginc 文件中被定义），我们可以方便地自定义需要的阴影投射的 Pass，但由于这些宏里需要使用一些特定的输入变量，因此我们需要保证为它们提供了这些变量。例如，TRANSFER_SHADOW_CASTER_NORMALOFFSET 会使用名称 v 作为输入结构体，v 中需要包含顶点位置 v.vertex 和顶点法线 v.normal 的信息，我们可以直接使用内置的 appdata_base 结构体，它包含了这些必需的顶点变量。如果我们需要进行顶点动画，可以在顶点着色器中直接修改 v.vertex，再传递给 TRANSFER_SHADOW_CASTER_NORMALOFFSET 即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Unity-Shader-中的内置变量（时间篇）&quot;&gt;Unity Shader 中的内置变量（时间篇）&lt;/h2&gt;
&lt;p&gt;动画效果往往都是把时间添加到一些变量的计算中，以便在时间变化时画面也可以随之变化。Unity Shader 提供了一系列关于时间的内置变量来允许我</summary>
      
    
    
    
    <category term="Unity Shader" scheme="http://example.com/categories/Unity-Shader/"/>
    
    
    <category term="Animation" scheme="http://example.com/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>高级纹理(二)</title>
    <link href="http://example.com/posts/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86(%E4%BA%8C)/"/>
    <id>http://example.com/posts/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86(%E4%BA%8C)/</id>
    <published>2022-02-23T12:36:28.000Z</published>
    <updated>2025-04-17T12:55:15.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="渲染纹理">渲染纹理</h2><p>在之前的学习中，一个摄像机的渲染结果会输出到颜色缓冲中，并显示到我们的屏幕上。现代的 GPU 允许我们把整个三维场景渲染到一个中间缓冲中，即<strong>渲染目标纹理（Render Target Texture，RTT）</strong>，而不是传统的帧缓冲或后备缓冲（back buffer）。与之相关的是<strong>多重渲染目标（Multiple Render Target，MRT）</strong>，这种技术指的是 GPU 允许我们把场景同时渲染到多个渲染目标纹理中，而不再需要为每个渲染目标纹理单独渲染完整的场景。延迟渲染就是使用多重渲染目标的一个应用。</p><p>Unity 为渲染目标纹理定义了一种专门的纹理类型——<strong>渲染纹理（Render Texture）</strong>。在 Unity 中使用渲染纹理通常有两种方式：一种方式是在 Project 目录下创建一个渲染纹理，然后把某个摄像机的渲染目标设置成该渲染纹理，这样一来该摄像机的渲染结果就会实时更新到渲染纹理中，而不会显示在屏幕上。使用这种方法，我么还可以选择渲染纹理的分辨率、滤波模式等纹理属性。另一种方式是在屏幕后处理时使用 GrabPass 命令或 OnRenderImage 函数来获取当前屏幕图像，Unity 会把这个屏幕图像放到一张和屏幕分辨率等同的渲染纹理中，下面我们可以在自定义的 Pass 中把它们当成普通纹理来处理，从而实现各种屏幕特效。</p><h3 id="镜子效果">镜子效果</h3><p>在 Project 视图下创建一个渲染纹理（右键单击 Create -&gt; Render Texture），名为 MirrorTexture，它使用的纹理设置如下图：</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_11.png" alt="渲染纹理使用的纹理设置" title="渲染纹理使用的纹理设置"></p><p>为了得到从镜子出发观察到的场景图像，我们还需要创建一个摄像机，并调整它的位置、裁剪平面、视角等，使得它的显示图像是我们希望的镜子图像。由于这个摄像机不需要直接显示在屏幕上，而是用于渲染纹理，我们把创建的 MirrorTexture 拖拽到该摄像机的 Target Texture 上。下图显示了摄像机面板的设置。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_12.png" alt="摄像机 Target Texture 设置" title="摄像机 Target Texture 设置"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">Shader &quot;Custom/Chapter10/Chapter10-Mirror&quot;<br>&#123;<br>    Properties &#123;<br>_MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>&#125;<br>SubShader &#123;<br>Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;<br><br>Pass &#123;<br>CGPROGRAM<br><br>#pragma vertex vert<br>#pragma fragment frag<br><br>sampler2D _MainTex;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float3 texcoord : TEXCOORD0;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float2 uv : TEXCOORD0;<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.uv = v.texcoord;<br>// Mirror needs to filp x<br>o.uv.x = 1 - o.uv.x;<br><br>return o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>return tex2D(_MainTex, i.uv);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125; <br> FallBack Off<br>&#125;<br><br></code></pre></td></tr></table></figure><p>镜子实现的原理很简单，它使用一个渲染纹理作为输入属性，并把该渲染纹理在水平方向上翻转后直接显示到物体上即可。在上面的代码中，我们翻转了 x 分量的纹理坐标。这是因为镜子里显示的图像都是左右相反的。</p><p>在上面的实现中，我们把渲染纹理的分辨率大小设置为 256 $\times$ 256。有时，这样的分辨率会使图像模糊不清，此时我们可以使用更高的分辨率或更多的抗锯齿采样等。但需要注意的是，更高的分辨率会影响带宽和性能，我们应当尽量使用较小的分辨率。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_13.png" alt="镜子效果" title="镜子效果"></p><h3 id="玻璃效果">玻璃效果</h3><p>在 Unity 中，我们还可以在 Unity Shader 中使用一种特殊的 Pass 来完成获取屏幕图像的目的，这就是 GrabPass。当我们在 Shader 中定义了一个 GrabPass 后，Unity 会把当前屏幕的图像绘制在一张纹理中，以便我们在后续的 Pass 中访问它。我们通常会使用 GrabPass 来实现诸如玻璃等透明材质的模拟，与使用简单的透明混合不同，使用 GrabPass 可以让我们对该物体后面的图像进行更复杂的处理，例如使用法线来模拟折射效果，而不再是简单的和原屏幕颜色进行混合。</p><p>需要注意的是，在使用 GrabPass 时，我们需要额外<strong>小心物体的渲染队列设置</strong>。GrabPass 通常用于渲染透明物体，尽管代码里并不包含混合指令，但我们往往仍然需要把物体的渲染队列设置成透明队列（即&quot;Queue&quot;=“Transparent”）。这样才能保证当渲染物体时，所有的不透明物体都已经被绘制在屏幕上，从而获取正确的屏幕图像。</p><p>我们首先使用一张法线纹理来修改模型的法线信息，然后使用反射方法，通过一个 Cubemap 来模拟玻璃的反射，而在模拟折射时，则使用 GrabPass 获取玻璃后面的屏幕图像，并使用切线空间下的法线对屏幕纹理坐标偏移后，再对屏幕图像进行采样来模拟近似的折射效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br><br>Shader &quot;Custom/Chapter10/Chapter10-GlassRefraction&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;<br>        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;<br>        _Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<br>        _Distortion (&quot;Distortion&quot;, Range(0, 100)) = 10<br>        _RefractAmount (&quot;Refract Amount&quot;, Range(0.0, 1.0)) = 1.0<br>    &#125;<br>    SubShader<br>    &#123;<br>        //We must be transparent, so other objects are drawn before this one.<br>        Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;<br><br>        //This pass grabs the screen behind the object into a texture.<br>        //We can access the result in the next pass as _RefractionTex<br>        GrabPass &#123; &quot;_RefractionTex&quot; &#125; <br><br>        Pass &#123;<br>            CGPROGRAM<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;UnityCG.cginc&quot;<br><br>            sampler2D _MainTex;<br>            float4 _MainTex_ST;<br>            sampler2D _BumpMap;<br>            float4 _BumpMap_ST;<br>            samplerCUBE _Cubemap;<br>            float _Distortion;<br>            fixed _RefractAmount;<br>            sampler2D _RefractionTex;<br>            float4 _RefractionTex_TexelSize;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 tangent : TANGENT;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br>            <br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float4 scrPos : TEXCOORD0;<br>                float4 uv : TEXCOORD1;<br>                float4 TtoW0 : TEXCOORD2;  <br>                float4 TtoW1 : TEXCOORD3;  <br>                float4 TtoW2 : TEXCOORD4;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.scrPos = ComputeGrabScreenPos(o.pos);<br>                o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);<br>                o.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap);<br><br>                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);<br>                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);<br>                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;<br><br>                o.TtoW0 =  float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);<br>                o.TtoW1 =  float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);<br>                o.TtoW2 =  float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);<br><br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET<br>            &#123;<br>                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);<br>                fixed3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));<br><br>                //Get the normal in tangent space<br>                fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));<br><br>                //Compute the offset in tangent space<br>                float2 offset = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;<br>                i.scrPos.xy = offset + i.scrPos.xy;<br>                fixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;<br><br>                //Convert the normal to world space<br>                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));<br>                fixed3 reflDir = reflect(-worldViewDir, bump);<br>                fixed4 texColor = tex2D(_MainTex, i.uv.xy);<br>                fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb;<br>                fixed3 finalColor = reflCol * (1 - _RefractAmount) + refrCol * _RefractAmount;<br><br>                return fixed4(finalColor, 1);<br><br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Diffuse&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>_MainTex 是该玻璃的材质纹理；_BumpMap 是玻璃的法线纹理；_Cubemap 是用于模拟反射的环境纹理；_Distortion 是用于控制模拟折射时图像的扭曲程度；_RefractAmount 用于控制折射程度，当 _RefractAmount 值为 0 时，该玻璃只包含反射效果，当 _RefractAmount 值为 1 时，该玻璃只包括折射效果。</p><p>我们首先在 SubShader 的标签中将渲染队列设置成 Transparent，尽管在后面的 RenderType 被设置为了 Opaque。这两者看似矛盾，但实际服务于不同的需求。把 Queue 设置成 Transparent 可以确保该物体渲染时，其他所有不透明物体都已经渲染到屏幕上了，否则就可能无法正确得到“透过玻璃看到的图像”。而设置 RenderType 则是为了在使用着色器替换（Shader Replacement）时，该物体可以在需要时被正确渲染。这通常发生在我们需要得到摄像机的深度和法线纹理时。</p><p>随后我们通过关键词 GrabPass 定义了一个抓取屏幕图像的 Pass。在这个 Pass 中我们定义了一个字符串，该字符串内部的名称决定了抓取得到的屏幕图像将会被存入哪个纹理中。实际上，我们可以省略声明该字符串，但直接声明纹理名称的方法往往可以得到更高的性能。下面是两种情况的比较。</p><ul><li>直接使用 GrabPass {}，然后在后续的 Pass 中直接使用 _GrabTexture 来访问屏幕图像。但是，当场景中有多个物体都使用了这样的形式来抓取屏幕时，这种方法的性能消耗比较大，因为对于每一个使用它的物体，Unity 都会为它单独进行一次昂贵的屏幕抓取操作。但这种方法可以让每个物体得到不同的屏幕图像，这取决于它们的渲染队列及渲染它们时当前的屏幕缓冲中的颜色。</li><li>使用 GrabPass {“TextureName”}，我们可以在后续的 Pass 中使用 TextureName 来访问屏幕图像。使用这种方法同样可以抓取屏幕，但 Unity 只会在每一帧时为第一个使用名为 TextureName 的纹理的物体执行一次抓取屏幕的操作，而这个纹理同样可以在其他 Pass 中被访问。这种方法更高效，因为不管场景中有多少物体使用了该命令，每一帧中 Unity 都只会执行一次抓取工作，但这也意味着所有物体都会使用同一张屏幕图像。不过，这在大多数情况下已经足够了。</li></ul><p>我们还定义了 _RefractionTex 和 _RefractionTex_TexelSize 变量，这对应了在使用 GrabPass 时指定的纹理名称。_RefractionTex_TexelSize 可以让我们得到该纹理的纹素大小，例如一个大小为 256 $\times$ 512 的纹理，它的纹素大小为(1/256, 1/512)。我们需要在对屏幕图像的采样坐标进行偏移时使用该变量。</p><p>在进行了必要的顶点坐标变换后，我们通过调用内置的 ComputeGrabScreenPos 函数来得到对应被抓取的屏幕图像的采样坐标。我们可以在 UnityCG.cginc 文件中找到它的声明，它的主要代码和 ComputeScreenPos 基本类似，最大的不同是针对平台差异造成的采样坐标问题进行了处理。接着，我们计算了 _MainTex 和 _BumpMap 的采样坐标，并把它们分别存储在一个 float4 类型变量的 xy 和 zw 分量中。由于我们需要在片元着色器中把法线方向从切线方向（由法线纹理采样得到）变换到世界空间下，以便对 Cubemap 进行采样，因此，我们需要在这里计算该顶点对应的从切线空间到世界空间的变换矩阵，并把该矩阵的每一行分别存储在 TtoW0、TtoW1、和 TtoW2 的 xyz 分量中。这里面使用的数学方法就是，得到切线空间下的 3 个坐标轴（xyz 轴分别对应了副切线、切线和法线的方向）在世界空间下的表示，再把它们依次按<strong>列</strong>组成一个变换矩阵即可。TtoW0 等值的 w 轴同样被利用起来，用于存储世界空间下的顶点坐标。</p><p>我们通过 TtoW0 等变量的 w 分量得到世界坐标，并用该值得到该片元对应的视角方向。随后，我们对法线纹理进行采样，得到切线空间下的法线方向。我们使用该值和 _Distortion 属性以及 _RefractionTex_TexelSize 来对屏幕图像的采样坐标进行偏移，模拟折射效果。_Distortion 值越大，偏移量越大，玻璃背后的物体看起来变形程度越大。在这里，我们选择使用切线空间下单法线方向来进行偏移，是因为该空间下的法线可以反应顶点局部空间下的法线方向。随后，我们对 scrPos 透视除法得到真正的屏幕坐标，再使用该坐标对抓取的屏幕图像 _RefractionTex 进行采样，得到模拟的折射颜色。</p><p>之后，我们把法线方向从切线空间变换到了世界空间下（使用变换矩阵的每一行，即 TtoW0、TtoW1 和 TtoW2，分别和法线方向点乘，构成新的法线方向），并据此得到视角方向相对于法线方向的反射方向。随后，使用反射方向对 Cubemap 进行采样，并把结果和主纹理颜色相乘后得到反射颜色。最后我们使用 _RefractAmount 属性对反射和折射颜色进行混合，作为最终的输出颜色。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_14.png" alt="玻璃效果" title="玻璃效果"></p><h3 id="渲染纹理-vs-GrabPass">渲染纹理 vs. GrabPass</h3><p>尽管 GrabPass 和 渲染纹理 + 额外摄像机的方式都可以抓取屏幕图像，但它们之间还是有一些不同的。GrabPass 的好处在于实现简单，我们只需要在 Shader 中写几行代码就可以实现抓取屏幕的目的。而要使用渲染纹理的话，我们首先需要创建一个渲染纹理和一个额外的摄像机，再把该摄像机的 Render Target 设置为新建的渲染纹理对象，最后把该渲染纹理传递给相应的 Shader。</p><p>但从效率上来讲，使用渲染纹理的效率往往要好于 GrabPass，尤其在移动设备上。使用渲染纹理我们可以自定义渲染纹理的大小，尽管这种方法需要把部分场景再次渲染一遍，但我们可以通过调整摄像机的渲染层来减少二次渲染时的场景大小，或使用其他方法来控制摄像机是否需要开启。而使用 GrabPass 获取到的图像分辨率和显示屏幕是一致的，这意味着在一些高分辨率的设备上可能会造成严重的带宽影响。而且在移动设备上，GrabPass 虽然不会重新渲染场景，但它往往需要 CPU 直接读取后备缓冲（back buffer）中的数据，破坏了 CPU 和 GPU 之间的并行性，这是比较耗时的，甚至在一些移动设备上这是不支持的。</p><p>Unity 引入了<strong>命令缓冲（Command Buffers）<strong>来允许我们扩展 Unity 的渲染流水线。使用命令缓冲我们也可以得到类似抓屏的效果，它可以在不透明物体渲染后把当前的图像复制到一个临时的渲染目标纹理中，然后在那里进行一些额外的操作，例如模糊等等，最后把图像传递给需要使用它的物体进行处理和显示。除此之外，命令缓冲还允许我们实习很多特殊的效果，我们可以在 Unity 官方手册中的</strong>图像命令缓冲</strong>一文（<a href="https://docs.unity.cn/cn/2021.2/Manual/GraphicsCommandBuffers.html%EF%BC%89%E4%B8%AD%E6%89%BE%E5%88%B0%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9%E3%80%82">https://docs.unity.cn/cn/2021.2/Manual/GraphicsCommandBuffers.html）中找到更多内容。</a></p><h2 id="程序纹理">程序纹理</h2><p>**程序纹理（Procedural Texture）**指的是那些由计算机生成的图像，我们通常使用一些特定的算法来创建个性化图案或非常真实的自然元素，例如木头、石子等。使用程序纹理的好处在于我们可以使用各种参数来控制纹理的外观，而这些属性不仅仅是那些颜色属性，甚至可以是完全不同类型的图案属性，这使得我们可以得到更加丰富的动画和视觉效果。</p><h3 id="在-Unity-中实现简单的程序纹理">在 Unity 中实现简单的程序纹理</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br>[<span class="hljs-meta">ExecuteInEditMode</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProceduralTextureGeneration</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br><span class="hljs-keyword">public</span> Material material = <span class="hljs-literal">null</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">region</span> Material properties</span><br>[<span class="hljs-meta">SerializeField, SetProperty(<span class="hljs-string">&quot;textureWidth&quot;</span>)</span>]<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_textureWidth = <span class="hljs-number">512</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> textureWidth &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">return</span> m_textureWidth;<br>&#125;<br><span class="hljs-keyword">set</span> &#123;<br>m_textureWidth = <span class="hljs-keyword">value</span>;<br>_UpdateMaterial();<br>&#125;<br>&#125;<br><br>[<span class="hljs-meta">SerializeField, SetProperty(<span class="hljs-string">&quot;backgroundColor&quot;</span>)</span>]<br><span class="hljs-keyword">private</span> Color m_backgroundColor = Color.white;<br><span class="hljs-keyword">public</span> Color backgroundColor &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">return</span> m_backgroundColor;<br>&#125;<br><span class="hljs-keyword">set</span> &#123;<br>m_backgroundColor = <span class="hljs-keyword">value</span>;<br>_UpdateMaterial();<br>&#125;<br>&#125;<br><br>[<span class="hljs-meta">SerializeField, SetProperty(<span class="hljs-string">&quot;circleColor&quot;</span>)</span>]<br><span class="hljs-keyword">private</span> Color m_circleColor = Color.yellow;<br><span class="hljs-keyword">public</span> Color circleColor &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">return</span> m_circleColor;<br>&#125;<br><span class="hljs-keyword">set</span> &#123;<br>m_circleColor = <span class="hljs-keyword">value</span>;<br>_UpdateMaterial();<br>&#125;<br>&#125;<br><br>[<span class="hljs-meta">SerializeField, SetProperty(<span class="hljs-string">&quot;blurFactor&quot;</span>)</span>]<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_blurFactor = <span class="hljs-number">2.0f</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> blurFactor &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">return</span> m_blurFactor;<br>&#125;<br><span class="hljs-keyword">set</span> &#123;<br>m_blurFactor = <span class="hljs-keyword">value</span>;<br>_UpdateMaterial();<br>&#125;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br><span class="hljs-keyword">private</span> Texture2D m_generatedTexture = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// Use this for initialization</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> ()</span> &#123;<br><span class="hljs-keyword">if</span> (material == <span class="hljs-literal">null</span>) &#123;<br>Renderer renderer = gameObject.GetComponent&lt;Renderer&gt;();<br><span class="hljs-keyword">if</span> (renderer == <span class="hljs-literal">null</span>) &#123;<br>Debug.LogWarning(<span class="hljs-string">&quot;Cannot find a renderer.&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>material = renderer.sharedMaterial;<br>&#125;<br><br>_UpdateMaterial();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> _UpdateMaterial() &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>m_generatedTexture = _GenerateProceduralTexture();<br>material.SetTexture(<span class="hljs-string">&quot;_MainTex&quot;</span>, m_generatedTexture);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Color _MixColor(Color color0, Color color1, <span class="hljs-built_in">float</span> mixFactor) &#123;<br>Color mixColor = Color.white;<br>mixColor.r = Mathf.Lerp(color0.r, color1.r, mixFactor);<br>mixColor.g = Mathf.Lerp(color0.g, color1.g, mixFactor);<br>mixColor.b = Mathf.Lerp(color0.b, color1.b, mixFactor);<br>mixColor.a = Mathf.Lerp(color0.a, color1.a, mixFactor);<br><span class="hljs-keyword">return</span> mixColor;<br>&#125;<br><br><span class="hljs-keyword">private</span> Texture2D _GenerateProceduralTexture() &#123;<br>Texture2D proceduralTexture = <span class="hljs-keyword">new</span> Texture2D(textureWidth, textureWidth);<br><br><span class="hljs-comment">// The interval between circles</span><br><span class="hljs-built_in">float</span> circleInterval = textureWidth / <span class="hljs-number">4.0f</span>;<br><span class="hljs-comment">// The radius of circles</span><br><span class="hljs-built_in">float</span> radius = textureWidth / <span class="hljs-number">10.0f</span>;<br><span class="hljs-comment">// The blur factor</span><br><span class="hljs-built_in">float</span> edgeBlur = <span class="hljs-number">1.0f</span> / blurFactor;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> w = <span class="hljs-number">0</span>; w &lt; textureWidth; w++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> h = <span class="hljs-number">0</span>; h &lt; textureWidth; h++) &#123;<br><span class="hljs-comment">// Initalize the pixel with background color</span><br>Color pixel = backgroundColor;<br><br><span class="hljs-comment">// Draw nine circles one by one</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br><span class="hljs-comment">// Compute the center of current circle</span><br>Vector2 circleCenter = <span class="hljs-keyword">new</span> Vector2(circleInterval * (i + <span class="hljs-number">1</span>), circleInterval * (j + <span class="hljs-number">1</span>));<br><br><span class="hljs-comment">// Compute the distance between the pixel and the center</span><br><span class="hljs-built_in">float</span> dist = Vector2.Distance(<span class="hljs-keyword">new</span> Vector2(w, h), circleCenter) - radius;<br><br><span class="hljs-comment">// Blur the edge of the circle</span><br>Color color = _MixColor(circleColor, <span class="hljs-keyword">new</span> Color(pixel.r, pixel.g, pixel.b, <span class="hljs-number">0.0f</span>), Mathf.SmoothStep(<span class="hljs-number">0f</span>, <span class="hljs-number">1.0f</span>, dist * edgeBlur));<br><br><span class="hljs-comment">// Mix the current color with the previous color</span><br>pixel = _MixColor(pixel, color, color.a);<br>&#125;<br>&#125;<br><br>proceduralTexture.SetPixel(w, h, pixel);<br>&#125;<br>&#125;<br><br>proceduralTexture.Apply();<br><br><span class="hljs-keyword">return</span> proceduralTexture;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>由于我们生成的纹理是由若干圆点构成的，因此在上面的代码中，我们声明了 4 个纹理属性：纹理的大小，数值通常是 2 的整数幂；纹理的背景颜色；原点的颜色；模糊因子，这个参数是用来模糊边界的。对于每个属性使用了 get/set 方法，为了在面板上修改属性时仍可执行 set 函数，我们使用了一个开源插件 SetProperty（<a href="https://github.com/LMNRY/SetProperty/blob/master/Scripts/SetPropertyExample.cs%EF%BC%89%E3%80%82%E8%BF%99%E4%BD%BF%E5%BE%97%E6%88%91%E4%BB%AC%E4%BF%AE%E6%94%B9%E4%BA%86%E6%9D%90%E8%B4%A8%E5%B1%9E%E6%80%A7%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%89%A7%E8%A1%8C">https://github.com/LMNRY/SetProperty/blob/master/Scripts/SetPropertyExample.cs）。这使得我们修改了材质属性时，可以执行</a> _UpdateMaterial 函数来使用新的属性重新生成程序纹理。</p><p>代码首先初始化一张二维纹理，并且提前计算了一些生成纹理时需要的变量。然后，使用了一个两层的嵌套循环遍历纹理中的每个像素，并在纹理上依次绘制 9 个圆形。最后调用 Texture2D.Apply 函数来强制把像素值写入纹理中，并返回该程序纹理。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_15.png" alt="程序纹理" title="程序纹理"></p><h3 id="Unity-的程序材质">Unity 的程序材质</h3><p>在 Unity 中，有一类专门使用程序纹理的材质，叫做<strong>程序材质（Procedural Materials）</strong>。这类材质和我们之前使用的那些材质本质上是一样的，不同的是，它们使用的纹理不是普通的纹理，而是程序纹理。需要注意的是，程序材质和它使用的程序纹理并不是在 Unity 中创建的，而是使用了一个名为 <strong>Substance Designer</strong> 的软件在 Unity 外部生成的。<strong>Substance Designer</strong> 是一个非常出色的纹理生成工具，很多 3A 的游戏项目都使用了由它生成的材质。这些材质都是以 .sbsar 为后缀的。在 Unity 中需要从官方资源商店或 Package Manager 安装 Substance in Unity 插件，把以 .sbsar 为后缀的文件导入到 Unity 后，Unity 就会生成一个 <strong>程序纹理资源（Procedural Material Asset）</strong>。程序纹理资源可以包含一个或多个程序材质。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_16.png" alt="程序纹理资源" title="程序纹理资源"></p><p>我们可以在程序纹理的面板上看到该材质使用的 Unity Shader 及其属性、生成程序纹理使用的纹理属性、材质预览等信息。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_17.png" alt="程序纹理资源效果" title="程序纹理资源效果"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;渲染纹理&quot;&gt;渲染纹理&lt;/h2&gt;
&lt;p&gt;在之前的学习中，一个摄像机的渲染结果会输出到颜色缓冲中，并显示到我们的屏幕上。现代的 GPU 允许我们把整个三维场景渲染到一个中间缓冲中，即&lt;strong&gt;渲染目标纹理（Render Target Texture，RTT）&lt;/</summary>
      
    
    
    
    <category term="Unity Shader" scheme="http://example.com/categories/Unity-Shader/"/>
    
    
    <category term="Texture" scheme="http://example.com/tags/Texture/"/>
    
  </entry>
  
  <entry>
    <title>高级纹理(一)</title>
    <link href="http://example.com/posts/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86(%E4%B8%80)/"/>
    <id>http://example.com/posts/%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86(%E4%B8%80)/</id>
    <published>2022-02-23T06:43:23.000Z</published>
    <updated>2025-04-17T12:55:15.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="立方体纹理">立方体纹理</h2><p>在图形学中，**立方体纹理（Cubemap）<strong>是</strong>环境映射（Environment Mapping）**的一种实现方法。环境映射可以模拟物体周围的环境，而使用了环境映射的物体可以看起来像镀了层金属一样反射出周围的环境。</p><p>立方体纹理一共包含了 6 张图像，这些图像对应了一个立方体的 6 个面，立方体纹理的名称也由此而来。立方体的每个面表示沿着世界空间下的轴向（上、下、左、右、前、后）观察所得的图像。对立方体纹理采样需要提供一个三维的纹理坐标，这个三维纹理坐标表示了在世界空间下的 3D 方向。这个方向矢量从立方体的中心出发，当它向外部延伸时就会和立方体的 6 个纹理之一发生相交，而采样得到的结果就是由该交点计算而来的。下图给出了使用方向矢量对立方体纹理采样的过程。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_1.png" alt="对立方体纹理的采样" title="对立方体纹理的采样"></p><p>立方体纹理的好处在于实现简单快速，得到的效果也比较好，但是它也有一些缺点，例如当场景中引入了新的物体、光源，或者物体发生移动时，我们就需要重新生成立方体纹理。除此之外，立方体纹理也仅可以反射环境，但不能反射使用了该立方体纹理的物体本身。这是因为立方体纹理不能模拟多次反射的结果，例如两个金属球互相反射的情况（Unity 引入的全局光照系统允许实现这样的自反射效果）。由于这样的原因，想要得到令人信服的渲染结果，应该尽量对凸面体而不要对凹面体使用立方体纹理（因为凹面体会反射自身）。</p><p>立方体纹理在实时渲染中有很多应用，最常见的是用于天空盒子（Skybox）以及环境映射。</p><h3 id="天空盒子">天空盒子</h3><p>**天空盒子（Skybox）**是游戏中用于模拟背景的一种方法。当我们在场景中使用了天空盒子时，整个场景就被包围在一个立方体内。这个立方体的每个面使用的技术就是立方体纹理映射技术。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_2.png" alt="天空盒子材质" title="天空盒子材质"></p><p>为了让天空盒子正常渲染，我们还需要把这 6 张纹理的 <strong>Wrap Mode</strong> 设置为 <strong>Clamp</strong>，以防在接缝处出现不匹配的现象。上面的材质中，除了 6 张纹理属性外还有 3 个属性：<strong>Tint Color</strong>，用于控制该材质的整体颜色；<strong>Exposure</strong>，用于调整天空盒子的亮度；<strong>Rotation</strong>，用于调整天空盒子沿 +y 轴方向的旋转角度。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_3.png" alt="为场景使用自定义的天空盒子" title="为场景使用自定义的天空盒子"></p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_4.png" alt="使用了天空盒子的场景" title="使用了天空盒子的场景"></p><p>在 Unity 中，天空盒子是在所有不透明物体之后渲染的，而其背后使用的网格是一个立方体或一个细分后的球体。</p><h3 id="创建用于环境映射的立方体纹理">创建用于环境映射的立方体纹理</h3><p>除了天空盒子，立方体纹理最常见的用处是用于环境映射。通过这种方法，我们可以模拟出金属质感的材质。</p><p>在 Unity 中，创建用于环境映射的立方体纹理的方法有三种：第一种方法是直接由一些特殊布局的纹理创建；第二种方法是手动创建一个 Cubemap 资源，再把 6 张图赋给它；第三种方法是由脚本生成。</p><p>如果使用第一种方法，我们需要提供一张具有特殊布局的纹理，例如类似立方体展开图的交叉布局、全景布局等。然后，我们只需要把该纹理的 <strong>Texture Type</strong> 设置为 <strong>Cubemap</strong> 即可，Unity 会为我们做好剩下的事情。在基于物理的渲染中，我们通常会使用一张 HDR 图像来生成高质量的 Cubemap。</p><p>第二种方法是 Unity 5 之前的版本中使用的方法。我们首先需要在项目资源中创建一个 Cubemap，然后把 6 张纹理拖拽到它的面板中。官方推荐使用第一种方法创建立方体纹理，这是因为第一种方法可以对纹理数据进行压缩，而且可以支持边缘修正、光滑反射（glossy reflection）和 HDR 等功能。</p><p>前面两种方法都需要我们提前准备好立方体纹理的图像，它们得到的立方体纹理往往是被场景中的物体所共用的。但在理想情况下，我们希望根据物体在场景中位置的不同，生成它们各自不同的立方体纹理。这时，我们就可以在 Unity 中使用脚本来创建。这是通过利用 Unity 提供的 <strong>Camera.RenderToCubemap</strong> 函数来实现的。Camera.RenderToCubemap 函数可以把从任意位置观察到的场景图像存储到 6 张图中，从而创建出该位置上对应的立方体纹理。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEditor;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RenderCubemapWizard</span> : <span class="hljs-title">ScriptableWizard</span> &#123;<br><br><span class="hljs-keyword">public</span> Transform renderFromPosition;<br><span class="hljs-keyword">public</span> Cubemap cubemap;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnWizardUpdate</span> ()</span> &#123;<br>helpString = <span class="hljs-string">&quot;Select transform to render from and cubemap to render into&quot;</span>;<br>isValid = (renderFromPosition != <span class="hljs-literal">null</span>) &amp;&amp; (cubemap != <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnWizardCreate</span> ()</span> &#123;<br><span class="hljs-comment">// create temporary camera for rendering</span><br>GameObject go = <span class="hljs-keyword">new</span> GameObject( <span class="hljs-string">&quot;CubemapCamera&quot;</span>);<br>go.AddComponent&lt;Camera&gt;();<br><span class="hljs-comment">// place it on the object</span><br>go.transform.position = renderFromPosition.position;<br><span class="hljs-comment">// render into cubemap</span><br>go.GetComponent&lt;Camera&gt;().RenderToCubemap(cubemap);<br><br><span class="hljs-comment">// destroy temporary camera</span><br>DestroyImmediate( go );<br>&#125;<br><br>[<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;GameObject/Render into Cubemap&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RenderCubemap</span> ()</span> &#123;<br>ScriptableWizard.DisplayWizard&lt;RenderCubemapWizard&gt;(<br><span class="hljs-string">&quot;Render cubemap&quot;</span>, <span class="hljs-string">&quot;Render!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们在 renderFromPosition（由用户指定）位置处动态创建一个摄像机，并调用 Camera.RenderToCubemap 函数把从当前位置观察到的图像渲染到用户指定的立方体纹理 cubemap 中，完成后再销毁临时摄像机。由于该代码需要添加菜单栏条目，因此我们需要把它放在 Editor 文件夹下才能正确执行。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_5.png" alt="使用脚本创建立方体纹理" title="使用脚本创建立方体纹理"></p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_6.png" alt="使用脚本渲染立方体纹理" title="使用脚本渲染立方体纹理"></p><p>需要注意的是，我们需要为 Cubemap 设置大小，即上图中的 <strong>Face size</strong> 选项。Face size 值越大，渲染出来的立方体纹理分辨率越大，效果可能更好，但需要占用的内存也越大，这可以由面板最下方显示的内存大小得到。</p><p>准备好了需要的立方体纹理后，我们就可以对物体使用环境映射技术。而环境映射最常见的应用就是反射和折射。</p><h3 id="反射">反射</h3><p>使用了反射效果的物体通常看起来就像镀了层金属。想要模拟反射效果很简单，我们只需要通过入射光线的方向和表面法线方向来计算反射方向，再利用反射方向对立方体纹理采样即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br><br>Shader &quot;Custom/Chapter10/Chapter10-Reflection&quot;<br>&#123;<br>    Properties &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)<br>        _ReflectColor (&quot;Reflection Color&quot;, Color) = (1, 1, 1, 1)<br>        _ReflectAmount (&quot;Reflection Amount&quot;, Range(0, 1)) = 1<br>        _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<br>    &#125;<br><br>    SubShader &#123;<br>        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot; &#125;<br><br>        Pass &#123;<br><br>            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br>            <br>            CGPROGRAM<br>            #pragma multi_compile_fwdbase<br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br>#include &quot;AutoLight.cginc&quot;<br><br>            fixed4 _Color;<br>            fixed4 _ReflectColor;<br>            float _ReflectAmount;<br>            samplerCUBE _Cubemap;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldPos : TEXCOORD0;<br>                float3 worldNormal : TEXCOORD1;<br>                float3 worldViewDir : TEXCOORD2;<br>                float3 worldRefl : TEXCOORD3;<br>                SHADOW_COORDS(4)<br>            &#125;;<br><br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);<br>                o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);<br>                <br>                TRANSFER_SHADOW(o);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET &#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed3 worldViewDir = normalize(i.worldViewDir);<br><br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br><br>                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0,dot(worldNormal,worldLightDir));<br><br>                fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb;<br><br>                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br><br>                fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten;<br><br>                return fixed4(color, 1.0);<br>            &#125;<br><br>            <br><br>            ENDCG<br>        &#125;<br><br>    &#125;<br><br>    FallBack &quot;Reflective/VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>_ReflectColor 用于控制反射颜色，_ReflectAmount 用于控制这个材质的反射程度，而 _Cubemap 就是用于模拟反射的环境映射纹理。使用 CG 中的 <strong>reflect</strong> 函数来计算顶点处的反射方向。物体反射到摄像机中的光线方向，可以由光路可逆的原则来求得。也就是说，我们可以计算视角方向关于顶点法线的反射方向来求得入射光线的方向。</p><p>对立方体纹理的采样需要使用 CG 的 <strong>texCUBE</strong> 函数。注意到，在上面的计算中，我们在采样时并没有对 i.worldRefl 进行归一化操作。这是因为，用于采样的参数仅仅是作为方向变量传递给 texCUBE 函数的，因此我们没有必要进行一次归一化的操作。然后，我们使用 _ReflectAmount 来混合漫反射颜色和反射颜色，并和环境光照相加后返回。</p><p>在上面的计算中，我们选择在顶点着色器中计算反射方向。当然，我们也可以选择在片元着色器中计算，这样得到的效果更加细腻。但是，对于绝大多数人来说这种差别往往是可以忽略不计的，因此出于性能方面的考虑，我们选择在顶点着色器中计算反射方向。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_7.png" alt="反射效果" title="反射效果"></p><h3 id="折射">折射</h3><p>当光线从一种介质（例如空气）斜射入另一种介质（例如玻璃）时，传播方向一般会发生改变。当给定入射角时，我们可以使用**斯涅尔定律（Snell’s Law）**来计算反射角。当光从介质 1 沿着和表面法线夹角为 $\theta _1$ 的方向斜射入介质 2 时，我们可以使用如下公式计算折射光线和法线的夹角 $\theta _2$ ：</p><p>$$<br>\eta _1\sin\theta _1 = \eta _2\sin\theta _2<br>$$</p><p>其中，$\eta _1$ 和 $\eta _2$ 分别是两个介质的<strong>折射率（index of refraction）</strong>。折射率是一项重要的物理常数，例如真空的折射率是 1，而玻璃的折射率一般是 1.5。下图给出了这些变量之间的关系。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_8.png" alt="斯涅尔定律" title="斯涅尔定律"></p><p>通常来说，当得到折射方向后我们就会直接使用它来对立方体纹理进行采样，但是这是不符合物理规律的。对一个透明物体来说，一种更准确的模拟方法需要计算两次折射——一次是当光线进入它的内部时，而另一次则是从它内部射出时。但是，想要在实时渲染中模拟出第二次折射方向是比较复杂的，而且仅仅模拟一次得到的效果在视觉上看起来“也挺像那么回事的”。正如我们之前提到的——图形学第一准则“如果它看起来是对的，那么它就是对的”。因此，在实时渲染中我们通常仅模拟第一次折射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br><br>Shader &quot;Custom/Chapter10/Chapter10-Refraction&quot;<br>&#123;<br>    Properties &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)<br>        _RefractColor (&quot;Refraction Color&quot;, Color) = (1, 1, 1, 1)<br>        _RefractAmount (&quot;Refraction Amount&quot;, Range(0, 1)) = 1<br>        _RefractRatio (&quot;Refraction Ratio&quot;, Range(0.1, 1)) = 0.5<br>        _Cubemap (&quot;Refraction Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<br>    &#125;<br><br>    SubShader &#123;<br>        Tags &#123; &quot;RenderType&quot; = &quot;Opaque&quot; &quot;Queue&quot; = &quot;Geometry&quot; &#125;<br><br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br>            <br>            #pragma multi_compile_fwdbase<br><br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br>            #include &quot;AutoLight.cginc&quot;<br><br>            fixed4 _Color;<br>            fixed4 _RefractColor;<br>            float _RefractAmount;<br>            fixed _RefractRatio;<br>            samplerCUBE _Cubemap;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldPos : TEXCOORD0;<br>                fixed3 worldNormal : TEXCOORD1;<br>                fixed3 worldViewDir : TEXCOORD2;<br>                fixed3 worldRefr : TEXCOORD3;<br>                SHADOW_COORDS(4)<br><br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);<br><br>                o.worldRefr = refract(-normalize(o.worldViewDir), normalize(o.worldNormal), _RefractRatio);<br><br>                TRANSFER_SHADOW(o);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET &#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed3 worldViewDir = normalize(i.worldViewDir);<br><br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br>                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir));<br><br>                fixed3 refraction = texCUBE(_Cubemap, i.worldRefr).xyz * _RefractColor.rgb;<br><br>                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br><br>                fixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten;<br><br>                return fixed4(color, 1.0);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    Fallback &quot;Reflective/VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们使用 _RefractRatio 得到不同介质的透射比来计算折射方向，其他属性和控制反射时使用的属性类似。我们使用了 CG 的 <strong>refract</strong> 函数来计算折射方向。它的第一个参数即为入射光线的方向，它必须是归一化后的矢量；第二个参数是表面法线，法线方向同样需要是归一化后的；第三个参数是入射光线所在介质的折射率和折射光线所在介质的折射率之间的比值，例如如果是光从空气射到玻璃表面，那么这个参数应该是空气的折射率和玻璃的折射率之间的比值，即 1/1.5。它的返回值就是计算而得的折射方向，它的模则等于入射光线的模。</p><p>同样，我们也没有对 i.worldRefr 进行归一化操作，因为对立方体纹理的采样只需要提供方向即可。最后，我们使用 _RefractAmount 来混合漫反射颜色和折射颜色，并和环境光照相加后返回。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_9.png" alt="折射效果" title="折射效果"></p><h3 id="菲涅耳反射">菲涅耳反射</h3><p>在实时渲染中，我们经常会使用**菲涅耳反射（Fresnel reflection）**来根据视角方向控制反射程度。通俗地讲，菲涅耳反射描述了一种光学现象，即当光线照射到物体表面上时，一部分发生反射，一部分进入物体内部，发生折射或散射。被反射的光和入射光之间存在一定的比率关系，这个比率关系可以通过菲涅耳等式进行计算。真实世界的菲涅耳等式是非常复杂的，但在实时渲染中，我们通常会用一些近似公式来计算。其中一个著名的近似公式就是 <strong>Schlick 菲涅耳近似等式</strong>：<br>$$<br>F_{Schlick}(v, n) = F_0 + (1 - F_0)(1 - v \cdot n)^5<br>$$</p><p>其中，$F_0$ 是一个反射系数，用于控制菲涅耳反射的强度，$v$ 是视角方向，$n$ 是表面法线。另一个应用比较广泛的等式是 <strong>Empricial 菲涅耳近似等式</strong>：<br>$$<br>F_{Empricial}(v, n) = \max(0, \min(1, bias + scale \times (1 - v \cdot n)^{power}))<br>$$</p><p>其中，$bias$、$scale$ 和 $power$ 是控制项。</p><p>使用上面的菲涅耳近似等式，我们可以在边界处模拟反射光强和折射光强/漫反射光强之间的变化。在许多车漆、水面等材质的渲染中，我们会经常使用菲涅耳反射来模拟更加真实的反射效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;<br><br>Shader &quot;Custom/Chapter10/Chapter10-Fresnel&quot;<br>&#123;<br>    Properties<br>    &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)<br>        _FresnelScale (&quot;Fresnel Scale&quot;, Range(0, 1)) = 0.5<br>        _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<br>        <br>    &#125;<br><br>    SubShader<br>    &#123;<br>        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot; &#125;<br><br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br><br>            #pragma multi_compile_fwdbase<br>            #pragma vertex vert<br>            #pragma fragment frag<br><br>            #include &quot;Lighting.cginc&quot;<br>            #include &quot;AutoLight.cginc&quot;<br><br>            fixed4 _Color;<br>            fixed _FresnelScale;<br>            samplerCUBE _Cubemap;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldPos : TEXCOORD0;<br>                fixed3 worldNormal : TEXCOORD1;<br>                fixed3 worldViewDir : TEXCOORD2;<br>                fixed3 worldRefl : TEXCOORD3;<br>                SHADOW_COORDS(4)<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);<br>                o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);<br>                TRANSFER_SHADOW(o);<br>                return o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_TARGET &#123;<br>                fixed3 worldNormal = normalize(i.worldNormal);<br>                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));<br>                fixed3 worldViewDir = normalize(i.worldViewDir);<br><br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br>                UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br>                fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb;<br><br>                fixed fresnel = _FresnelScale + (1 - _FresnelScale) * pow(1 - dot(worldViewDir, worldNormal), 5);<br>                fixed3 diffuse = _LightColor0.rgb * _Color.rgb * max(0, dot(worldNormal, worldLightDir));<br>                fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;<br>                return fixed4(color, 1.0);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Reflective/VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用 Schlick 菲涅耳近似等式来计算 fresnel 变量，并使用它来混合漫反射光照和反射光照。一些实现也会直接把 fresnel 和反射光照相乘后叠加到漫反射光照上，模拟边缘光照的效果。</p><p><img src="/posts_image/Advanced_Texture/Advanced_Texture_10.png" alt="菲涅耳反射效果" title="菲涅耳反射效果"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;立方体纹理&quot;&gt;立方体纹理&lt;/h2&gt;
&lt;p&gt;在图形学中，**立方体纹理（Cubemap）&lt;strong&gt;是&lt;/strong&gt;环境映射（Environment Mapping）**的一种实现方法。环境映射可以模拟物体周围的环境，而使用了环境映射的物体可以看起来像镀了层</summary>
      
    
    
    
    <category term="Unity Shader" scheme="http://example.com/categories/Unity-Shader/"/>
    
    
    <category term="Texture" scheme="http://example.com/tags/Texture/"/>
    
  </entry>
  
  <entry>
    <title>插值函数</title>
    <link href="http://example.com/posts/%E6%8F%92%E5%80%BC%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/posts/%E6%8F%92%E5%80%BC%E5%87%BD%E6%95%B0/</id>
    <published>2022-02-20T08:15:09.000Z</published>
    <updated>2025-04-17T12:55:15.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性插值函数">线性插值函数</h2><p>$$<br>lerp(y_1, y_2, weight) = y_1 + (y_2 - y_1) \times weight<br>$$</p><p>其中 $weight$ 是一个在 [0, 1] 区间的实数，倒不是因为取更大的值后这个函数就无定义了，而是因为取了更大的值，这个函数就失去了我们构造它的理由，另外，CG 会限制 $weight$ 的值在 [0, 1] 的范围内，超过这个范围会被留在边界 0 或者边界 1。</p><p>这里 $y_1$ 被称为起点，而 $y_2$ 被称为终点，lerp 函数就是取值 $y_1$ 到 $y_2$ 中间的一个值。取值由 $weight$ 来控制，当 $weight$ 为 0.5 时，取值刚好在起点和终点之间。为了更加方便理解，可以把公式写成这种形式：<br>$$<br>lerp(y_1, y_2, weight) = (1 - weight) \times y_1 + weight \times y_2<br>$$</p><p>简单来说，lerp 函数是在 $y_1$ 和 $y_2$ 之间过渡。$y_1$ 和 $y_2$ 可以是一个值，也可以是一个函数。比如，我们可以在正弦函数和线性函数之间做过渡，我们先看一下正弦函数：</p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_1.png" alt="正弦函数曲线" title="正弦函数曲线"></p><p>再看一下最简单的线性函数 $y = x$</p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_2.png" alt="线性函数曲线" title="线性函数曲线"></p><p>在它俩之间过渡，我们只需要使用 $lerp(\sin x, x, 0.5)$ 即可。当然可以调整 $weight$ 参数观察不同的结果。</p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_3.png" alt="weight 为 0.5" title="weight 为 0.5"></p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_4.png" alt="weight 为 0.8" title="weight 为 0.8"></p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_5.png" alt="weight 为 0.2" title="weight 为 0.2"></p><p>当 $y_1$ 和 $y_2$ 分别为两个点时，结果就是两点间的位置。</p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_6.png" alt="线性插值" title="线性插值"></p><h4 id="贝塞尔曲线">贝塞尔曲线</h4><p>当有 $A$、$B$、$C$ 三个点且有 $D$ 为从 $A$ 到 $C$ 上权重为 $t$ 的插值，$E$ 为从 $C$ 到 $B$ 上权重为 $t$ 的插值，点 $F$ 为从 $D$ 到 $E$ 上权重为 $t$ 的插值，则点 $F$ 是以 $A$ 为起点、$B$ 为终点、$C$ 为控制点的二阶贝塞尔曲线上的一点。</p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_7.png" alt="贝塞尔二阶曲线上的点" title="贝塞尔二阶曲线上的点"></p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_8.png" alt="贝塞尔二阶曲线上的点" title="贝塞尔二阶曲线上的点"></p><p>同理，当有 $A$、$B$、$C$、$D$ 四个点，$E$ 为从 $A$ 到 $C$ 上权重为 $t$ 的插值，$F$ 为从 $C$ 到 $D$ 上权重为 $t$ 的插值，$G$ 为从 $D$ 到 $B$ 上权重为 $t$ 的插值，且 $H$ 为从 $E$ 到 $F$ 上权重为 $t$ 的插值，$I$ 为从 $F$ 到 $G$ 上权重为 $t$ 的插值，$J$ 为从 $H$ 到 $I$ 上权重为 $t$ 的插值，则点 $J$ 是以 $A$ 为起点、$B$ 为终点、$C$ 和 $D$ 为控制点的三阶贝塞尔曲线上的一点。</p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_9.png" alt="贝塞尔三阶曲线上的点" title="贝塞尔三阶曲线上的点"></p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_10.png" alt="贝塞尔三阶曲线上的点" title="贝塞尔三阶曲线上的点"></p><h6 id="二阶贝塞尔曲线公式推导">二阶贝塞尔曲线公式推导</h6><p>由 $f(p_0, p_1, t) = (p_1 - p_0) \times t + p_0$ 可得：</p><p>$$<br>\begin{aligned}<br>D &amp;= (C - A)t + A\<br>E &amp;= (B - C)t + C\<br>F &amp;= (E - D)t + D\<br>&amp;= (((B - C)t + C) - ((C - A)t + A)t + ((C - A)t + A))\<br>&amp;= (At + Bt -2Ct + C - A)t + Ct - At + A\<br>&amp;= (t - 1)^2A + t^2B + 2t(1 - t)C\<br>\<br>B(t) &amp;= (1 - t)^2A + t^2B + 2t(1 - t)C, t \in [0, 1]<br>\end{aligned}<br>$$</p><h6 id="三阶贝塞尔曲线公式推导">三阶贝塞尔曲线公式推导</h6><p>由 $f(p_0, p_1, t) = (p_1 - p_0) \times t + p_0$ 可得：</p><p>$$<br>\begin{aligned}<br>E &amp;= (C - A)t + A\<br>F &amp;= (D - C)t + C\<br>G &amp;= (B - D)t + D\<br>\end{aligned}<br>$$</p><p>$H$ 可以看作以 $A$ 为起点、$D$ 为终点、$C$ 为控制点的二阶贝塞尔曲线上的点，$I$ 可以看作以 $C$ 为起点、$B$ 为终点、$D$ 为控制点的二阶贝塞尔曲线上的点，所以由二阶贝塞尔曲线公式可得：</p><p>$$<br>\begin{aligned}<br>H &amp;= (F - E)t + E\<br>&amp;= (1 - t)^2A + t^2D + 2t(1 - t)C\<br>\<br>I &amp;= (G - F)t + F\<br>&amp;= (1 - t)^2C + t^2B + 2t(1 - t)D\<br>\<br>J &amp;= (I - H)t + H\<br>&amp;= (((1 - t)^2C + t^2B + 2t(1 - t)D) - ((1 - t)^2A + t^2D + 2t(1 - t)C))t + ((1 - t)^2A + t^2D + 2t(1 - t)C)\<br>&amp;= (1 - t)^3A + t^3B + 3t(1 - t)^2C + 3t^2(1 - t)D\<br>\<br>B(t) &amp;= (1 - t)^3A + t^3B + 3t(1 - t)^2C + 3t^2(1 - t)D, t \in [0, 1]<br>\end{aligned}<br>$$</p><p>或者 $J$ 也可以看作以 $E$ 为起点、$G$ 为终点、$F$ 为控制点的二阶贝塞尔曲线上的点，由二阶贝塞尔曲线公式可得：</p><p>$$<br>\begin{aligned}<br>E &amp;= (C - A)t + A\<br>F &amp;= (D - C)t + C\<br>G &amp;= (B - D)t + D\<br>J &amp;= (1 - t)^2E + t^2G + 2t(1 - t)F\<br>&amp;= (1 - t)^2((C - A)t + A) + t^2((B - D)t + D) + 2t(1 - t)((D - C)t + C)\<br>&amp;= (1 - t)^3A + t^3B + 3t(1 - t)^2C + 3t^2(1 - t)D\<br>\<br>B(t) &amp;= (1 - t)^3A + t^3B + 3t(1 - t)^2C + 3t^2(1 - t)D, t \in [0, 1]<br>\end{aligned}<br>$$</p><h2 id="阶梯插值函数">阶梯插值函数</h2><p>step 函数的逻辑是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">step(a, x)&#123;<br>    if(x &lt; a)<br>        return 0;<br>    else<br>        return 1;  <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_11.png" alt="阶梯插值函数" title="阶梯插值函数"></p><h2 id="平滑阶梯插值函数">平滑阶梯插值函数</h2><p>smoothstep 函数可以用来生成 0 到 1 的平滑过渡值，它也叫平滑阶梯函数。smoothstep 函数的定义是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shaderlab">float smoothstep(float a, float b, float x) <br>&#123;<br>  x = clamp((x - a) / (b- a), 0.0, 1.0); <br>  return x * x * (3 - 2 * x);<br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说就是：</p><ul><li>在 a &lt; b 的情况下，当 x &lt; a 时，返回 0，当 x &gt; b 时，返回 1，否则在 0 和 1 之间平滑过渡：</li></ul><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_12.png" alt="平滑阶梯插值函数" title="平滑阶梯插值函数"></p><ul><li>在 a &gt; b 的情况下，当 x &lt; b 时，返回 1，当 x &gt; a 时，返回 0，否则在 0 和 1 之间平滑过渡：</li></ul><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_13.png" alt="平滑阶梯插值函数" title="平滑阶梯插值函数"></p><p>两个 smoothstep 进行减法运算可以得到一些波形图，例如 smoothstep(1, 2, x) - smoothstep(2, 3, x):</p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_14.png" alt="smoothstep(1, 2, x) - smoothstep(2, 3, x)" title="smoothstep(1, 2, x) - smoothstep(2, 3, x)"></p><p>想要增加波峰的持续宽度，可以构造 smoothstep(1, 2, x) - smoothstep(3, 4, x)：</p><p><img src="/posts_image/InterpolationFunction/InterpolationFunction_15.png" alt="smoothstep(1, 2, x) - smoothstep(3, 4, x)" title="smoothstep(1, 2, x) - smoothstep(3, 4, x)"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线性插值函数&quot;&gt;线性插值函数&lt;/h2&gt;
&lt;p&gt;$$&lt;br&gt;
lerp(y_1, y_2, weight) = y_1 + (y_2 - y_1) \times weight&lt;br&gt;
$$&lt;/p&gt;
&lt;p&gt;其中 $weight$ 是一个在 [0, 1] 区间的实数，倒</summary>
      
    
    
    
    <category term="Unity Shader" scheme="http://example.com/categories/Unity-Shader/"/>
    
    
    <category term="Math" scheme="http://example.com/tags/Math/"/>
    
  </entry>
  
</feed>
